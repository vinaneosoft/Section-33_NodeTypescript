{"version":3,"file":"2155.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/utils.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/equals.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/logging.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languageService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesAssociations.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/languagesRegistry.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/autorun.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/promise.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/lazyObservableValue.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/api.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/base.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/debugName.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/observableInternal/derived.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Event } from '../event.js';\nimport { DisposableStore, toDisposable } from '../lifecycle.js';\nimport { BaseObservable, ConvenientObservable, _setKeepObserved, _setRecomputeInitiallyAndOnChange, subtransaction, transaction } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { derived, derivedOpts } from './derived.js';\nimport { getLogger } from './logging.js';\nimport { strictEquals } from '../equals.js';\n/**\n * Represents an efficient observable whose value never changes.\n */\nexport function constObservable(value) {\n    return new ConstObservable(value);\n}\nclass ConstObservable extends ConvenientObservable {\n    constructor(value) {\n        super();\n        this.value = value;\n    }\n    get debugName() {\n        return this.toString();\n    }\n    get() {\n        return this.value;\n    }\n    addObserver(observer) {\n        // NO OP\n    }\n    removeObserver(observer) {\n        // NO OP\n    }\n    toString() {\n        return `Const: ${this.value}`;\n    }\n}\nexport function observableFromEvent(...args) {\n    let owner;\n    let event;\n    let getValue;\n    if (args.length === 3) {\n        [owner, event, getValue] = args;\n    }\n    else {\n        [event, getValue] = args;\n    }\n    return new FromEventObservable(new DebugNameData(owner, undefined, getValue), event, getValue, () => FromEventObservable.globalTransaction, strictEquals);\n}\nexport function observableFromEventOpts(options, event, getValue) {\n    return new FromEventObservable(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? getValue), event, getValue, () => FromEventObservable.globalTransaction, options.equalsFn ?? strictEquals);\n}\nexport class FromEventObservable extends BaseObservable {\n    constructor(_debugNameData, event, _getValue, _getTransaction, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this.event = event;\n        this._getValue = _getValue;\n        this._getTransaction = _getTransaction;\n        this._equalityComparator = _equalityComparator;\n        this.hasValue = false;\n        this.handleEvent = (args) => {\n            const newValue = this._getValue(args);\n            const oldValue = this.value;\n            const didChange = !this.hasValue || !(this._equalityComparator(oldValue, newValue));\n            let didRunTransaction = false;\n            if (didChange) {\n                this.value = newValue;\n                if (this.hasValue) {\n                    didRunTransaction = true;\n                    subtransaction(this._getTransaction(), (tx) => {\n                        getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n                        for (const o of this.observers) {\n                            tx.updateObserver(o, this);\n                            o.handleChange(this, undefined);\n                        }\n                    }, () => {\n                        const name = this.getDebugName();\n                        return 'Event fired' + (name ? `: ${name}` : '');\n                    });\n                }\n                this.hasValue = true;\n            }\n            if (!didRunTransaction) {\n                getLogger()?.handleFromEventObservableTriggered(this, { oldValue, newValue, change: undefined, didChange, hadValue: this.hasValue });\n            }\n        };\n    }\n    getDebugName() {\n        return this._debugNameData.getDebugName(this);\n    }\n    get debugName() {\n        const name = this.getDebugName();\n        return 'From Event' + (name ? `: ${name}` : '');\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n        this.hasValue = false;\n        this.value = undefined;\n    }\n    get() {\n        if (this.subscription) {\n            if (!this.hasValue) {\n                this.handleEvent(undefined);\n            }\n            return this.value;\n        }\n        else {\n            // no cache, as there are no subscribers to keep it updated\n            const value = this._getValue(undefined);\n            return value;\n        }\n    }\n}\n(function (observableFromEvent) {\n    observableFromEvent.Observer = FromEventObservable;\n    function batchEventsGlobally(tx, fn) {\n        let didSet = false;\n        if (FromEventObservable.globalTransaction === undefined) {\n            FromEventObservable.globalTransaction = tx;\n            didSet = true;\n        }\n        try {\n            fn();\n        }\n        finally {\n            if (didSet) {\n                FromEventObservable.globalTransaction = undefined;\n            }\n        }\n    }\n    observableFromEvent.batchEventsGlobally = batchEventsGlobally;\n})(observableFromEvent || (observableFromEvent = {}));\nexport function observableSignalFromEvent(debugName, event) {\n    return new FromEventObservableSignal(debugName, event);\n}\nclass FromEventObservableSignal extends BaseObservable {\n    constructor(debugName, event) {\n        super();\n        this.debugName = debugName;\n        this.event = event;\n        this.handleEvent = () => {\n            transaction((tx) => {\n                for (const o of this.observers) {\n                    tx.updateObserver(o, this);\n                    o.handleChange(this, undefined);\n                }\n            }, () => this.debugName);\n        };\n    }\n    onFirstObserverAdded() {\n        this.subscription = this.event(this.handleEvent);\n    }\n    onLastObserverRemoved() {\n        this.subscription.dispose();\n        this.subscription = undefined;\n    }\n    get() {\n        // NO OP\n    }\n}\nexport function observableSignal(debugNameOrOwner) {\n    if (typeof debugNameOrOwner === 'string') {\n        return new ObservableSignal(debugNameOrOwner);\n    }\n    else {\n        return new ObservableSignal(undefined, debugNameOrOwner);\n    }\n}\nclass ObservableSignal extends BaseObservable {\n    get debugName() {\n        return new DebugNameData(this._owner, this._debugName, undefined).getDebugName(this) ?? 'Observable Signal';\n    }\n    toString() {\n        return this.debugName;\n    }\n    constructor(_debugName, _owner) {\n        super();\n        this._debugName = _debugName;\n        this._owner = _owner;\n    }\n    trigger(tx, change) {\n        if (!tx) {\n            transaction(tx => {\n                this.trigger(tx, change);\n            }, () => `Trigger signal ${this.debugName}`);\n            return;\n        }\n        for (const o of this.observers) {\n            tx.updateObserver(o, this);\n            o.handleChange(this, change);\n        }\n    }\n    get() {\n        // NO OP\n    }\n}\n/**\n * This makes sure the observable is being observed and keeps its cache alive.\n */\nexport function keepObserved(observable) {\n    const o = new KeepAliveObserver(false, undefined);\n    observable.addObserver(o);\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setKeepObserved(keepObserved);\n/**\n * This converts the given observable into an autorun.\n */\nexport function recomputeInitiallyAndOnChange(observable, handleValue) {\n    const o = new KeepAliveObserver(true, handleValue);\n    observable.addObserver(o);\n    if (handleValue) {\n        handleValue(observable.get());\n    }\n    else {\n        observable.reportChanges();\n    }\n    return toDisposable(() => {\n        observable.removeObserver(o);\n    });\n}\n_setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange);\nexport class KeepAliveObserver {\n    constructor(_forceRecompute, _handleValue) {\n        this._forceRecompute = _forceRecompute;\n        this._handleValue = _handleValue;\n        this._counter = 0;\n    }\n    beginUpdate(observable) {\n        this._counter++;\n    }\n    endUpdate(observable) {\n        this._counter--;\n        if (this._counter === 0 && this._forceRecompute) {\n            if (this._handleValue) {\n                this._handleValue(observable.get());\n            }\n            else {\n                observable.reportChanges();\n            }\n        }\n    }\n    handlePossibleChange(observable) {\n        // NO OP\n    }\n    handleChange(observable, change) {\n        // NO OP\n    }\n}\nexport function derivedObservableWithCache(owner, computeFn) {\n    let lastValue = undefined;\n    const observable = derivedOpts({ owner, debugReferenceFn: computeFn }, reader => {\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return observable;\n}\nexport function derivedObservableWithWritableCache(owner, computeFn) {\n    let lastValue = undefined;\n    const onChange = observableSignal('derivedObservableWithWritableCache');\n    const observable = derived(owner, reader => {\n        onChange.read(reader);\n        lastValue = computeFn(reader, lastValue);\n        return lastValue;\n    });\n    return Object.assign(observable, {\n        clearCache: (tx) => {\n            lastValue = undefined;\n            onChange.trigger(tx);\n        },\n        setCache: (newValue, tx) => {\n            lastValue = newValue;\n            onChange.trigger(tx);\n        }\n    });\n}\n/**\n * When the items array changes, referential equal items are not mapped again.\n */\nexport function mapObservableArrayCached(owner, items, map, keySelector) {\n    let m = new ArrayMap(map, keySelector);\n    const self = derivedOpts({\n        debugReferenceFn: map,\n        owner,\n        onLastObserverRemoved: () => {\n            m.dispose();\n            m = new ArrayMap(map);\n        }\n    }, (reader) => {\n        m.setItems(items.read(reader));\n        return m.getItems();\n    });\n    return self;\n}\nclass ArrayMap {\n    constructor(_map, _keySelector) {\n        this._map = _map;\n        this._keySelector = _keySelector;\n        this._cache = new Map();\n        this._items = [];\n    }\n    dispose() {\n        this._cache.forEach(entry => entry.store.dispose());\n        this._cache.clear();\n    }\n    setItems(items) {\n        const newItems = [];\n        const itemsToRemove = new Set(this._cache.keys());\n        for (const item of items) {\n            const key = this._keySelector ? this._keySelector(item) : item;\n            let entry = this._cache.get(key);\n            if (!entry) {\n                const store = new DisposableStore();\n                const out = this._map(item, store);\n                entry = { out, store };\n                this._cache.set(key, entry);\n            }\n            else {\n                itemsToRemove.delete(key);\n            }\n            newItems.push(entry.out);\n        }\n        for (const item of itemsToRemove) {\n            const entry = this._cache.get(item);\n            entry.store.dispose();\n            this._cache.delete(item);\n        }\n        this._items = newItems;\n    }\n    getItems() {\n        return this._items;\n    }\n}\nexport class ValueWithChangeEventFromObservable {\n    constructor(observable) {\n        this.observable = observable;\n    }\n    get onDidChange() {\n        return Event.fromObservableLight(this.observable);\n    }\n    get value() {\n        return this.observable.get();\n    }\n}\nexport function observableFromValueWithChangeEvent(owner, value) {\n    if (value instanceof ValueWithChangeEventFromObservable) {\n        return value.observable;\n    }\n    return observableFromEvent(owner, value.onDidChange, () => value.value);\n}\n/**\n * Works like a derived.\n * However, if the value is not undefined, it is cached and will not be recomputed anymore.\n * In that case, the derived will unsubscribe from its dependencies.\n*/\nexport function derivedConstOnceDefined(owner, fn) {\n    return derivedObservableWithCache(owner, (reader, lastValue) => lastValue ?? fn(reader));\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from './arrays.js';\n/**\n * Compares two items for equality using strict equality.\n*/\nexport const strictEquals = (a, b) => a === b;\n/**\n * Checks if the items of two arrays are equal.\n * By default, strict equality is used to compare elements, but a custom equality comparer can be provided.\n */\nexport function itemsEquals(itemEquals = strictEquals) {\n    return (a, b) => arrays.equals(a, b, itemEquals);\n}\n/**\n * Uses `item.equals(other)` to determine equality.\n */\nexport function itemEquals() {\n    return (a, b) => a.equals(b);\n}\nexport function equalsIfDefined(equalsOrV1, v2, equals) {\n    if (equals !== undefined) {\n        const v1 = equalsOrV1;\n        if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n            return v2 === v1;\n        }\n        return equals(v1, v2);\n    }\n    else {\n        const equals = equalsOrV1;\n        return (v1, v2) => {\n            if (v1 === undefined || v1 === null || v2 === undefined || v2 === null) {\n                return v2 === v1;\n            }\n            return equals(v1, v2);\n        };\n    }\n}\n/**\n * Drills into arrays (items ordered) and objects (keys unordered) and uses strict equality on everything else.\n*/\nexport function structuralEquals(a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (Array.isArray(a) && Array.isArray(b)) {\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0; i < a.length; i++) {\n            if (!structuralEquals(a[i], b[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    if (a && typeof a === 'object' && b && typeof b === 'object') {\n        if (Object.getPrototypeOf(a) === Object.prototype && Object.getPrototypeOf(b) === Object.prototype) {\n            const aObj = a;\n            const bObj = b;\n            const keysA = Object.keys(aObj);\n            const keysB = Object.keys(bObj);\n            const keysBSet = new Set(keysB);\n            if (keysA.length !== keysB.length) {\n                return false;\n            }\n            for (const key of keysA) {\n                if (!keysBSet.has(key)) {\n                    return false;\n                }\n                if (!structuralEquals(aObj[key], bObj[key])) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    }\n    return false;\n}\nconst objIds = new WeakMap();\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nlet globalObservableLogger;\nexport function setLogger(logger) {\n    globalObservableLogger = logger;\n}\nexport function getLogger() {\n    return globalObservableLogger;\n}\nexport class ConsoleObservableLogger {\n    constructor() {\n        this.indentation = 0;\n        this.changedObservablesSets = new WeakMap();\n    }\n    textToConsoleArgs(text) {\n        return consoleTextToArgs([\n            normalText(repeat('|  ', this.indentation)),\n            text,\n        ]);\n    }\n    formatInfo(info) {\n        if (!info.hadValue) {\n            return [\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n                normalText(` (initial)`),\n            ];\n        }\n        return info.didChange\n            ? [\n                normalText(` `),\n                styled(formatValue(info.oldValue, 70), {\n                    color: 'red',\n                    strikeThrough: true,\n                }),\n                normalText(` `),\n                styled(formatValue(info.newValue, 60), {\n                    color: 'green',\n                }),\n            ]\n            : [normalText(` (unchanged)`)];\n    }\n    handleObservableChanged(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable value changed'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n        ]));\n    }\n    formatChanges(changes) {\n        if (changes.size === 0) {\n            return undefined;\n        }\n        return styled(' (changed deps: ' +\n            [...changes].map((o) => o.debugName).join(', ') +\n            ')', { color: 'gray' });\n    }\n    handleDerivedCreated(derived) {\n        const existingHandleChange = derived.handleChange;\n        this.changedObservablesSets.set(derived, new Set());\n        derived.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(derived).add(observable);\n            return existingHandleChange.apply(derived, [observable, change]);\n        };\n    }\n    handleDerivedRecomputed(derived, info) {\n        const changedObservables = this.changedObservablesSets.get(derived);\n        console.log(...this.textToConsoleArgs([\n            formatKind('derived recomputed'),\n            styled(derived.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: derived._debugNameData.referenceFn ?? derived._computeFn }] }\n        ]));\n        changedObservables.clear();\n    }\n    handleFromEventObservableTriggered(observable, info) {\n        console.log(...this.textToConsoleArgs([\n            formatKind('observable from event triggered'),\n            styled(observable.debugName, { color: 'BlueViolet' }),\n            ...this.formatInfo(info),\n            { data: [{ fn: observable._getValue }] }\n        ]));\n    }\n    handleAutorunCreated(autorun) {\n        const existingHandleChange = autorun.handleChange;\n        this.changedObservablesSets.set(autorun, new Set());\n        autorun.handleChange = (observable, change) => {\n            this.changedObservablesSets.get(autorun).add(observable);\n            return existingHandleChange.apply(autorun, [observable, change]);\n        };\n    }\n    handleAutorunTriggered(autorun) {\n        const changedObservables = this.changedObservablesSets.get(autorun);\n        console.log(...this.textToConsoleArgs([\n            formatKind('autorun'),\n            styled(autorun.debugName, { color: 'BlueViolet' }),\n            this.formatChanges(changedObservables),\n            { data: [{ fn: autorun._debugNameData.referenceFn ?? autorun._runFn }] }\n        ]));\n        changedObservables.clear();\n        this.indentation++;\n    }\n    handleAutorunFinished(autorun) {\n        this.indentation--;\n    }\n    handleBeginTransaction(transaction) {\n        let transactionName = transaction.getDebugName();\n        if (transactionName === undefined) {\n            transactionName = '';\n        }\n        console.log(...this.textToConsoleArgs([\n            formatKind('transaction'),\n            styled(transactionName, { color: 'BlueViolet' }),\n            { data: [{ fn: transaction._fn }] }\n        ]));\n        this.indentation++;\n    }\n    handleEndTransaction() {\n        this.indentation--;\n    }\n}\nfunction consoleTextToArgs(text) {\n    const styles = new Array();\n    const data = [];\n    let firstArg = '';\n    function process(t) {\n        if ('length' in t) {\n            for (const item of t) {\n                if (item) {\n                    process(item);\n                }\n            }\n        }\n        else if ('text' in t) {\n            firstArg += `%c${t.text}`;\n            styles.push(t.style);\n            if (t.data) {\n                data.push(...t.data);\n            }\n        }\n        else if ('data' in t) {\n            data.push(...t.data);\n        }\n    }\n    process(text);\n    const result = [firstArg, ...styles];\n    result.push(...data);\n    return result;\n}\nfunction normalText(text) {\n    return styled(text, { color: 'black' });\n}\nfunction formatKind(kind) {\n    return styled(padStr(`${kind}: `, 10), { color: 'black', bold: true });\n}\nfunction styled(text, options = {\n    color: 'black',\n}) {\n    function objToCss(styleObj) {\n        return Object.entries(styleObj).reduce((styleString, [propName, propValue]) => {\n            return `${styleString}${propName}:${propValue};`;\n        }, '');\n    }\n    const style = {\n        color: options.color,\n    };\n    if (options.strikeThrough) {\n        style['text-decoration'] = 'line-through';\n    }\n    if (options.bold) {\n        style['font-weight'] = 'bold';\n    }\n    return {\n        text,\n        style: objToCss(style),\n    };\n}\nfunction formatValue(value, availableLen) {\n    switch (typeof value) {\n        case 'number':\n            return '' + value;\n        case 'string':\n            if (value.length + 2 <= availableLen) {\n                return `\"${value}\"`;\n            }\n            return `\"${value.substr(0, availableLen - 7)}\"+...`;\n        case 'boolean':\n            return value ? 'true' : 'false';\n        case 'undefined':\n            return 'undefined';\n        case 'object':\n            if (value === null) {\n                return 'null';\n            }\n            if (Array.isArray(value)) {\n                return formatArray(value, availableLen);\n            }\n            return formatObject(value, availableLen);\n        case 'symbol':\n            return value.toString();\n        case 'function':\n            return `[[Function${value.name ? ' ' + value.name : ''}]]`;\n        default:\n            return '' + value;\n    }\n}\nfunction formatArray(value, availableLen) {\n    let result = '[ ';\n    let first = true;\n    for (const val of value) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' ]';\n    return result;\n}\nfunction formatObject(value, availableLen) {\n    let result = '{ ';\n    let first = true;\n    for (const [key, val] of Object.entries(value)) {\n        if (!first) {\n            result += ', ';\n        }\n        if (result.length - 5 > availableLen) {\n            result += '...';\n            break;\n        }\n        first = false;\n        result += `${key}: ${formatValue(val, availableLen - result.length)}`;\n    }\n    result += ' }';\n    return result;\n}\nfunction repeat(str, count) {\n    let result = '';\n    for (let i = 1; i <= count; i++) {\n        result += str;\n    }\n    return result;\n}\nfunction padStr(str, length) {\n    while (str.length < length) {\n        str += ' ';\n    }\n    return str;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LanguagesRegistry } from './languagesRegistry.js';\nimport { firstOrDefault } from '../../../base/common/arrays.js';\nimport { TokenizationRegistry } from '../languages.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { observableFromEvent } from '../../../base/common/observable.js';\nexport class LanguageService extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(warnOnOverwrite = false) {\n        super();\n        this._onDidRequestBasicLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestBasicLanguageFeatures = this._onDidRequestBasicLanguageFeatures.event;\n        this._onDidRequestRichLanguageFeatures = this._register(new Emitter());\n        this.onDidRequestRichLanguageFeatures = this._onDidRequestRichLanguageFeatures.event;\n        this._onDidChange = this._register(new Emitter({ leakWarningThreshold: 200 /* https://github.com/microsoft/vscode/issues/119968 */ }));\n        this.onDidChange = this._onDidChange.event;\n        this._requestedBasicLanguages = new Set();\n        this._requestedRichLanguages = new Set();\n        LanguageService.instanceCount++;\n        this._registry = this._register(new LanguagesRegistry(true, warnOnOverwrite));\n        this.languageIdCodec = this._registry.languageIdCodec;\n        this._register(this._registry.onDidChange(() => this._onDidChange.fire()));\n    }\n    dispose() {\n        LanguageService.instanceCount--;\n        super.dispose();\n    }\n    isRegisteredLanguageId(languageId) {\n        return this._registry.isRegisteredLanguageId(languageId);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        return this._registry.getLanguageIdByLanguageName(languageName);\n    }\n    getLanguageIdByMimeType(mimeType) {\n        return this._registry.getLanguageIdByMimeType(mimeType);\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        const languageIds = this._registry.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n        return firstOrDefault(languageIds, null);\n    }\n    createById(languageId) {\n        return new LanguageSelection(this.onDidChange, () => {\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    createByFilepathOrFirstLine(resource, firstLine) {\n        return new LanguageSelection(this.onDidChange, () => {\n            const languageId = this.guessLanguageIdByFilepathOrFirstLine(resource, firstLine);\n            return this._createAndGetLanguageIdentifier(languageId);\n        });\n    }\n    _createAndGetLanguageIdentifier(languageId) {\n        if (!languageId || !this.isRegisteredLanguageId(languageId)) {\n            // Fall back to plain text if language is unknown\n            languageId = PLAINTEXT_LANGUAGE_ID;\n        }\n        return languageId;\n    }\n    requestBasicLanguageFeatures(languageId) {\n        if (!this._requestedBasicLanguages.has(languageId)) {\n            this._requestedBasicLanguages.add(languageId);\n            this._onDidRequestBasicLanguageFeatures.fire(languageId);\n        }\n    }\n    requestRichLanguageFeatures(languageId) {\n        if (!this._requestedRichLanguages.has(languageId)) {\n            this._requestedRichLanguages.add(languageId);\n            // Ensure basic features are requested\n            this.requestBasicLanguageFeatures(languageId);\n            // Ensure tokenizers are created\n            TokenizationRegistry.getOrCreate(languageId);\n            this._onDidRequestRichLanguageFeatures.fire(languageId);\n        }\n    }\n}\nclass LanguageSelection {\n    constructor(onDidChangeLanguages, selector) {\n        this._value = observableFromEvent(this, onDidChangeLanguages, () => selector());\n        this.onDidChange = Event.fromObservable(this._value);\n    }\n    get languageId() {\n        return this._value.get();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { parse } from '../../../base/common/glob.js';\nimport { Mimes } from '../../../base/common/mime.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { basename, posix } from '../../../base/common/path.js';\nimport { DataUri } from '../../../base/common/resources.js';\nimport { startsWithUTF8BOM } from '../../../base/common/strings.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nlet registeredAssociations = [];\nlet nonUserRegisteredAssociations = [];\nlet userRegisteredAssociations = [];\n/**\n * Associate a language to the registry (platform).\n * * **NOTE**: This association will lose over associations registered using `registerConfiguredLanguageAssociation`.\n * * **NOTE**: Use `clearPlatformLanguageAssociations` to remove all associations registered using this function.\n */\nexport function registerPlatformLanguageAssociation(association, warnOnOverwrite = false) {\n    _registerLanguageAssociation(association, false, warnOnOverwrite);\n}\nfunction _registerLanguageAssociation(association, userConfigured, warnOnOverwrite) {\n    // Register\n    const associationItem = toLanguageAssociationItem(association, userConfigured);\n    registeredAssociations.push(associationItem);\n    if (!associationItem.userConfigured) {\n        nonUserRegisteredAssociations.push(associationItem);\n    }\n    else {\n        userRegisteredAssociations.push(associationItem);\n    }\n    // Check for conflicts unless this is a user configured association\n    if (warnOnOverwrite && !associationItem.userConfigured) {\n        registeredAssociations.forEach(a => {\n            if (a.mime === associationItem.mime || a.userConfigured) {\n                return; // same mime or userConfigured is ok\n            }\n            if (associationItem.extension && a.extension === associationItem.extension) {\n                console.warn(`Overwriting extension <<${associationItem.extension}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filename && a.filename === associationItem.filename) {\n                console.warn(`Overwriting filename <<${associationItem.filename}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.filepattern && a.filepattern === associationItem.filepattern) {\n                console.warn(`Overwriting filepattern <<${associationItem.filepattern}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n            if (associationItem.firstline && a.firstline === associationItem.firstline) {\n                console.warn(`Overwriting firstline <<${associationItem.firstline}>> to now point to mime <<${associationItem.mime}>>`);\n            }\n        });\n    }\n}\nfunction toLanguageAssociationItem(association, userConfigured) {\n    return {\n        id: association.id,\n        mime: association.mime,\n        filename: association.filename,\n        extension: association.extension,\n        filepattern: association.filepattern,\n        firstline: association.firstline,\n        userConfigured: userConfigured,\n        filenameLowercase: association.filename ? association.filename.toLowerCase() : undefined,\n        extensionLowercase: association.extension ? association.extension.toLowerCase() : undefined,\n        filepatternLowercase: association.filepattern ? parse(association.filepattern.toLowerCase()) : undefined,\n        filepatternOnPath: association.filepattern ? association.filepattern.indexOf(posix.sep) >= 0 : false\n    };\n}\n/**\n * Clear language associations from the registry (platform).\n */\nexport function clearPlatformLanguageAssociations() {\n    registeredAssociations = registeredAssociations.filter(a => a.userConfigured);\n    nonUserRegisteredAssociations = [];\n}\n/**\n * @see `getMimeTypes`\n */\nexport function getLanguageIds(resource, firstLine) {\n    return getAssociations(resource, firstLine).map(item => item.id);\n}\nfunction getAssociations(resource, firstLine) {\n    let path;\n    if (resource) {\n        switch (resource.scheme) {\n            case Schemas.file:\n                path = resource.fsPath;\n                break;\n            case Schemas.data: {\n                const metadata = DataUri.parseMetaData(resource);\n                path = metadata.get(DataUri.META_DATA_LABEL);\n                break;\n            }\n            case Schemas.vscodeNotebookCell:\n                // File path not relevant for language detection of cell\n                path = undefined;\n                break;\n            default:\n                path = resource.path;\n        }\n    }\n    if (!path) {\n        return [{ id: 'unknown', mime: Mimes.unknown }];\n    }\n    path = path.toLowerCase();\n    const filename = basename(path);\n    // 1.) User configured mappings have highest priority\n    const configuredLanguage = getAssociationByPath(path, filename, userRegisteredAssociations);\n    if (configuredLanguage) {\n        return [configuredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 2.) Registered mappings have middle priority\n    const registeredLanguage = getAssociationByPath(path, filename, nonUserRegisteredAssociations);\n    if (registeredLanguage) {\n        return [registeredLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n    }\n    // 3.) Firstline has lowest priority\n    if (firstLine) {\n        const firstlineLanguage = getAssociationByFirstline(firstLine);\n        if (firstlineLanguage) {\n            return [firstlineLanguage, { id: PLAINTEXT_LANGUAGE_ID, mime: Mimes.text }];\n        }\n    }\n    return [{ id: 'unknown', mime: Mimes.unknown }];\n}\nfunction getAssociationByPath(path, filename, associations) {\n    let filenameMatch = undefined;\n    let patternMatch = undefined;\n    let extensionMatch = undefined;\n    // We want to prioritize associations based on the order they are registered so that the last registered\n    // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n    for (let i = associations.length - 1; i >= 0; i--) {\n        const association = associations[i];\n        // First exact name match\n        if (filename === association.filenameLowercase) {\n            filenameMatch = association;\n            break; // take it!\n        }\n        // Longest pattern match\n        if (association.filepattern) {\n            if (!patternMatch || association.filepattern.length > patternMatch.filepattern.length) {\n                const target = association.filepatternOnPath ? path : filename; // match on full path if pattern contains path separator\n                if (association.filepatternLowercase?.(target)) {\n                    patternMatch = association;\n                }\n            }\n        }\n        // Longest extension match\n        if (association.extension) {\n            if (!extensionMatch || association.extension.length > extensionMatch.extension.length) {\n                if (filename.endsWith(association.extensionLowercase)) {\n                    extensionMatch = association;\n                }\n            }\n        }\n    }\n    // 1.) Exact name match has second highest priority\n    if (filenameMatch) {\n        return filenameMatch;\n    }\n    // 2.) Match on pattern\n    if (patternMatch) {\n        return patternMatch;\n    }\n    // 3.) Match on extension comes next\n    if (extensionMatch) {\n        return extensionMatch;\n    }\n    return undefined;\n}\nfunction getAssociationByFirstline(firstLine) {\n    if (startsWithUTF8BOM(firstLine)) {\n        firstLine = firstLine.substr(1);\n    }\n    if (firstLine.length > 0) {\n        // We want to prioritize associations based on the order they are registered so that the last registered\n        // association wins over all other. This is for https://github.com/microsoft/vscode/issues/20074\n        for (let i = registeredAssociations.length - 1; i >= 0; i--) {\n            const association = registeredAssociations[i];\n            if (!association.firstline) {\n                continue;\n            }\n            const matches = firstLine.match(association.firstline);\n            if (matches && matches.length > 0) {\n                return association;\n            }\n        }\n    }\n    return undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { regExpLeadsToEndlessLoop } from '../../../base/common/strings.js';\nimport { clearPlatformLanguageAssociations, getLanguageIds, registerPlatformLanguageAssociation } from './languagesAssociations.js';\nimport { ModesRegistry, PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { Extensions } from '../../../platform/configuration/common/configurationRegistry.js';\nimport { Registry } from '../../../platform/registry/common/platform.js';\nconst hasOwnProperty = Object.prototype.hasOwnProperty;\nconst NULL_LANGUAGE_ID = 'vs.editor.nullLanguage';\nexport class LanguageIdCodec {\n    constructor() {\n        this._languageIdToLanguage = [];\n        this._languageToLanguageId = new Map();\n        this._register(NULL_LANGUAGE_ID, 0 /* LanguageId.Null */);\n        this._register(PLAINTEXT_LANGUAGE_ID, 1 /* LanguageId.PlainText */);\n        this._nextLanguageId = 2;\n    }\n    _register(language, languageId) {\n        this._languageIdToLanguage[languageId] = language;\n        this._languageToLanguageId.set(language, languageId);\n    }\n    register(language) {\n        if (this._languageToLanguageId.has(language)) {\n            return;\n        }\n        const languageId = this._nextLanguageId++;\n        this._register(language, languageId);\n    }\n    encodeLanguageId(languageId) {\n        return this._languageToLanguageId.get(languageId) || 0 /* LanguageId.Null */;\n    }\n    decodeLanguageId(languageId) {\n        return this._languageIdToLanguage[languageId] || NULL_LANGUAGE_ID;\n    }\n}\nexport class LanguagesRegistry extends Disposable {\n    static { this.instanceCount = 0; }\n    constructor(useModesRegistry = true, warnOnOverwrite = false) {\n        super();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        LanguagesRegistry.instanceCount++;\n        this._warnOnOverwrite = warnOnOverwrite;\n        this.languageIdCodec = new LanguageIdCodec();\n        this._dynamicLanguages = [];\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        if (useModesRegistry) {\n            this._initializeFromRegistry();\n            this._register(ModesRegistry.onDidChangeLanguages((m) => {\n                this._initializeFromRegistry();\n            }));\n        }\n    }\n    dispose() {\n        LanguagesRegistry.instanceCount--;\n        super.dispose();\n    }\n    _initializeFromRegistry() {\n        this._languages = {};\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        clearPlatformLanguageAssociations();\n        const desc = [].concat(ModesRegistry.getLanguages()).concat(this._dynamicLanguages);\n        this._registerLanguages(desc);\n    }\n    _registerLanguages(desc) {\n        for (const d of desc) {\n            this._registerLanguage(d);\n        }\n        // Rebuild fast path maps\n        this._mimeTypesMap = {};\n        this._nameMap = {};\n        this._lowercaseNameMap = {};\n        Object.keys(this._languages).forEach((langId) => {\n            const language = this._languages[langId];\n            if (language.name) {\n                this._nameMap[language.name] = language.identifier;\n            }\n            language.aliases.forEach((alias) => {\n                this._lowercaseNameMap[alias.toLowerCase()] = language.identifier;\n            });\n            language.mimetypes.forEach((mimetype) => {\n                this._mimeTypesMap[mimetype] = language.identifier;\n            });\n        });\n        Registry.as(Extensions.Configuration).registerOverrideIdentifiers(this.getRegisteredLanguageIds());\n        this._onDidChange.fire();\n    }\n    _registerLanguage(lang) {\n        const langId = lang.id;\n        let resolvedLanguage;\n        if (hasOwnProperty.call(this._languages, langId)) {\n            resolvedLanguage = this._languages[langId];\n        }\n        else {\n            this.languageIdCodec.register(langId);\n            resolvedLanguage = {\n                identifier: langId,\n                name: null,\n                mimetypes: [],\n                aliases: [],\n                extensions: [],\n                filenames: [],\n                configurationFiles: [],\n                icons: []\n            };\n            this._languages[langId] = resolvedLanguage;\n        }\n        this._mergeLanguage(resolvedLanguage, lang);\n    }\n    _mergeLanguage(resolvedLanguage, lang) {\n        const langId = lang.id;\n        let primaryMime = null;\n        if (Array.isArray(lang.mimetypes) && lang.mimetypes.length > 0) {\n            resolvedLanguage.mimetypes.push(...lang.mimetypes);\n            primaryMime = lang.mimetypes[0];\n        }\n        if (!primaryMime) {\n            primaryMime = `text/x-${langId}`;\n            resolvedLanguage.mimetypes.push(primaryMime);\n        }\n        if (Array.isArray(lang.extensions)) {\n            if (lang.configuration) {\n                // insert first as this appears to be the 'primary' language definition\n                resolvedLanguage.extensions = lang.extensions.concat(resolvedLanguage.extensions);\n            }\n            else {\n                resolvedLanguage.extensions = resolvedLanguage.extensions.concat(lang.extensions);\n            }\n            for (const extension of lang.extensions) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, extension: extension }, this._warnOnOverwrite);\n            }\n        }\n        if (Array.isArray(lang.filenames)) {\n            for (const filename of lang.filenames) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filename: filename }, this._warnOnOverwrite);\n                resolvedLanguage.filenames.push(filename);\n            }\n        }\n        if (Array.isArray(lang.filenamePatterns)) {\n            for (const filenamePattern of lang.filenamePatterns) {\n                registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, filepattern: filenamePattern }, this._warnOnOverwrite);\n            }\n        }\n        if (typeof lang.firstLine === 'string' && lang.firstLine.length > 0) {\n            let firstLineRegexStr = lang.firstLine;\n            if (firstLineRegexStr.charAt(0) !== '^') {\n                firstLineRegexStr = '^' + firstLineRegexStr;\n            }\n            try {\n                const firstLineRegex = new RegExp(firstLineRegexStr);\n                if (!regExpLeadsToEndlessLoop(firstLineRegex)) {\n                    registerPlatformLanguageAssociation({ id: langId, mime: primaryMime, firstline: firstLineRegex }, this._warnOnOverwrite);\n                }\n            }\n            catch (err) {\n                // Most likely, the regex was bad\n                console.warn(`[${lang.id}]: Invalid regular expression \\`${firstLineRegexStr}\\`: `, err);\n            }\n        }\n        resolvedLanguage.aliases.push(langId);\n        let langAliases = null;\n        if (typeof lang.aliases !== 'undefined' && Array.isArray(lang.aliases)) {\n            if (lang.aliases.length === 0) {\n                // signal that this language should not get a name\n                langAliases = [null];\n            }\n            else {\n                langAliases = lang.aliases;\n            }\n        }\n        if (langAliases !== null) {\n            for (const langAlias of langAliases) {\n                if (!langAlias || langAlias.length === 0) {\n                    continue;\n                }\n                resolvedLanguage.aliases.push(langAlias);\n            }\n        }\n        const containsAliases = (langAliases !== null && langAliases.length > 0);\n        if (containsAliases && langAliases[0] === null) {\n            // signal that this language should not get a name\n        }\n        else {\n            const bestName = (containsAliases ? langAliases[0] : null) || langId;\n            if (containsAliases || !resolvedLanguage.name) {\n                resolvedLanguage.name = bestName;\n            }\n        }\n        if (lang.configuration) {\n            resolvedLanguage.configurationFiles.push(lang.configuration);\n        }\n        if (lang.icon) {\n            resolvedLanguage.icons.push(lang.icon);\n        }\n    }\n    isRegisteredLanguageId(languageId) {\n        if (!languageId) {\n            return false;\n        }\n        return hasOwnProperty.call(this._languages, languageId);\n    }\n    getRegisteredLanguageIds() {\n        return Object.keys(this._languages);\n    }\n    getLanguageIdByLanguageName(languageName) {\n        const languageNameLower = languageName.toLowerCase();\n        if (!hasOwnProperty.call(this._lowercaseNameMap, languageNameLower)) {\n            return null;\n        }\n        return this._lowercaseNameMap[languageNameLower];\n    }\n    getLanguageIdByMimeType(mimeType) {\n        if (!mimeType) {\n            return null;\n        }\n        if (hasOwnProperty.call(this._mimeTypesMap, mimeType)) {\n            return this._mimeTypesMap[mimeType];\n        }\n        return null;\n    }\n    guessLanguageIdByFilepathOrFirstLine(resource, firstLine) {\n        if (!resource && !firstLine) {\n            return [];\n        }\n        return getLanguageIds(resource, firstLine);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { DisposableStore, markAsDisposed, toDisposable, trackDisposable } from '../lifecycle.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorun(fn) {\n    return new AutorunObserver(new DebugNameData(undefined, undefined, fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n */\nexport function autorunOpts(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, undefined, undefined);\n}\n/**\n * Runs immediately and whenever a transaction ends and an observed observable changed.\n * {@link fn} should start with a JS Doc using `@description` to name the autorun.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The run function is given the last change summary.\n * The change summary is discarded after the run function was called.\n *\n * @see autorun\n */\nexport function autorunHandleChanges(options, fn) {\n    return new AutorunObserver(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn ?? fn), fn, options.createEmptyChangeSummary, options.handleChange);\n}\n/**\n * @see autorunHandleChanges (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStoreHandleChanges(options, fn) {\n    const store = new DisposableStore();\n    const disposable = autorunHandleChanges({\n        owner: options.owner,\n        debugName: options.debugName,\n        debugReferenceFn: options.debugReferenceFn ?? fn,\n        createEmptyChangeSummary: options.createEmptyChangeSummary,\n        handleChange: options.handleChange,\n    }, (reader, changeSummary) => {\n        store.clear();\n        fn(reader, changeSummary, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\n/**\n * @see autorun (but with a disposable store that is cleared before the next run or on dispose)\n */\nexport function autorunWithStore(fn) {\n    const store = new DisposableStore();\n    const disposable = autorunOpts({\n        owner: undefined,\n        debugName: undefined,\n        debugReferenceFn: fn,\n    }, reader => {\n        store.clear();\n        fn(reader, store);\n    });\n    return toDisposable(() => {\n        disposable.dispose();\n        store.dispose();\n    });\n}\nexport class AutorunObserver {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _runFn, createChangeSummary, _handleChange) {\n        this._debugNameData = _debugNameData;\n        this._runFn = _runFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this.state = 2 /* AutorunState.stale */;\n        this.updateCount = 0;\n        this.disposed = false;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleAutorunCreated(this);\n        this._runIfNeeded();\n        trackDisposable(this);\n    }\n    dispose() {\n        this.disposed = true;\n        for (const o of this.dependencies) {\n            o.removeObserver(this);\n        }\n        this.dependencies.clear();\n        markAsDisposed(this);\n    }\n    _runIfNeeded() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        this.state = 3 /* AutorunState.upToDate */;\n        const isDisposed = this.disposed;\n        try {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunTriggered(this);\n                const changeSummary = this.changeSummary;\n                this.changeSummary = this.createChangeSummary?.();\n                this._runFn(this, changeSummary);\n            }\n        }\n        finally {\n            if (!isDisposed) {\n                getLogger()?.handleAutorunFinished(this);\n            }\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n    }\n    toString() {\n        return `Autorun<${this.debugName}>`;\n    }\n    // IObserver implementation\n    beginUpdate() {\n        if (this.state === 3 /* AutorunState.upToDate */) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n        this.updateCount++;\n    }\n    endUpdate() {\n        if (this.updateCount === 1) {\n            do {\n                if (this.state === 1 /* AutorunState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* AutorunState.upToDate */;\n                    for (const d of this.dependencies) {\n                        d.reportChanges();\n                        if (this.state === 2 /* AutorunState.stale */) {\n                            // The other dependencies will refresh on demand\n                            break;\n                        }\n                    }\n                }\n                this._runIfNeeded();\n            } while (this.state !== 3 /* AutorunState.upToDate */);\n        }\n        this.updateCount--;\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        if (this.state === 3 /* AutorunState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* AutorunState.dependenciesMightHaveChanged */;\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            if (shouldReact) {\n                this.state = 2 /* AutorunState.stale */;\n            }\n        }\n    }\n    // IReader implementation\n    readObservable(observable) {\n        // In case the run action disposes the autorun\n        if (this.disposed) {\n            return observable.get();\n        }\n        observable.addObserver(this);\n        const value = observable.get();\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n}\n(function (autorun) {\n    autorun.Observer = AutorunObserver;\n})(autorun || (autorun = {}));\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { autorun } from './autorun.js';\nimport { observableValue, transaction } from './base.js';\nimport { CancellationError } from '../errors.js';\n/**\n * A promise whose state is observable.\n */\nexport class ObservablePromise {\n    static fromFn(fn) {\n        return new ObservablePromise(fn());\n    }\n    constructor(promise) {\n        this._value = observableValue(this, undefined);\n        /**\n         * The current state of the promise.\n         * Is `undefined` if the promise didn't resolve yet.\n         */\n        this.promiseResult = this._value;\n        this.promise = promise.then(value => {\n            transaction(tx => {\n                /** @description onPromiseResolved */\n                this._value.set(new PromiseResult(value, undefined), tx);\n            });\n            return value;\n        }, error => {\n            transaction(tx => {\n                /** @description onPromiseRejected */\n                this._value.set(new PromiseResult(undefined, error), tx);\n            });\n            throw error;\n        });\n    }\n}\nexport class PromiseResult {\n    constructor(\n    /**\n     * The value of the resolved promise.\n     * Undefined if the promise rejected.\n     */\n    data, \n    /**\n     * The error in case of a rejected promise.\n     * Undefined if the promise resolved.\n     */\n    error) {\n        this.data = data;\n        this.error = error;\n    }\n}\nexport function waitForState(observable, predicate, isError, cancellationToken) {\n    if (!predicate) {\n        predicate = state => state !== null && state !== undefined;\n    }\n    return new Promise((resolve, reject) => {\n        let isImmediateRun = true;\n        let shouldDispose = false;\n        const stateObs = observable.map(state => {\n            /** @description waitForState.state */\n            return {\n                isFinished: predicate(state),\n                error: isError ? isError(state) : false,\n                state\n            };\n        });\n        const d = autorun(reader => {\n            /** @description waitForState */\n            const { isFinished, error, state } = stateObs.read(reader);\n            if (isFinished || error) {\n                if (isImmediateRun) {\n                    // The variable `d` is not initialized yet\n                    shouldDispose = true;\n                }\n                else {\n                    d.dispose();\n                }\n                if (error) {\n                    reject(error === true ? state : error);\n                }\n                else {\n                    resolve(state);\n                }\n            }\n        });\n        if (cancellationToken) {\n            const dc = cancellationToken.onCancellationRequested(() => {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n            });\n            if (cancellationToken.isCancellationRequested) {\n                d.dispose();\n                dc.dispose();\n                reject(new CancellationError());\n                return;\n            }\n        }\n        isImmediateRun = false;\n        if (shouldDispose) {\n            d.dispose();\n        }\n    });\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BaseObservable, TransactionImpl } from './base.js';\n/**\n * Holds off updating observers until the value is actually read.\n*/\nexport class LazyObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'LazyObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._isUpToDate = true;\n        this._deltas = [];\n        this._updateCounter = 0;\n        this._value = initialValue;\n    }\n    get() {\n        this._update();\n        return this._value;\n    }\n    _update() {\n        if (this._isUpToDate) {\n            return;\n        }\n        this._isUpToDate = true;\n        if (this._deltas.length > 0) {\n            for (const observer of this.observers) {\n                for (const change of this._deltas) {\n                    observer.handleChange(this, change);\n                }\n            }\n            this._deltas.length = 0;\n        }\n        else {\n            for (const observer of this.observers) {\n                observer.handleChange(this, undefined);\n            }\n        }\n    }\n    _beginUpdate() {\n        this._updateCounter++;\n        if (this._updateCounter === 1) {\n            for (const observer of this.observers) {\n                observer.beginUpdate(this);\n            }\n        }\n    }\n    _endUpdate() {\n        this._updateCounter--;\n        if (this._updateCounter === 0) {\n            this._update();\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this._updateCounter > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this._updateCounter > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            this._isUpToDate = false;\n            this._setValue(value);\n            if (change !== undefined) {\n                this._deltas.push(change);\n            }\n            tx.updateObserver({\n                beginUpdate: () => this._beginUpdate(),\n                endUpdate: () => this._endUpdate(),\n                handleChange: (observable, change) => { },\n                handlePossibleChange: (observable) => { },\n            }, this);\n            if (this._updateCounter > 1) {\n                // We already started begin/end update, so we need to manually call handlePossibleChange\n                for (const observer of this.observers) {\n                    observer.handlePossibleChange(this);\n                }\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { ObservableValue } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { LazyObservableValue } from './lazyObservableValue.js';\nexport function observableValueOpts(options, initialValue) {\n    if (options.lazy) {\n        return new LazyObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n    }\n    return new ObservableValue(new DebugNameData(options.owner, options.debugName, undefined), initialValue, options.equalsFn ?? strictEquals);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { strictEquals } from '../equals.js';\nimport { DebugNameData, getFunctionName } from './debugName.js';\nimport { getLogger } from './logging.js';\nlet _recomputeInitiallyAndOnChange;\nexport function _setRecomputeInitiallyAndOnChange(recomputeInitiallyAndOnChange) {\n    _recomputeInitiallyAndOnChange = recomputeInitiallyAndOnChange;\n}\nlet _keepObserved;\nexport function _setKeepObserved(keepObserved) {\n    _keepObserved = keepObserved;\n}\nlet _derived;\n/**\n * @internal\n * This is to allow splitting files.\n*/\nexport function _setDerivedOpts(derived) {\n    _derived = derived;\n}\nexport class ConvenientObservable {\n    get TChange() { return null; }\n    reportChanges() {\n        this.get();\n    }\n    /** @sealed */\n    read(reader) {\n        if (reader) {\n            return reader.readObservable(this);\n        }\n        else {\n            return this.get();\n        }\n    }\n    map(fnOrOwner, fnOrUndefined) {\n        const owner = fnOrUndefined === undefined ? undefined : fnOrOwner;\n        const fn = fnOrUndefined === undefined ? fnOrOwner : fnOrUndefined;\n        return _derived({\n            owner,\n            debugName: () => {\n                const name = getFunctionName(fn);\n                if (name !== undefined) {\n                    return name;\n                }\n                // regexp to match `x => x.y` or `x => x?.y` where x and y can be arbitrary identifiers (uses backref):\n                const regexp = /^\\s*\\(?\\s*([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*\\)?\\s*=>\\s*\\1(?:\\??)\\.([a-zA-Z_$][a-zA-Z_$0-9]*)\\s*$/;\n                const match = regexp.exec(fn.toString());\n                if (match) {\n                    return `${this.debugName}.${match[2]}`;\n                }\n                if (!owner) {\n                    return `${this.debugName} (mapped)`;\n                }\n                return undefined;\n            },\n            debugReferenceFn: fn,\n        }, (reader) => fn(this.read(reader), reader));\n    }\n    /**\n     * @sealed\n     * Converts an observable of an observable value into a direct observable of the value.\n    */\n    flatten() {\n        return _derived({\n            owner: undefined,\n            debugName: () => `${this.debugName} (flattened)`,\n        }, (reader) => this.read(reader).read(reader));\n    }\n    recomputeInitiallyAndOnChange(store, handleValue) {\n        store.add(_recomputeInitiallyAndOnChange(this, handleValue));\n        return this;\n    }\n    /**\n     * Ensures that this observable is observed. This keeps the cache alive.\n     * However, in case of deriveds, it does not force eager evaluation (only when the value is read/get).\n     * Use `recomputeInitiallyAndOnChange` for eager evaluation.\n     */\n    keepObserved(store) {\n        store.add(_keepObserved(this));\n        return this;\n    }\n}\nexport class BaseObservable extends ConvenientObservable {\n    constructor() {\n        super(...arguments);\n        this.observers = new Set();\n    }\n    addObserver(observer) {\n        const len = this.observers.size;\n        this.observers.add(observer);\n        if (len === 0) {\n            this.onFirstObserverAdded();\n        }\n    }\n    removeObserver(observer) {\n        const deleted = this.observers.delete(observer);\n        if (deleted && this.observers.size === 0) {\n            this.onLastObserverRemoved();\n        }\n    }\n    onFirstObserverAdded() { }\n    onLastObserverRemoved() { }\n}\n/**\n * Starts a transaction in which many observables can be changed at once.\n * {@link fn} should start with a JS Doc using `@description` to give the transaction a debug name.\n * Reaction run on demand or when the transaction ends.\n */\nexport function transaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\nlet _globalTransaction = undefined;\nexport function globalTransaction(fn) {\n    if (_globalTransaction) {\n        fn(_globalTransaction);\n    }\n    else {\n        const tx = new TransactionImpl(fn, undefined);\n        _globalTransaction = tx;\n        try {\n            fn(tx);\n        }\n        finally {\n            tx.finish(); // During finish, more actions might be added to the transaction.\n            // Which is why we only clear the global transaction after finish.\n            _globalTransaction = undefined;\n        }\n    }\n}\nexport async function asyncTransaction(fn, getDebugName) {\n    const tx = new TransactionImpl(fn, getDebugName);\n    try {\n        await fn(tx);\n    }\n    finally {\n        tx.finish();\n    }\n}\n/**\n * Allows to chain transactions.\n */\nexport function subtransaction(tx, fn, getDebugName) {\n    if (!tx) {\n        transaction(fn, getDebugName);\n    }\n    else {\n        fn(tx);\n    }\n}\nexport class TransactionImpl {\n    constructor(_fn, _getDebugName) {\n        this._fn = _fn;\n        this._getDebugName = _getDebugName;\n        this.updatingObservers = [];\n        getLogger()?.handleBeginTransaction(this);\n    }\n    getDebugName() {\n        if (this._getDebugName) {\n            return this._getDebugName();\n        }\n        return getFunctionName(this._fn);\n    }\n    updateObserver(observer, observable) {\n        // When this gets called while finish is active, they will still get considered\n        this.updatingObservers.push({ observer, observable });\n        observer.beginUpdate(observable);\n    }\n    finish() {\n        const updatingObservers = this.updatingObservers;\n        for (let i = 0; i < updatingObservers.length; i++) {\n            const { observer, observable } = updatingObservers[i];\n            observer.endUpdate(observable);\n        }\n        // Prevent anyone from updating observers from now on.\n        this.updatingObservers = null;\n        getLogger()?.handleEndTransaction();\n    }\n}\nexport function observableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new ObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class ObservableValue extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? 'ObservableValue';\n    }\n    constructor(_debugNameData, initialValue, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._equalityComparator = _equalityComparator;\n        this._value = initialValue;\n    }\n    get() {\n        return this._value;\n    }\n    set(value, tx, change) {\n        if (change === undefined && this._equalityComparator(this._value, value)) {\n            return;\n        }\n        let _tx;\n        if (!tx) {\n            tx = _tx = new TransactionImpl(() => { }, () => `Setting ${this.debugName}`);\n        }\n        try {\n            const oldValue = this._value;\n            this._setValue(value);\n            getLogger()?.handleObservableChanged(this, { oldValue, newValue: value, change, didChange: true, hadValue: true });\n            for (const observer of this.observers) {\n                tx.updateObserver(observer, this);\n                observer.handleChange(this, change);\n            }\n        }\n        finally {\n            if (_tx) {\n                _tx.finish();\n            }\n        }\n    }\n    toString() {\n        return `${this.debugName}: ${this._value}`;\n    }\n    _setValue(newValue) {\n        this._value = newValue;\n    }\n}\n/**\n * A disposable observable. When disposed, its value is also disposed.\n * When a new value is set, the previous value is disposed.\n */\nexport function disposableObservableValue(nameOrOwner, initialValue) {\n    let debugNameData;\n    if (typeof nameOrOwner === 'string') {\n        debugNameData = new DebugNameData(undefined, nameOrOwner, undefined);\n    }\n    else {\n        debugNameData = new DebugNameData(nameOrOwner, undefined, undefined);\n    }\n    return new DisposableObservableValue(debugNameData, initialValue, strictEquals);\n}\nexport class DisposableObservableValue extends ObservableValue {\n    _setValue(newValue) {\n        if (this._value === newValue) {\n            return;\n        }\n        if (this._value) {\n            this._value.dispose();\n        }\n        this._value = newValue;\n    }\n    dispose() {\n        this._value?.dispose();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class DebugNameData {\n    constructor(owner, debugNameSource, referenceFn) {\n        this.owner = owner;\n        this.debugNameSource = debugNameSource;\n        this.referenceFn = referenceFn;\n    }\n    getDebugName(target) {\n        return getDebugName(target, this);\n    }\n}\nconst countPerName = new Map();\nconst cachedDebugName = new WeakMap();\nexport function getDebugName(target, data) {\n    const cached = cachedDebugName.get(target);\n    if (cached) {\n        return cached;\n    }\n    const dbgName = computeDebugName(target, data);\n    if (dbgName) {\n        let count = countPerName.get(dbgName) ?? 0;\n        count++;\n        countPerName.set(dbgName, count);\n        const result = count === 1 ? dbgName : `${dbgName}#${count}`;\n        cachedDebugName.set(target, result);\n        return result;\n    }\n    return undefined;\n}\nfunction computeDebugName(self, data) {\n    const cached = cachedDebugName.get(self);\n    if (cached) {\n        return cached;\n    }\n    const ownerStr = data.owner ? formatOwner(data.owner) + `.` : '';\n    let result;\n    const debugNameSource = data.debugNameSource;\n    if (debugNameSource !== undefined) {\n        if (typeof debugNameSource === 'function') {\n            result = debugNameSource();\n            if (result !== undefined) {\n                return ownerStr + result;\n            }\n        }\n        else {\n            return ownerStr + debugNameSource;\n        }\n    }\n    const referenceFn = data.referenceFn;\n    if (referenceFn !== undefined) {\n        result = getFunctionName(referenceFn);\n        if (result !== undefined) {\n            return ownerStr + result;\n        }\n    }\n    if (data.owner !== undefined) {\n        const key = findKey(data.owner, self);\n        if (key !== undefined) {\n            return ownerStr + key;\n        }\n    }\n    return undefined;\n}\nfunction findKey(obj, value) {\n    for (const key in obj) {\n        if (obj[key] === value) {\n            return key;\n        }\n    }\n    return undefined;\n}\nconst countPerClassName = new Map();\nconst ownerId = new WeakMap();\nfunction formatOwner(owner) {\n    const id = ownerId.get(owner);\n    if (id) {\n        return id;\n    }\n    const className = getClassName(owner);\n    let count = countPerClassName.get(className) ?? 0;\n    count++;\n    countPerClassName.set(className, count);\n    const result = count === 1 ? className : `${className}#${count}`;\n    ownerId.set(owner, result);\n    return result;\n}\nfunction getClassName(obj) {\n    const ctor = obj.constructor;\n    if (ctor) {\n        return ctor.name;\n    }\n    return 'Object';\n}\nexport function getFunctionName(fn) {\n    const fnSrc = fn.toString();\n    // Pattern: /** @description ... */\n    const regexp = /\\/\\*\\*\\s*@description\\s*([^*]*)\\*\\//;\n    const match = regexp.exec(fnSrc);\n    const result = match ? match[1] : undefined;\n    return result?.trim();\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { assertFn } from '../assert.js';\nimport { strictEquals } from '../equals.js';\nimport { DisposableStore } from '../lifecycle.js';\nimport { BaseObservable, _setDerivedOpts } from './base.js';\nimport { DebugNameData } from './debugName.js';\nimport { getLogger } from './logging.js';\nexport function derived(computeFnOrOwner, computeFn) {\n    if (computeFn !== undefined) {\n        return new Derived(new DebugNameData(computeFnOrOwner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals);\n    }\n    return new Derived(new DebugNameData(undefined, undefined, computeFnOrOwner), computeFnOrOwner, undefined, undefined, undefined, strictEquals);\n}\nexport function derivedWithSetter(owner, computeFn, setter) {\n    return new DerivedWithSetter(new DebugNameData(owner, undefined, computeFn), computeFn, undefined, undefined, undefined, strictEquals, setter);\n}\nexport function derivedOpts(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, options.debugReferenceFn), computeFn, undefined, undefined, options.onLastObserverRemoved, options.equalsFn ?? strictEquals);\n}\n_setDerivedOpts(derivedOpts);\n/**\n * Represents an observable that is derived from other observables.\n * The value is only recomputed when absolutely needed.\n *\n * {@link computeFn} should start with a JS Doc using `@description` to name the derived.\n *\n * Use `createEmptyChangeSummary` to create a \"change summary\" that can collect the changes.\n * Use `handleChange` to add a reported change to the change summary.\n * The compute function is given the last change summary.\n * The change summary is discarded after the compute function was called.\n *\n * @see derived\n */\nexport function derivedHandleChanges(options, computeFn) {\n    return new Derived(new DebugNameData(options.owner, options.debugName, undefined), computeFn, options.createEmptyChangeSummary, options.handleChange, undefined, options.equalityComparer ?? strictEquals);\n}\nexport function derivedWithStore(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    const store = new DisposableStore();\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        store.clear();\n        return computeFn(r, store);\n    }, undefined, undefined, () => store.dispose(), strictEquals);\n}\nexport function derivedDisposable(computeFnOrOwner, computeFnOrUndefined) {\n    let computeFn;\n    let owner;\n    if (computeFnOrUndefined === undefined) {\n        computeFn = computeFnOrOwner;\n        owner = undefined;\n    }\n    else {\n        owner = computeFnOrOwner;\n        computeFn = computeFnOrUndefined;\n    }\n    let store = undefined;\n    return new Derived(new DebugNameData(owner, undefined, computeFn), r => {\n        if (!store) {\n            store = new DisposableStore();\n        }\n        else {\n            store.clear();\n        }\n        const result = computeFn(r);\n        if (result) {\n            store.add(result);\n        }\n        return result;\n    }, undefined, undefined, () => {\n        if (store) {\n            store.dispose();\n            store = undefined;\n        }\n    }, strictEquals);\n}\nexport class Derived extends BaseObservable {\n    get debugName() {\n        return this._debugNameData.getDebugName(this) ?? '(anonymous)';\n    }\n    constructor(_debugNameData, _computeFn, createChangeSummary, _handleChange, _handleLastObserverRemoved = undefined, _equalityComparator) {\n        super();\n        this._debugNameData = _debugNameData;\n        this._computeFn = _computeFn;\n        this.createChangeSummary = createChangeSummary;\n        this._handleChange = _handleChange;\n        this._handleLastObserverRemoved = _handleLastObserverRemoved;\n        this._equalityComparator = _equalityComparator;\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        this.updateCount = 0;\n        this.dependencies = new Set();\n        this.dependenciesToBeRemoved = new Set();\n        this.changeSummary = undefined;\n        this.changeSummary = this.createChangeSummary?.();\n        getLogger()?.handleDerivedCreated(this);\n    }\n    onLastObserverRemoved() {\n        /**\n         * We are not tracking changes anymore, thus we have to assume\n         * that our cache is invalid.\n         */\n        this.state = 0 /* DerivedState.initial */;\n        this.value = undefined;\n        for (const d of this.dependencies) {\n            d.removeObserver(this);\n        }\n        this.dependencies.clear();\n        this._handleLastObserverRemoved?.();\n    }\n    get() {\n        if (this.observers.size === 0) {\n            // Without observers, we don't know when to clean up stuff.\n            // Thus, we don't cache anything to prevent memory leaks.\n            const result = this._computeFn(this, this.createChangeSummary?.());\n            // Clear new dependencies\n            this.onLastObserverRemoved();\n            return result;\n        }\n        else {\n            do {\n                // We might not get a notification for a dependency that changed while it is updating,\n                // thus we also have to ask all our depedencies if they changed in this case.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    for (const d of this.dependencies) {\n                        /** might call {@link handleChange} indirectly, which could make us stale */\n                        d.reportChanges();\n                        if (this.state === 2 /* DerivedState.stale */) {\n                            // The other dependencies will refresh on demand, so early break\n                            break;\n                        }\n                    }\n                }\n                // We called report changes of all dependencies.\n                // If we are still not stale, we can assume to be up to date again.\n                if (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */) {\n                    this.state = 3 /* DerivedState.upToDate */;\n                }\n                this._recomputeIfNeeded();\n                // In case recomputation changed one of our dependencies, we need to recompute again.\n            } while (this.state !== 3 /* DerivedState.upToDate */);\n            return this.value;\n        }\n    }\n    _recomputeIfNeeded() {\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            return;\n        }\n        const emptySet = this.dependenciesToBeRemoved;\n        this.dependenciesToBeRemoved = this.dependencies;\n        this.dependencies = emptySet;\n        const hadValue = this.state !== 0 /* DerivedState.initial */;\n        const oldValue = this.value;\n        this.state = 3 /* DerivedState.upToDate */;\n        const changeSummary = this.changeSummary;\n        this.changeSummary = this.createChangeSummary?.();\n        try {\n            /** might call {@link handleChange} indirectly, which could invalidate us */\n            this.value = this._computeFn(this, changeSummary);\n        }\n        finally {\n            // We don't want our observed observables to think that they are (not even temporarily) not being observed.\n            // Thus, we only unsubscribe from observables that are definitely not read anymore.\n            for (const o of this.dependenciesToBeRemoved) {\n                o.removeObserver(this);\n            }\n            this.dependenciesToBeRemoved.clear();\n        }\n        const didChange = hadValue && !(this._equalityComparator(oldValue, this.value));\n        getLogger()?.handleDerivedRecomputed(this, {\n            oldValue,\n            newValue: this.value,\n            change: undefined,\n            didChange,\n            hadValue,\n        });\n        if (didChange) {\n            for (const r of this.observers) {\n                r.handleChange(this, undefined);\n            }\n        }\n    }\n    toString() {\n        return `LazyDerived<${this.debugName}>`;\n    }\n    // IObserver Implementation\n    beginUpdate(_observable) {\n        this.updateCount++;\n        const propagateBeginUpdate = this.updateCount === 1;\n        if (this.state === 3 /* DerivedState.upToDate */) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            // If we propagate begin update, that will already signal a possible change.\n            if (!propagateBeginUpdate) {\n                for (const r of this.observers) {\n                    r.handlePossibleChange(this);\n                }\n            }\n        }\n        if (propagateBeginUpdate) {\n            for (const r of this.observers) {\n                r.beginUpdate(this); // This signals a possible change\n            }\n        }\n    }\n    endUpdate(_observable) {\n        this.updateCount--;\n        if (this.updateCount === 0) {\n            // End update could change the observer list.\n            const observers = [...this.observers];\n            for (const r of observers) {\n                r.endUpdate(this);\n            }\n        }\n        assertFn(() => this.updateCount >= 0);\n    }\n    handlePossibleChange(observable) {\n        // In all other states, observers already know that we might have changed.\n        if (this.state === 3 /* DerivedState.upToDate */ && this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            this.state = 1 /* DerivedState.dependenciesMightHaveChanged */;\n            for (const r of this.observers) {\n                r.handlePossibleChange(this);\n            }\n        }\n    }\n    handleChange(observable, change) {\n        if (this.dependencies.has(observable) && !this.dependenciesToBeRemoved.has(observable)) {\n            const shouldReact = this._handleChange ? this._handleChange({\n                changedObservable: observable,\n                change,\n                didChange: (o) => o === observable,\n            }, this.changeSummary) : true;\n            const wasUpToDate = this.state === 3 /* DerivedState.upToDate */;\n            if (shouldReact && (this.state === 1 /* DerivedState.dependenciesMightHaveChanged */ || wasUpToDate)) {\n                this.state = 2 /* DerivedState.stale */;\n                if (wasUpToDate) {\n                    for (const r of this.observers) {\n                        r.handlePossibleChange(this);\n                    }\n                }\n            }\n        }\n    }\n    // IReader Implementation\n    readObservable(observable) {\n        // Subscribe before getting the value to enable caching\n        observable.addObserver(this);\n        /** This might call {@link handleChange} indirectly, which could invalidate us */\n        const value = observable.get();\n        // Which is why we only add the observable to the dependencies now.\n        this.dependencies.add(observable);\n        this.dependenciesToBeRemoved.delete(observable);\n        return value;\n    }\n    addObserver(observer) {\n        const shouldCallBeginUpdate = !this.observers.has(observer) && this.updateCount > 0;\n        super.addObserver(observer);\n        if (shouldCallBeginUpdate) {\n            observer.beginUpdate(this);\n        }\n    }\n    removeObserver(observer) {\n        const shouldCallEndUpdate = this.observers.has(observer) && this.updateCount > 0;\n        super.removeObserver(observer);\n        if (shouldCallEndUpdate) {\n            // Calling end update after removing the observer makes sure endUpdate cannot be called twice here.\n            observer.endUpdate(this);\n        }\n    }\n}\nexport class DerivedWithSetter extends Derived {\n    constructor(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved = undefined, equalityComparator, set) {\n        super(debugNameData, computeFn, createChangeSummary, handleChange, handleLastObserverRemoved, equalityComparator);\n        this.set = set;\n    }\n}\n"],"names":["constObservable","value","ConstObservable","constructor","super","this","debugName","toString","get","addObserver","observer","removeObserver","observableFromEvent","args","owner","event","getValue","length","FromEventObservable","undefined","globalTransaction","observableFromEventOpts","options","debugReferenceFn","equalsFn","_debugNameData","_getValue","_getTransaction","_equalityComparator","hasValue","handleEvent","newValue","oldValue","didChange","didRunTransaction","tx","handleFromEventObservableTriggered","change","hadValue","o","observers","updateObserver","handleChange","name","getDebugName","onFirstObserverAdded","subscription","onLastObserverRemoved","dispose","observableSignalFromEvent","FromEventObservableSignal","Observer","batchEventsGlobally","fn","didSet","observableSignal","debugNameOrOwner","ObservableSignal","_owner","_debugName","trigger","recomputeInitiallyAndOnChange","observable","handleValue","KeepAliveObserver","reportChanges","_forceRecompute","_handleValue","_counter","beginUpdate","endUpdate","handlePossibleChange","derivedObservableWithCache","computeFn","lastValue","reader","mapObservableArrayCached","items","map","keySelector","m","ArrayMap","setItems","read","getItems","_map","_keySelector","_cache","Map","_items","forEach","entry","store","clear","newItems","itemsToRemove","Set","keys","item","key","delete","out","set","push","derivedConstOnceDefined","strictEquals","a","b","itemsEquals","itemEquals","equals","equalsIfDefined","equalsOrV1","v2","v1","structuralEquals","Array","isArray","i","Object","getPrototypeOf","prototype","aObj","bObj","keysA","keysB","keysBSet","has","WeakMap","globalObservableLogger","setLogger","logger","getLogger","ConsoleObservableLogger","indentation","changedObservablesSets","textToConsoleArgs","text","styles","data","firstArg","process","t","style","result","consoleTextToArgs","normalText","repeat","formatInfo","info","styled","formatValue","color","strikeThrough","handleObservableChanged","console","log","formatKind","formatChanges","changes","size","join","handleDerivedCreated","derived","existingHandleChange","add","apply","handleDerivedRecomputed","changedObservables","referenceFn","_computeFn","handleAutorunCreated","autorun","handleAutorunTriggered","_runFn","handleAutorunFinished","handleBeginTransaction","transaction","transactionName","_fn","handleEndTransaction","kind","str","padStr","bold","styleObj","entries","reduce","styleString","propName","propValue","availableLen","substr","first","val","formatArray","formatObject","count","LanguageService","instanceCount","warnOnOverwrite","_onDidRequestBasicLanguageFeatures","_register","onDidRequestBasicLanguageFeatures","_onDidRequestRichLanguageFeatures","onDidRequestRichLanguageFeatures","_onDidChange","leakWarningThreshold","onDidChange","_requestedBasicLanguages","_requestedRichLanguages","_registry","LanguagesRegistry","languageIdCodec","fire","isRegisteredLanguageId","languageId","getLanguageIdByLanguageName","languageName","getLanguageIdByMimeType","mimeType","guessLanguageIdByFilepathOrFirstLine","resource","firstLine","languageIds","createById","LanguageSelection","_createAndGetLanguageIdentifier","createByFilepathOrFirstLine","requestBasicLanguageFeatures","requestRichLanguageFeatures","getOrCreate","onDidChangeLanguages","selector","_value","fromObservable","registeredAssociations","nonUserRegisteredAssociations","userRegisteredAssociations","registerPlatformLanguageAssociation","association","userConfigured","associationItem","id","mime","filename","extension","filepattern","firstline","filenameLowercase","toLowerCase","extensionLowercase","filepatternLowercase","filepatternOnPath","indexOf","sep","toLanguageAssociationItem","warn","_registerLanguageAssociation","clearPlatformLanguageAssociations","filter","getLanguageIds","path","scheme","file","fsPath","parseMetaData","META_DATA_LABEL","vscodeNotebookCell","unknown","configuredLanguage","getAssociationByPath","registeredLanguage","firstlineLanguage","matches","match","getAssociationByFirstline","getAssociations","associations","filenameMatch","patternMatch","extensionMatch","target","endsWith","hasOwnProperty","NULL_LANGUAGE_ID","LanguageIdCodec","_languageIdToLanguage","_languageToLanguageId","_nextLanguageId","language","register","encodeLanguageId","decodeLanguageId","useModesRegistry","_warnOnOverwrite","_dynamicLanguages","_languages","_mimeTypesMap","_nameMap","_lowercaseNameMap","_initializeFromRegistry","desc","concat","getLanguages","_registerLanguages","d","_registerLanguage","langId","identifier","aliases","alias","mimetypes","mimetype","as","Configuration","registerOverrideIdentifiers","getRegisteredLanguageIds","lang","resolvedLanguage","call","extensions","filenames","configurationFiles","icons","_mergeLanguage","primaryMime","configuration","filenamePatterns","filenamePattern","firstLineRegexStr","charAt","firstLineRegex","RegExp","err","langAliases","langAlias","containsAliases","bestName","icon","languageNameLower","AutorunObserver","autorunOpts","autorunHandleChanges","createEmptyChangeSummary","autorunWithStoreHandleChanges","disposable","changeSummary","autorunWithStore","createChangeSummary","_handleChange","state","updateCount","disposed","dependencies","dependenciesToBeRemoved","_runIfNeeded","emptySet","isDisposed","assert","changedObservable","readObservable","ObservablePromise","fromFn","promise","promiseResult","then","PromiseResult","error","waitForState","predicate","isError","cancellationToken","Promise","resolve","reject","isImmediateRun","shouldDispose","stateObs","isFinished","dc","onCancellationRequested","isCancellationRequested","LazyObservableValue","initialValue","_isUpToDate","_deltas","_updateCounter","_update","_beginUpdate","_endUpdate","r","shouldCallBeginUpdate","shouldCallEndUpdate","_tx","_setValue","finish","observableValueOpts","lazy","_recomputeInitiallyAndOnChange","_keepObserved","_derived","_setRecomputeInitiallyAndOnChange","_setKeepObserved","keepObserved","_setDerivedOpts","ConvenientObservable","TChange","fnOrOwner","fnOrUndefined","exec","flatten","BaseObservable","arguments","len","TransactionImpl","_globalTransaction","async","asyncTransaction","subtransaction","_getDebugName","updatingObservers","observableValue","nameOrOwner","debugNameData","ObservableValue","disposableObservableValue","DisposableObservableValue","DebugNameData","debugNameSource","cached","cachedDebugName","dbgName","self","ownerStr","ownerId","className","obj","ctor","getClassName","countPerClassName","formatOwner","getFunctionName","findKey","computeDebugName","countPerName","fnSrc","trim","computeFnOrOwner","Derived","derivedWithSetter","setter","DerivedWithSetter","derivedOpts","derivedHandleChanges","equalityComparer","derivedWithStore","computeFnOrUndefined","derivedDisposable","_handleLastObserverRemoved","_recomputeIfNeeded","_observable","propagateBeginUpdate","shouldReact","wasUpToDate","handleLastObserverRemoved","equalityComparator"],"sourceRoot":""}