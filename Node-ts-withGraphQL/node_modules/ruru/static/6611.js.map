{"version":3,"file":"6611.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/glob.js"],"sourcesContent":["import { isThenable } from './async.js';\nimport { isEqualOrParent } from './extpath.js';\nimport { LRUCache } from './map.js';\nimport { basename, extname, posix, sep } from './path.js';\nimport { isLinux } from './platform.js';\nimport { escapeRegExpCharacters, ltrim } from './strings.js';\nexport const GLOBSTAR = '**';\nexport const GLOB_SPLIT = '/';\nconst PATH_REGEX = '[/\\\\\\\\]'; // any slash or backslash\nconst NO_PATH_REGEX = '[^/\\\\\\\\]'; // any non-slash and non-backslash\nconst ALL_FORWARD_SLASHES = /\\//g;\nfunction starsToRegExp(starCount, isLastPattern) {\n    switch (starCount) {\n        case 0:\n            return '';\n        case 1:\n            return `${NO_PATH_REGEX}*?`; // 1 star matches any number of characters except path separator (/ and \\) - non greedy (?)\n        default:\n            // Matches:  (Path Sep OR Path Val followed by Path Sep) 0-many times except when it's the last pattern\n            //           in which case also matches (Path Sep followed by Path Val)\n            // Group is non capturing because we don't need to capture at all (?:...)\n            // Overall we use non-greedy matching because it could be that we match too much\n            return `(?:${PATH_REGEX}|${NO_PATH_REGEX}+${PATH_REGEX}${isLastPattern ? `|${PATH_REGEX}${NO_PATH_REGEX}+` : ''})*?`;\n    }\n}\nexport function splitGlobAware(pattern, splitChar) {\n    if (!pattern) {\n        return [];\n    }\n    const segments = [];\n    let inBraces = false;\n    let inBrackets = false;\n    let curVal = '';\n    for (const char of pattern) {\n        switch (char) {\n            case splitChar:\n                if (!inBraces && !inBrackets) {\n                    segments.push(curVal);\n                    curVal = '';\n                    continue;\n                }\n                break;\n            case '{':\n                inBraces = true;\n                break;\n            case '}':\n                inBraces = false;\n                break;\n            case '[':\n                inBrackets = true;\n                break;\n            case ']':\n                inBrackets = false;\n                break;\n        }\n        curVal += char;\n    }\n    // Tail\n    if (curVal) {\n        segments.push(curVal);\n    }\n    return segments;\n}\nfunction parseRegExp(pattern) {\n    if (!pattern) {\n        return '';\n    }\n    let regEx = '';\n    // Split up into segments for each slash found\n    const segments = splitGlobAware(pattern, GLOB_SPLIT);\n    // Special case where we only have globstars\n    if (segments.every(segment => segment === GLOBSTAR)) {\n        regEx = '.*';\n    }\n    // Build regex over segments\n    else {\n        let previousSegmentWasGlobStar = false;\n        segments.forEach((segment, index) => {\n            // Treat globstar specially\n            if (segment === GLOBSTAR) {\n                // if we have more than one globstar after another, just ignore it\n                if (previousSegmentWasGlobStar) {\n                    return;\n                }\n                regEx += starsToRegExp(2, index === segments.length - 1);\n            }\n            // Anything else, not globstar\n            else {\n                // States\n                let inBraces = false;\n                let braceVal = '';\n                let inBrackets = false;\n                let bracketVal = '';\n                for (const char of segment) {\n                    // Support brace expansion\n                    if (char !== '}' && inBraces) {\n                        braceVal += char;\n                        continue;\n                    }\n                    // Support brackets\n                    if (inBrackets && (char !== ']' || !bracketVal) /* ] is literally only allowed as first character in brackets to match it */) {\n                        let res;\n                        // range operator\n                        if (char === '-') {\n                            res = char;\n                        }\n                        // negation operator (only valid on first index in bracket)\n                        else if ((char === '^' || char === '!') && !bracketVal) {\n                            res = '^';\n                        }\n                        // glob split matching is not allowed within character ranges\n                        // see http://man7.org/linux/man-pages/man7/glob.7.html\n                        else if (char === GLOB_SPLIT) {\n                            res = '';\n                        }\n                        // anything else gets escaped\n                        else {\n                            res = escapeRegExpCharacters(char);\n                        }\n                        bracketVal += res;\n                        continue;\n                    }\n                    switch (char) {\n                        case '{':\n                            inBraces = true;\n                            continue;\n                        case '[':\n                            inBrackets = true;\n                            continue;\n                        case '}': {\n                            const choices = splitGlobAware(braceVal, ',');\n                            // Converts {foo,bar} => [foo|bar]\n                            const braceRegExp = `(?:${choices.map(choice => parseRegExp(choice)).join('|')})`;\n                            regEx += braceRegExp;\n                            inBraces = false;\n                            braceVal = '';\n                            break;\n                        }\n                        case ']': {\n                            regEx += ('[' + bracketVal + ']');\n                            inBrackets = false;\n                            bracketVal = '';\n                            break;\n                        }\n                        case '?':\n                            regEx += NO_PATH_REGEX; // 1 ? matches any single character except path separator (/ and \\)\n                            continue;\n                        case '*':\n                            regEx += starsToRegExp(1);\n                            continue;\n                        default:\n                            regEx += escapeRegExpCharacters(char);\n                    }\n                }\n                // Tail: Add the slash we had split on if there is more to\n                // come and the remaining pattern is not a globstar\n                // For example if pattern: some/**/*.js we want the \"/\" after\n                // some to be included in the RegEx to prevent a folder called\n                // \"something\" to match as well.\n                if (index < segments.length - 1 && // more segments to come after this\n                    (segments[index + 1] !== GLOBSTAR || // next segment is not **, or...\n                        index + 2 < segments.length // ...next segment is ** but there is more segments after that\n                    )) {\n                    regEx += PATH_REGEX;\n                }\n            }\n            // update globstar state\n            previousSegmentWasGlobStar = (segment === GLOBSTAR);\n        });\n    }\n    return regEx;\n}\n// regexes to check for trivial glob patterns that just check for String#endsWith\nconst T1 = /^\\*\\*\\/\\*\\.[\\w\\.-]+$/; // **/*.something\nconst T2 = /^\\*\\*\\/([\\w\\.-]+)\\/?$/; // **/something\nconst T3 = /^{\\*\\*\\/\\*?[\\w\\.-]+\\/?(,\\*\\*\\/\\*?[\\w\\.-]+\\/?)*}$/; // {**/*.something,**/*.else} or {**/package.json,**/project.json}\nconst T3_2 = /^{\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?(,\\*\\*\\/\\*?[\\w\\.-]+(\\/(\\*\\*)?)?)*}$/; // Like T3, with optional trailing /**\nconst T4 = /^\\*\\*((\\/[\\w\\.-]+)+)\\/?$/; // **/something/else\nconst T5 = /^([\\w\\.-]+(\\/[\\w\\.-]+)*)\\/?$/; // something/else\nconst CACHE = new LRUCache(10000); // bounded to 10000 elements\nconst FALSE = function () {\n    return false;\n};\nconst NULL = function () {\n    return null;\n};\nfunction parsePattern(arg1, options) {\n    if (!arg1) {\n        return NULL;\n    }\n    // Handle relative patterns\n    let pattern;\n    if (typeof arg1 !== 'string') {\n        pattern = arg1.pattern;\n    }\n    else {\n        pattern = arg1;\n    }\n    // Whitespace trimming\n    pattern = pattern.trim();\n    // Check cache\n    const patternKey = `${pattern}_${!!options.trimForExclusions}`;\n    let parsedPattern = CACHE.get(patternKey);\n    if (parsedPattern) {\n        return wrapRelativePattern(parsedPattern, arg1);\n    }\n    // Check for Trivials\n    let match;\n    if (T1.test(pattern)) {\n        parsedPattern = trivia1(pattern.substr(4), pattern); // common pattern: **/*.txt just need endsWith check\n    }\n    else if (match = T2.exec(trimForExclusions(pattern, options))) { // common pattern: **/some.txt just need basename check\n        parsedPattern = trivia2(match[1], pattern);\n    }\n    else if ((options.trimForExclusions ? T3_2 : T3).test(pattern)) { // repetition of common patterns (see above) {**/*.txt,**/*.png}\n        parsedPattern = trivia3(pattern, options);\n    }\n    else if (match = T4.exec(trimForExclusions(pattern, options))) { // common pattern: **/something/else just need endsWith check\n        parsedPattern = trivia4and5(match[1].substr(1), pattern, true);\n    }\n    else if (match = T5.exec(trimForExclusions(pattern, options))) { // common pattern: something/else just need equals check\n        parsedPattern = trivia4and5(match[1], pattern, false);\n    }\n    // Otherwise convert to pattern\n    else {\n        parsedPattern = toRegExp(pattern);\n    }\n    // Cache\n    CACHE.set(patternKey, parsedPattern);\n    return wrapRelativePattern(parsedPattern, arg1);\n}\nfunction wrapRelativePattern(parsedPattern, arg2) {\n    if (typeof arg2 === 'string') {\n        return parsedPattern;\n    }\n    const wrappedPattern = function (path, basename) {\n        if (!isEqualOrParent(path, arg2.base, !isLinux)) {\n            // skip glob matching if `base` is not a parent of `path`\n            return null;\n        }\n        // Given we have checked `base` being a parent of `path`,\n        // we can now remove the `base` portion of the `path`\n        // and only match on the remaining path components\n        // For that we try to extract the portion of the `path`\n        // that comes after the `base` portion. We have to account\n        // for the fact that `base` might end in a path separator\n        // (https://github.com/microsoft/vscode/issues/162498)\n        return parsedPattern(ltrim(path.substr(arg2.base.length), sep), basename);\n    };\n    // Make sure to preserve associated metadata\n    wrappedPattern.allBasenames = parsedPattern.allBasenames;\n    wrappedPattern.allPaths = parsedPattern.allPaths;\n    wrappedPattern.basenames = parsedPattern.basenames;\n    wrappedPattern.patterns = parsedPattern.patterns;\n    return wrappedPattern;\n}\nfunction trimForExclusions(pattern, options) {\n    return options.trimForExclusions && pattern.endsWith('/**') ? pattern.substr(0, pattern.length - 2) : pattern; // dropping **, tailing / is dropped later\n}\n// common pattern: **/*.txt just need endsWith check\nfunction trivia1(base, pattern) {\n    return function (path, basename) {\n        return typeof path === 'string' && path.endsWith(base) ? pattern : null;\n    };\n}\n// common pattern: **/some.txt just need basename check\nfunction trivia2(base, pattern) {\n    const slashBase = `/${base}`;\n    const backslashBase = `\\\\${base}`;\n    const parsedPattern = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (basename) {\n            return basename === base ? pattern : null;\n        }\n        return path === base || path.endsWith(slashBase) || path.endsWith(backslashBase) ? pattern : null;\n    };\n    const basenames = [base];\n    parsedPattern.basenames = basenames;\n    parsedPattern.patterns = [pattern];\n    parsedPattern.allBasenames = basenames;\n    return parsedPattern;\n}\n// repetition of common patterns (see above) {**/*.txt,**/*.png}\nfunction trivia3(pattern, options) {\n    const parsedPatterns = aggregateBasenameMatches(pattern.slice(1, -1)\n        .split(',')\n        .map(pattern => parsePattern(pattern, options))\n        .filter(pattern => pattern !== NULL), pattern);\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (patternsLength === 1) {\n        return parsedPatterns[0];\n    }\n    const parsedPattern = function (path, basename) {\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            if (parsedPatterns[i](path, basename)) {\n                return pattern;\n            }\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        parsedPattern.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        parsedPattern.allPaths = allPaths;\n    }\n    return parsedPattern;\n}\n// common patterns: **/something/else just need endsWith check, something/else just needs and equals check\nfunction trivia4and5(targetPath, pattern, matchPathEnds) {\n    const usingPosixSep = sep === posix.sep;\n    const nativePath = usingPosixSep ? targetPath : targetPath.replace(ALL_FORWARD_SLASHES, sep);\n    const nativePathEnd = sep + nativePath;\n    const targetPathEnd = posix.sep + targetPath;\n    let parsedPattern;\n    if (matchPathEnds) {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && ((path === nativePath || path.endsWith(nativePathEnd)) || !usingPosixSep && (path === targetPath || path.endsWith(targetPathEnd))) ? pattern : null;\n        };\n    }\n    else {\n        parsedPattern = function (path, basename) {\n            return typeof path === 'string' && (path === nativePath || (!usingPosixSep && path === targetPath)) ? pattern : null;\n        };\n    }\n    parsedPattern.allPaths = [(matchPathEnds ? '*/' : './') + targetPath];\n    return parsedPattern;\n}\nfunction toRegExp(pattern) {\n    try {\n        const regExp = new RegExp(`^${parseRegExp(pattern)}$`);\n        return function (path) {\n            regExp.lastIndex = 0; // reset RegExp to its initial state to reuse it!\n            return typeof path === 'string' && regExp.test(path) ? pattern : null;\n        };\n    }\n    catch (error) {\n        return NULL;\n    }\n}\nexport function match(arg1, path, hasSibling) {\n    if (!arg1 || typeof path !== 'string') {\n        return false;\n    }\n    return parse(arg1)(path, undefined, hasSibling);\n}\nexport function parse(arg1, options = {}) {\n    if (!arg1) {\n        return FALSE;\n    }\n    // Glob with String\n    if (typeof arg1 === 'string' || isRelativePattern(arg1)) {\n        const parsedPattern = parsePattern(arg1, options);\n        if (parsedPattern === NULL) {\n            return FALSE;\n        }\n        const resultPattern = function (path, basename) {\n            return !!parsedPattern(path, basename);\n        };\n        if (parsedPattern.allBasenames) {\n            resultPattern.allBasenames = parsedPattern.allBasenames;\n        }\n        if (parsedPattern.allPaths) {\n            resultPattern.allPaths = parsedPattern.allPaths;\n        }\n        return resultPattern;\n    }\n    // Glob with Expression\n    return parsedExpression(arg1, options);\n}\nexport function isRelativePattern(obj) {\n    const rp = obj;\n    if (!rp) {\n        return false;\n    }\n    return typeof rp.base === 'string' && typeof rp.pattern === 'string';\n}\nfunction parsedExpression(expression, options) {\n    const parsedPatterns = aggregateBasenameMatches(Object.getOwnPropertyNames(expression)\n        .map(pattern => parseExpressionPattern(pattern, expression[pattern], options))\n        .filter(pattern => pattern !== NULL));\n    const patternsLength = parsedPatterns.length;\n    if (!patternsLength) {\n        return NULL;\n    }\n    if (!parsedPatterns.some(parsedPattern => !!parsedPattern.requiresSiblings)) {\n        if (patternsLength === 1) {\n            return parsedPatterns[0];\n        }\n        const resultExpression = function (path, basename) {\n            let resultPromises = undefined;\n            for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n                const result = parsedPatterns[i](path, basename);\n                if (typeof result === 'string') {\n                    return result; // immediately return as soon as the first expression matches\n                }\n                // If the result is a promise, we have to keep it for\n                // later processing and await the result properly.\n                if (isThenable(result)) {\n                    if (!resultPromises) {\n                        resultPromises = [];\n                    }\n                    resultPromises.push(result);\n                }\n            }\n            // With result promises, we have to loop over each and\n            // await the result before we can return any result.\n            if (resultPromises) {\n                return (async () => {\n                    for (const resultPromise of resultPromises) {\n                        const result = await resultPromise;\n                        if (typeof result === 'string') {\n                            return result;\n                        }\n                    }\n                    return null;\n                })();\n            }\n            return null;\n        };\n        const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n        if (withBasenames) {\n            resultExpression.allBasenames = withBasenames.allBasenames;\n        }\n        const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n        if (allPaths.length) {\n            resultExpression.allPaths = allPaths;\n        }\n        return resultExpression;\n    }\n    const resultExpression = function (path, base, hasSibling) {\n        let name = undefined;\n        let resultPromises = undefined;\n        for (let i = 0, n = parsedPatterns.length; i < n; i++) {\n            // Pattern matches path\n            const parsedPattern = parsedPatterns[i];\n            if (parsedPattern.requiresSiblings && hasSibling) {\n                if (!base) {\n                    base = basename(path);\n                }\n                if (!name) {\n                    name = base.substr(0, base.length - extname(path).length);\n                }\n            }\n            const result = parsedPattern(path, base, name, hasSibling);\n            if (typeof result === 'string') {\n                return result; // immediately return as soon as the first expression matches\n            }\n            // If the result is a promise, we have to keep it for\n            // later processing and await the result properly.\n            if (isThenable(result)) {\n                if (!resultPromises) {\n                    resultPromises = [];\n                }\n                resultPromises.push(result);\n            }\n        }\n        // With result promises, we have to loop over each and\n        // await the result before we can return any result.\n        if (resultPromises) {\n            return (async () => {\n                for (const resultPromise of resultPromises) {\n                    const result = await resultPromise;\n                    if (typeof result === 'string') {\n                        return result;\n                    }\n                }\n                return null;\n            })();\n        }\n        return null;\n    };\n    const withBasenames = parsedPatterns.find(pattern => !!pattern.allBasenames);\n    if (withBasenames) {\n        resultExpression.allBasenames = withBasenames.allBasenames;\n    }\n    const allPaths = parsedPatterns.reduce((all, current) => current.allPaths ? all.concat(current.allPaths) : all, []);\n    if (allPaths.length) {\n        resultExpression.allPaths = allPaths;\n    }\n    return resultExpression;\n}\nfunction parseExpressionPattern(pattern, value, options) {\n    if (value === false) {\n        return NULL; // pattern is disabled\n    }\n    const parsedPattern = parsePattern(pattern, options);\n    if (parsedPattern === NULL) {\n        return NULL;\n    }\n    // Expression Pattern is <boolean>\n    if (typeof value === 'boolean') {\n        return parsedPattern;\n    }\n    // Expression Pattern is <SiblingClause>\n    if (value) {\n        const when = value.when;\n        if (typeof when === 'string') {\n            const result = (path, basename, name, hasSibling) => {\n                if (!hasSibling || !parsedPattern(path, basename)) {\n                    return null;\n                }\n                const clausePattern = when.replace('$(basename)', () => name);\n                const matched = hasSibling(clausePattern);\n                return isThenable(matched) ?\n                    matched.then(match => match ? pattern : null) :\n                    matched ? pattern : null;\n            };\n            result.requiresSiblings = true;\n            return result;\n        }\n    }\n    // Expression is anything\n    return parsedPattern;\n}\nfunction aggregateBasenameMatches(parsedPatterns, result) {\n    const basenamePatterns = parsedPatterns.filter(parsedPattern => !!parsedPattern.basenames);\n    if (basenamePatterns.length < 2) {\n        return parsedPatterns;\n    }\n    const basenames = basenamePatterns.reduce((all, current) => {\n        const basenames = current.basenames;\n        return basenames ? all.concat(basenames) : all;\n    }, []);\n    let patterns;\n    if (result) {\n        patterns = [];\n        for (let i = 0, n = basenames.length; i < n; i++) {\n            patterns.push(result);\n        }\n    }\n    else {\n        patterns = basenamePatterns.reduce((all, current) => {\n            const patterns = current.patterns;\n            return patterns ? all.concat(patterns) : all;\n        }, []);\n    }\n    const aggregate = function (path, basename) {\n        if (typeof path !== 'string') {\n            return null;\n        }\n        if (!basename) {\n            let i;\n            for (i = path.length; i > 0; i--) {\n                const ch = path.charCodeAt(i - 1);\n                if (ch === 47 /* CharCode.Slash */ || ch === 92 /* CharCode.Backslash */) {\n                    break;\n                }\n            }\n            basename = path.substr(i);\n        }\n        const index = basenames.indexOf(basename);\n        return index !== -1 ? patterns[index] : null;\n    };\n    aggregate.basenames = basenames;\n    aggregate.patterns = patterns;\n    aggregate.allBasenames = basenames;\n    const aggregatedPatterns = parsedPatterns.filter(parsedPattern => !parsedPattern.basenames);\n    aggregatedPatterns.push(aggregate);\n    return aggregatedPatterns;\n}\n"],"names":["GLOBSTAR","GLOB_SPLIT","PATH_REGEX","NO_PATH_REGEX","ALL_FORWARD_SLASHES","starsToRegExp","starCount","isLastPattern","splitGlobAware","pattern","splitChar","segments","inBraces","inBrackets","curVal","char","push","parseRegExp","regEx","every","segment","previousSegmentWasGlobStar","forEach","index","length","braceVal","bracketVal","braceRegExp","map","choice","join","res","T1","T2","T3","T3_2","T4","T5","CACHE","FALSE","NULL","parsePattern","arg1","options","trim","patternKey","trimForExclusions","match","parsedPattern","get","test","base","path","basename","endsWith","trivia1","substr","exec","slashBase","backslashBase","basenames","patterns","allBasenames","trivia2","parsedPatterns","aggregateBasenameMatches","slice","split","filter","patternsLength","i","n","withBasenames","find","allPaths","reduce","all","current","concat","trivia3","trivia4and5","regExp","RegExp","lastIndex","error","toRegExp","set","arg2","wrappedPattern","wrapRelativePattern","targetPath","matchPathEnds","usingPosixSep","sep","nativePath","replace","nativePathEnd","targetPathEnd","hasSibling","parse","undefined","obj","rp","isRelativePattern","resultPattern","expression","Object","getOwnPropertyNames","value","when","result","name","matched","then","requiresSiblings","parseExpressionPattern","some","resultExpression","resultPromises","resultPromise","parsedExpression","basenamePatterns","aggregate","ch","charCodeAt","indexOf","aggregatedPatterns"],"sourceRoot":""}