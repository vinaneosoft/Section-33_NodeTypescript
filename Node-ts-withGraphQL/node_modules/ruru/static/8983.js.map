{"version":3,"file":"8983.js","mappings":"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","sources":["webpack://ruru/../grafast/dist/mermaid.js","webpack://ruru/../grafast/dist/planJSONInterfaces.js","webpack://ruru/../grafast/dist/stripAnsi.js","webpack://ruru/../ruru-components/dist/components/MermaidReal.js"],"sourcesContent":["\"use strict\";\n/*\n * This file contains all our utilities for dealing with Mermaid-js\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mermaidEscape = exports.COLORS = void 0;\nexports.planToMermaid = planToMermaid;\nconst tslib_1 = require(\"tslib\");\nconst stripAnsi_js_1 = require(\"./stripAnsi.js\");\n/**\n * An array of hex colour codes that we use for colouring the buckets/steps in\n * the mermaid-js plan diagram.\n *\n * Generated by mokole.com/palette.html; re-ordered by Jem\n */\nexports.COLORS = [\n    \"#696969\",\n    \"#00bfff\",\n    \"#7f007f\",\n    \"#ffa500\",\n    \"#0000ff\",\n    \"#7fff00\",\n    \"#ff1493\",\n    \"#808000\",\n    \"#dda0dd\",\n    \"#ff0000\",\n    \"#ffff00\",\n    \"#00ffff\",\n    \"#4169e1\",\n    \"#3cb371\",\n    \"#a52a2a\",\n    \"#ff00ff\",\n    \"#f5deb3\",\n];\n/**\n * Given a string, escapes the string so that it can be embedded as the description of a node in a mermaid chart.\n *\n * 1. If it's already safe, returns it verbatim\n * 2. If it contains disallowed characters, escape them by replacing them with similar-looking characters,\n * 3. Wrap the string in quote marks.\n *\n * @remarks\n *\n * NOTE: rather than doing literal escapes, we replace with lookalike characters because:\n *\n * 1. Mermaid has a bug when calculating the width of the node that doesn't respect escapes,\n * 2. It's easier to read the raw mermaid markup with substitutes rather than messy escapes.\n *\n * @internal\n */\nconst mermaidEscape = (str) => {\n    if (str.match(/^[a-z0-9 ]+$/i)) {\n        return str;\n    }\n    // Technically we should replace with escapes like this:\n    //.replace(/[#\"]/g, (l) => ({ \"#\": \"#35;\", '\"': \"#quot;\" }[l as any]))\n    // However there's a bug in Mermaid's rendering that causes the node to use\n    // the escaped string as the width for the node rather than the unescaped\n    // string. Thus we replace with similar looking characters.\n    return `\"${(0, stripAnsi_js_1.stripAnsi)(str.trim())\n        .replace(/[#\"<>]/g, (l) => ({ \"#\": \"ꖛ\", '\"': \"”\", \"<\": \"ᐸ\", \">\": \"ᐳ\" })[l])\n        .replace(/\\r?\\n/g, \"<br />\")}\"`;\n};\nexports.mermaidEscape = mermaidEscape;\nfunction isGrafastPlanJSONv1(json) {\n    return json.version === \"v1\";\n}\nfunction planToMermaid(planJSON, { \n// printPathRelations = false,\nconcise = false, skipBuckets = global.grafastExplainMermaidSkipBuckets ?? false, } = {}) {\n    if (!isGrafastPlanJSONv1(planJSON)) {\n        throw new Error(\"planToMermaid only supports v1 plan JSON\");\n    }\n    const stepById = Object.create(null);\n    const layerPlanById = Object.create(null);\n    const dependentsByStepId = Object.create(null);\n    const sortedSteps = [];\n    const extractSteps = (bucket) => {\n        if (layerPlanById[bucket.id]) {\n            throw new Error(`Two buckets with the same ID ${bucket.id}?`);\n        }\n        layerPlanById[bucket.id] = bucket;\n        // Shallowest bucket first, then most dependencies\n        const sorted = [...bucket.steps].sort((a, z) => z.dependencyIds.length - a.dependencyIds.length);\n        for (const step of sorted) {\n            if (stepById[step.id]) {\n                throw new Error(`Step ${step.id} (${step.stepClass}/${step.metaString}) duplicated in plan?!`);\n            }\n            stepById[step.id] = step;\n            sortedSteps.push(step);\n            for (const depId of step.dependencyIds) {\n                if (!dependentsByStepId[depId]) {\n                    dependentsByStepId[depId] = [step];\n                }\n                else {\n                    dependentsByStepId[depId].push(step);\n                }\n            }\n        }\n    };\n    planJSON.buckets.forEach(extractSteps);\n    const shouldHideStep = (step) => {\n        if (step.stepClass === \"ConstantStep\")\n            return true;\n        if (step.extra?.constant?.type === \"undefined\") {\n            return true;\n        }\n        if (step.bucketId === 0 &&\n            step.isSyncAndSafe &&\n            (dependentsByStepId[step.id]?.length ?? 0) === 0) {\n            return true;\n        }\n        return false;\n    };\n    const partitionToPoly = (bucketId) => {\n        const lp = layerPlanById[bucketId];\n        if (lp.reason.type === \"polymorphicPartition\") {\n            return layerPlans.find((lp) => lp.childIds.includes(bucketId));\n        }\n        else {\n            return bucketId;\n        }\n    };\n    const isExcessivelyReferenced = (stepId) => {\n        const step = stepById[stepId];\n        if (!step)\n            return true;\n        if (step.stepClass === \"ConstantStep\")\n            return true;\n        if (step.bucketId !== 0)\n            return false;\n        const dependents = dependentsByStepId[stepId];\n        if (!dependents || dependents.length === 0)\n            return false;\n        const firstDependent = dependents[0];\n        // If it's referenced by more than one layer plan, it's excessive\n        return dependents.some((d) => partitionToPoly(d.bucketId) !==\n            partitionToPoly(firstDependent.bucketId));\n    };\n    const color = (i) => {\n        return exports.COLORS[i % exports.COLORS.length];\n    };\n    const planStyle = `fill:#fff,stroke-width:1px,color:#000`;\n    const itemplanStyle = `fill:#fff,stroke-width:2px,color:#000`;\n    const unbatchedplanStyle = `fill:#dff,stroke-width:1px,color:#000`;\n    const sideeffectplanStyle = `fill:#fcc,stroke-width:2px,color:#000`;\n    const graph = [\n        `%%{init: {'themeVariables': { 'fontSize': '12px'}}}%%`,\n        `${concise ? \"flowchart\" : \"graph\"} TD`,\n        `    classDef path fill:#eee,stroke:#000,color:#000`,\n        `    classDef plan ${planStyle}`,\n        `    classDef itemplan ${itemplanStyle}`,\n        `    classDef unbatchedplan ${unbatchedplanStyle}`,\n        `    classDef sideeffectplan ${sideeffectplanStyle}`,\n        `    classDef bucket fill:#f6f6f6,color:#000,stroke-width:2px,text-align:left`,\n        ``,\n    ];\n    const squish = (str, start = 8, end = 8) => {\n        if (str.length > start + end + 4) {\n            return `${str.slice(0, start)}...${str.slice(str.length - end)}`;\n        }\n        return str;\n    };\n    const stepToString = (step) => {\n        return `${step.stepClass.replace(/Step$/, \"\")}${step.bucketId === 0 ? \"\" : `{${step.bucketId}}`}${step.metaString ? `<${step.metaString}>` : \"\"}[${step.id}]`;\n    };\n    const layerPlans = Object.values(layerPlanById);\n    if (!skipBuckets) {\n        if (!concise)\n            graph.push(\"    subgraph Buckets\");\n        for (let i = 0, l = layerPlans.length; i < l; i++) {\n            const layerPlan = layerPlans[i];\n            const raisonDEtre = ` (${layerPlan.reason.type})` +\n                (layerPlan.reason.type === \"polymorphicPartition\"\n                    ? `\\n|${layerPlan.reason.typeNames.join(\"\\n|\")}`\n                    : layerPlan.reason.type === \"polymorphic\"\n                        ? `\\n__typename: ${shortStep(stepById[layerPlan.reason.parentStepId])}`\n                        : ``);\n            graph.push(`    Bucket${layerPlan.id}(${(0, exports.mermaidEscape)(`Bucket ${layerPlan.id}${raisonDEtre}${layerPlan.parentSideEffectStepId != null\n                ? `\\nParent side effect step: ${stepById[layerPlan.parentSideEffectStepId].id}`\n                : \"\"}${layerPlan.copyStepIds.length > 0\n                ? `\\nDeps: ${layerPlan.copyStepIds\n                    .map((pId) => stepById[pId].id)\n                    .join(\", \")}`\n                : \"\"}${layerPlan.reason.type === \"polymorphicPartition\"\n                ? \"\\n\" + pp(layerPlan.reason.polymorphicPaths)\n                : \"\"}\\n${layerPlan.rootStepId != null && layerPlan.reason.type !== \"root\"\n                ? `\\nROOT ${stepToString(stepById[layerPlan.rootStepId])}`\n                : \"\"}${startSteps(layerPlan)}`)}):::bucket`);\n        }\n        if (!concise)\n            graph.push(\"    end\");\n    }\n    if (!skipBuckets) {\n        for (let i = 0, l = layerPlans.length; i < l; i++) {\n            const layerPlan = layerPlans[i];\n            const childNodes = layerPlan.childIds.map((cId) => `Bucket${cId}`);\n            if (childNodes.length > 0) {\n                graph.push(`    Bucket${layerPlan.id} --> ${childNodes.join(\" & \")}`);\n            }\n        }\n    }\n    const planIdMap = Object.create(null);\n    const planId = (plan) => {\n        if (!planIdMap[plan.id]) {\n            if (shouldHideStep(plan)) {\n                console.warn(`Was expecting to hide step ${plan.id}, but we're rendering it anyway?`);\n            }\n            const planName = plan.stepClass.replace(/Step$/, \"\");\n            const planNode = `${planName}${plan.id}`;\n            planIdMap[plan.id] = planNode;\n            const rawMeta = plan.metaString;\n            const strippedMeta = rawMeta != null ? (0, stripAnsi_js_1.stripAnsi)(rawMeta) : null;\n            const meta = concise && strippedMeta ? squish(strippedMeta) : strippedMeta;\n            const isUnbatched = plan.supportsUnbatched;\n            const polyPaths = pp(plan.polymorphicPaths);\n            const depIdsInSameBucket = plan.dependencyIds.filter((id) => stepById[id].bucketId === plan.bucketId);\n            const polyPathsAreSame = depIdsInSameBucket.length >= 1 &&\n                depIdsInSameBucket.every((id) => pp(stepById[id].polymorphicPaths) === polyPaths);\n            const polyPathsIfDifferent = polyPathsAreSame || polyPaths === \"\" ? \"\" : `\\n${polyPaths}`;\n            const [lBrace, rBrace, shape = \"\", planNameText = planName] = plan.stepClass === \"__ItemStep\"\n                ? [\"[/\", \"\\\\]\"]\n                : plan.stepClass === \"__ValueStep\" && plan.extra?.combined\n                    ? [null, null, \"docs\", \"__Combined\"]\n                    : plan.isSyncAndSafe\n                        ? isUnbatched\n                            ? [\"{{\", \"}}\"]\n                            : [\"[\", \"]\"]\n                        : [\"[[\", \"]]\"];\n            const depCount = isExcessivelyReferenced(plan.id)\n                ? `\\nDependents: ${dependentsByStepId[plan.id]?.length}`\n                : ``;\n            const extraDeps = plan.dependencyIds.filter(isExcessivelyReferenced);\n            const extraDependencies = extraDeps.length > 0\n                ? `\\nMore deps:\\n${extraDeps\n                    .map((depId) => {\n                    const step = stepById[depId];\n                    return `- ${shortStep(step)}`;\n                })\n                    .join(\"\\n\")}`\n                : ``;\n            const planString = `${planNameText}[${plan.id}${`∈${plan.bucketId}`}${plan.stream ? \"@s\" : \"\"}]${plan.isUnary ? \" ➊\" : \"\"}${polyPathsAreSame && polyPaths !== \"\" ? \"^\" : \"\"}${meta ? `\\n<${meta}>` : \"\"}${polyPathsIfDifferent}${depCount}${extraDependencies}`;\n            const planClass = plan.hasSideEffects\n                ? \"sideeffectplan\"\n                : plan.stepClass === \"__ItemStep\"\n                    ? \"itemplan\"\n                    : isUnbatched && !plan.isSyncAndSafe\n                        ? \"unbatchedplan\"\n                        : \"plan\";\n            if (lBrace === null) {\n                graph.push(`    ${planNode}:::${planClass}@{shape: ${shape}, label: ${(0, exports.mermaidEscape)(planString)}}`);\n            }\n            else {\n                graph.push(`    ${planNode}${lBrace}${(0, exports.mermaidEscape)(planString)}${rBrace}:::${planClass}`);\n            }\n        }\n        return planIdMap[plan.id];\n    };\n    graph.push(\"\");\n    graph.push(\"    %% plan dependencies\");\n    const chainByDep = Object.create(null);\n    const depDeets = (step, idx) => {\n        const forbiddenFlags = step.dependencyForbiddenFlags[idx];\n        const onReject = step.dependencyOnReject[idx];\n        // TODO: factor 'data only' into the diagrams\n        //\n        // const dataOnly = step.dependencyDataOnly[idx];\n        const info = [];\n        if (forbiddenFlags) {\n            if ((forbiddenFlags & 2) === 2) {\n                info.push(\"rejectNull\");\n            }\n            if ((forbiddenFlags & 1) === 0) {\n                info.push(\"trapError\");\n            }\n            if ((forbiddenFlags & 4) === 0) {\n                info.push(\"trapInhibited\");\n            }\n            if (onReject) {\n                info.push(`onReject=${trim((0, stripAnsi_js_1.stripAnsi)(onReject))}`);\n            }\n        }\n        const str = info.join(\";\");\n        if (str) {\n            return `|${(0, exports.mermaidEscape)(str)}|`;\n        }\n        else {\n            return \"\";\n        }\n    };\n    sortedSteps.forEach(\n    // This comment is here purely to maintain the previous formatting to reduce a git diff.\n    (plan) => {\n        if (shouldHideStep(plan))\n            return;\n        const planNode = planId(plan);\n        const depNodes = plan.dependencyIds.map((depId) => {\n            const step = stepById[depId];\n            if (shouldHideStep(step) || isExcessivelyReferenced(depId)) {\n                return null;\n            }\n            else {\n                return planId(step);\n            }\n        });\n        const transformItemPlanNode = null;\n        /*\n        plan.stepClass === '__ListTransformStep'\n          ? planId(\n              steps[operationPlan.transformDependencyPlanIdByTransformStepId[plan.id]],\n            )\n          : null;\n          */\n        const firstDep = depNodes.find((n) => n != null);\n        if (depNodes.length > 0 && firstDep) {\n            if (plan.stepClass === \"__ItemStep\") {\n                const arrow = plan.extra?.transformStepId == null ? \"==>\" : \"-.->\";\n                graph.push(`    ${firstDep} ${arrow}${depDeets(plan, 0)} ${planNode}`);\n                const normal = [];\n                for (let i = 0; i < depNodes.length; i++) {\n                    const r = depNodes[i];\n                    if (r == null || r === firstDep)\n                        continue;\n                    const deets = depDeets(plan, i);\n                    if (deets) {\n                        graph.push(`    ${r} -->${deets} ${planNode}`);\n                    }\n                    else {\n                        normal.push(r);\n                    }\n                }\n                if (normal.length > 0) {\n                    outputGroupedNormalLinks(graph, planNode, normal);\n                }\n            }\n            else {\n                if (concise &&\n                    !dependentsByStepId[plan.id] &&\n                    depNodes.length === 1) {\n                    // Try alternating the nodes so they render closer together\n                    if (chainByDep[firstDep] === undefined) {\n                        graph.push(`    ${firstDep} -->${depDeets(plan, 0)} ${planNode}`);\n                    }\n                    else {\n                        graph.push(`    ${chainByDep[firstDep]} o--o${depDeets(plan, 0)} ${planNode}`);\n                    }\n                    chainByDep[firstDep] = planNode;\n                }\n                else {\n                    const normal = [];\n                    for (let i = 0; i < depNodes.length; i++) {\n                        const r = depNodes[i];\n                        if (r == null)\n                            continue;\n                        const deets = depDeets(plan, i);\n                        if (deets) {\n                            graph.push(`    ${r} -->${deets} ${planNode}`);\n                        }\n                        else {\n                            normal.push(r);\n                        }\n                    }\n                    outputGroupedNormalLinks(graph, planNode, normal);\n                }\n            }\n        }\n        if (transformItemPlanNode) {\n            graph.push(`    ${transformItemPlanNode} -.-> ${planNode}`);\n        }\n        return plan;\n    });\n    graph.push(\"\");\n    graph.push(\"    %% define steps\");\n    sortedSteps.forEach((step) => {\n        if (!shouldHideStep(step)) {\n            planId(step);\n        }\n    });\n    for (let i = 0, l = layerPlans.length; i < l; i++) {\n        const layerPlan = layerPlans[i];\n        const steps = layerPlan.steps;\n        graph.push(`    classDef bucket${layerPlan.id} stroke:${color(typeof layerPlan.id === \"number\" ? layerPlan.id : Object.values(layerPlanById).indexOf(layerPlan))}`);\n        graph.push(`    class ${[\n            `Bucket${layerPlan.id}`,\n            ...steps.filter((s) => !shouldHideStep(s)).map(planId),\n        ].join(\",\")} bucket${layerPlan.id}`);\n    }\n    let firstSideEffect = true;\n    sortedSteps.forEach((step) => {\n        if (step.implicitSideEffectStepId) {\n            if (firstSideEffect) {\n                graph.push(\"\");\n                graph.push(\"    %% implicit side effects\");\n                firstSideEffect = false;\n            }\n            const sideEffectStep = stepById[step.implicitSideEffectStepId];\n            graph.push(`    ${planId(sideEffectStep)} -.-o ${planId(step)}`);\n        }\n    });\n    graph.push(\"\");\n    // Handle concat for any \"combination\" layer plans\n    for (let i = 0, l = layerPlans.length; i < l; i++) {\n        const layerPlan = layerPlans[i];\n        if (layerPlan.reason.type === \"combined\") {\n            for (const { targetStepId, sources } of layerPlan.reason.combinations) {\n                const targetStep = stepById[targetStepId];\n                for (const { stepId } of sources) {\n                    const step = stepById[stepId];\n                    graph.push(`    ${planId(step)} -.-x ${planId(targetStep)}`);\n                }\n            }\n        }\n    }\n    const graphString = graph.join(\"\\n\");\n    return graphString;\n    function startSteps(layerPlan) {\n        return layerPlan.phases.length === 1\n            ? ``\n            : `\\n${layerPlan.phases\n                .map((phase, i) => `${i + 1}: ${shortSteps(phase.normalStepIds?.map((id) => stepById[id]))}${phase.unbatchedStepIds\n                ? `\\n>: ${shortSteps(phase.unbatchedStepIds.map((id) => stepById[id]))}`\n                : \"\"}`)\n                .join(\"\\n\")}`;\n    }\n}\nfunction shortStep(step) {\n    if (step.stepClass === \"ConstantStep\") {\n        return `Constant${step.metaString ? `<${step.metaString}>` : \"\"}[${step.id}]`;\n    }\n    return `${step.stepClass.replace(/Step$/, \"\") ?? \"\"}[${step.id}]`;\n}\nfunction shortSteps(steps) {\n    if (!steps) {\n        return \"\";\n    }\n    const str = steps.map(shortStep).join(\", \");\n    if (str.length < 40) {\n        return str;\n    }\n    else {\n        return steps.map((s) => s.id).join(\", \");\n    }\n}\nfunction pp(polymorphicPaths) {\n    if (polymorphicPaths == null) {\n        return \"\";\n    }\n    const counts = Object.create(null);\n    const out = [];\n    const last = Object.create(null);\n    for (const p of polymorphicPaths) {\n        const i = p.lastIndexOf(\">\");\n        if (i <= 0) {\n            out.push(p);\n        }\n        else {\n            const end = p.slice(i);\n            last[end] = p;\n            if (counts[end]) {\n                counts[end]++;\n            }\n            else {\n                counts[end] = 1;\n            }\n        }\n    }\n    for (const [end, count] of Object.entries(counts)) {\n        out.push(count === 1 ? last[end] : `(${count}) ...${end}`);\n    }\n    return out.join(\"\\n\");\n}\ntslib_1.__exportStar(require(\"./planJSONInterfaces.js\"), exports);\nfunction trim(string, length = 15) {\n    if (string.length > length) {\n        return string.substring(0, length - 2) + \"…\";\n    }\n    else {\n        return string;\n    }\n}\nfunction outputGroupedNormalLinks(graph, planNode, normal) {\n    if (normal.length) {\n        const counts = Object.create(null);\n        for (const n of normal) {\n            if (counts[n]) {\n                counts[n]++;\n            }\n            else {\n                counts[n] = 1;\n            }\n        }\n        const oners = Object.keys(counts).filter((n) => counts[n] === 1);\n        if (oners.length >= 1) {\n            graph.push(`    ${oners.join(\" & \")} --> ${planNode}`);\n        }\n        for (const [n, c] of Object.entries(counts)) {\n            if (c !== 1) {\n                graph.push(`    ${n} -- ${c} --> ${planNode}`);\n            }\n        }\n    }\n}\n//# sourceMappingURL=mermaid.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=planJSONInterfaces.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ANSI_REGEXP = void 0;\nexports.stripAnsi = stripAnsi;\n// Extracted from https://github.com/chalk/ansi-regex MIT license\n// Copyright (c) Sindre Sorhus <sindresorhus@gmail.com> (https://sindresorhus.com)\n// Copyright (c) Benjie (https://twitter.com/benjie)\nexports.ANSI_REGEXP = \n// eslint-disable-next-line no-control-regex, no-useless-escape\n/[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)|(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-nq-uy=><~]))/g;\nfunction stripAnsi(str) {\n    return str.replace(exports.ANSI_REGEXP, \"\");\n}\n//# sourceMappingURL=stripAnsi.js.map","import { jsx as _jsx } from \"react/jsx-runtime\";\nimport { planToMermaid } from \"grafast/mermaid\";\nimport mermaid from \"mermaid\";\nimport { useEffect, useMemo } from \"react\";\nlet initialized = false;\nconst MermaidReal = ({ plan }) => {\n    const diagram = useMemo(() => planToMermaid(plan), [plan]);\n    useEffect(() => {\n        if (!initialized) {\n            initialized = true;\n            mermaid.initialize({\n                startOnLoad: true,\n                maxTextSize: 1000000,\n                maxEdges: 1000,\n            });\n        }\n        if (diagram) {\n            mermaid.contentLoaded();\n        }\n    }, [diagram]);\n    return (_jsx(\"div\", { className: \"mermaid\", children: diagram }, diagram));\n};\nexport default MermaidReal;\n//# sourceMappingURL=MermaidReal.js.map"],"names":["Object","defineProperty","exports","value","mermaidEscape","COLORS","planToMermaid","planJSON","concise","skipBuckets","g","grafastExplainMermaidSkipBuckets","version","Error","stepById","create","layerPlanById","dependentsByStepId","sortedSteps","buckets","forEach","bucket","id","sorted","steps","sort","a","z","dependencyIds","length","step","stepClass","metaString","push","depId","shouldHideStep","extra","constant","type","bucketId","isSyncAndSafe","partitionToPoly","reason","layerPlans","find","lp","childIds","includes","isExcessivelyReferenced","stepId","dependents","firstDependent","some","d","color","i","graph","stepToString","replace","values","l","layerPlan","raisonDEtre","typeNames","join","shortStep","parentStepId","parentSideEffectStepId","copyStepIds","map","pId","pp","polymorphicPaths","rootStepId","startSteps","childNodes","cId","planIdMap","planId","plan","console","warn","planName","planNode","rawMeta","strippedMeta","stripAnsi_js_1","stripAnsi","meta","str","start","end","slice","squish","isUnbatched","supportsUnbatched","polyPaths","depIdsInSameBucket","filter","polyPathsAreSame","every","polyPathsIfDifferent","lBrace","rBrace","shape","planNameText","combined","depCount","extraDeps","extraDependencies","planString","stream","isUnary","planClass","hasSideEffects","chainByDep","depDeets","idx","forbiddenFlags","dependencyForbiddenFlags","onReject","dependencyOnReject","info","string","substring","trim","depNodes","firstDep","n","arrow","transformStepId","normal","r","deets","outputGroupedNormalLinks","undefined","indexOf","s","firstSideEffect","implicitSideEffectStepId","sideEffectStep","targetStepId","sources","combinations","targetStep","phases","phase","shortSteps","normalStepIds","unbatchedStepIds","tslib_1","counts","out","last","p","lastIndexOf","count","entries","oners","keys","c","match","__exportStar","ANSI_REGEXP","initialized","diagram","useMemo","useEffect","initialize","startOnLoad","maxTextSize","maxEdges","contentLoaded","className","children"],"sourceRoot":""}