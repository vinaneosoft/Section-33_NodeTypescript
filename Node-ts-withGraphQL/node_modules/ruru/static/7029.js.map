{"version":3,"file":"7029.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/semanticTokensDto.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { VSBuffer } from '../../../base/common/buffer.js';\nimport * as platform from '../../../base/common/platform.js';\nfunction reverseEndianness(arr) {\n    for (let i = 0, len = arr.length; i < len; i += 4) {\n        // flip bytes 0<->3 and 1<->2\n        const b0 = arr[i + 0];\n        const b1 = arr[i + 1];\n        const b2 = arr[i + 2];\n        const b3 = arr[i + 3];\n        arr[i + 0] = b3;\n        arr[i + 1] = b2;\n        arr[i + 2] = b1;\n        arr[i + 3] = b0;\n    }\n}\nfunction toLittleEndianBuffer(arr) {\n    const uint8Arr = new Uint8Array(arr.buffer, arr.byteOffset, arr.length * 4);\n    if (!platform.isLittleEndian()) {\n        // the byte order must be changed\n        reverseEndianness(uint8Arr);\n    }\n    return VSBuffer.wrap(uint8Arr);\n}\nexport function encodeSemanticTokensDto(semanticTokens) {\n    const dest = new Uint32Array(encodeSemanticTokensDtoSize(semanticTokens));\n    let offset = 0;\n    dest[offset++] = semanticTokens.id;\n    if (semanticTokens.type === 'full') {\n        dest[offset++] = 1 /* EncodedSemanticTokensType.Full */;\n        dest[offset++] = semanticTokens.data.length;\n        dest.set(semanticTokens.data, offset);\n        offset += semanticTokens.data.length;\n    }\n    else {\n        dest[offset++] = 2 /* EncodedSemanticTokensType.Delta */;\n        dest[offset++] = semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            dest[offset++] = delta.start;\n            dest[offset++] = delta.deleteCount;\n            if (delta.data) {\n                dest[offset++] = delta.data.length;\n                dest.set(delta.data, offset);\n                offset += delta.data.length;\n            }\n            else {\n                dest[offset++] = 0;\n            }\n        }\n    }\n    return toLittleEndianBuffer(dest);\n}\nfunction encodeSemanticTokensDtoSize(semanticTokens) {\n    let result = 0;\n    result += (+1 // id\n        + 1 // type\n    );\n    if (semanticTokens.type === 'full') {\n        result += (+1 // data length\n            + semanticTokens.data.length);\n    }\n    else {\n        result += (+1 // delta count\n        );\n        result += (+1 // start\n            + 1 // deleteCount\n            + 1 // data length\n        ) * semanticTokens.deltas.length;\n        for (const delta of semanticTokens.deltas) {\n            if (delta.data) {\n                result += delta.data.length;\n            }\n        }\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n"],"names":["encodeSemanticTokensDto","semanticTokens","dest","Uint32Array","result","type","data","length","deltas","delta","encodeSemanticTokensDtoSize","offset","id","set","start","deleteCount","arr","uint8Arr","Uint8Array","buffer","byteOffset","i","len","b0","b1","b2","b3","reverseEndianness","wrap","toLittleEndianBuffer","hasBuffer","Buffer","textDecoder","VSBuffer","actual","isBuffer","from","byteLength","constructor","this","toString","TextDecoder","decode","readUInt16LE","source","writeUInt16LE","destination","value","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8"],"sourceRoot":""}