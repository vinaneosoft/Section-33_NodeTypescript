{"version":3,"file":"1320.js","mappings":"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","sources":["webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/smallImmutableSet.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelEvents.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/undoRedo/common/undoRedo.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/textChange.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/cursorColumns.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelBracketPairs.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/bracketPairsTree.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsImpl.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/indentationGuesser.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/intervalTree.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/rbTreeBase.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeBase.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBuffer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/fixedArray.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousMultilineTokensBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/treeSitterTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensEditing.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/contiguousTokensStore.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/sparseTokensStore.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/tokenizationTextModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModel.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/stringBuilder.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/extensions.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/base/common/buffer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/beforeEditPositionMapper.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/richEditBrackets.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/ast.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/textModelDefaults.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/nullTokenize.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/guidesTextModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/treeSitterParserService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/brackets.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/characterPair.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/electricCharacter.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/indentRules.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/onEnter.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports/languageBracketsConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/languageConfigurationRegistry.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/tokenizer.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/tokens/lineTokens.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/concat23Trees.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/nodeReader.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/parser.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/combineTextEditInfos.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/platform/instantiation/common/descriptors.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/textModelGuides.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/textModelPart.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/utils.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/bracketPairsTextModelPart/bracketPairsTree/length.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/modelService.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/core/indentation.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/services/textResourceConfiguration.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/languages/supports.js","webpack://ruru/../../node_modules/monaco-editor/esm/vs/editor/common/model/editStack.js"],"sourcesContent":["/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nconst emptyArr = [];\n/**\n * Represents an immutable set that works best for a small number of elements (less than 32).\n * It uses bits to encode element membership efficiently.\n*/\nexport class SmallImmutableSet {\n    static { this.cache = new Array(129); }\n    static create(items, additionalItems) {\n        if (items <= 128 && additionalItems.length === 0) {\n            // We create a cache of 128=2^7 elements to cover all sets with up to 7 (dense) elements.\n            let cached = SmallImmutableSet.cache[items];\n            if (!cached) {\n                cached = new SmallImmutableSet(items, additionalItems);\n                SmallImmutableSet.cache[items] = cached;\n            }\n            return cached;\n        }\n        return new SmallImmutableSet(items, additionalItems);\n    }\n    static { this.empty = SmallImmutableSet.create(0, emptyArr); }\n    static getEmpty() {\n        return this.empty;\n    }\n    constructor(items, additionalItems) {\n        this.items = items;\n        this.additionalItems = additionalItems;\n    }\n    add(value, keyProvider) {\n        const key = keyProvider.getKey(value);\n        let idx = key >> 5; // divided by 32\n        if (idx === 0) {\n            // fast path\n            const newItem = (1 << key) | this.items;\n            if (newItem === this.items) {\n                return this;\n            }\n            return SmallImmutableSet.create(newItem, this.additionalItems);\n        }\n        idx--;\n        const newItems = this.additionalItems.slice(0);\n        while (newItems.length < idx) {\n            newItems.push(0);\n        }\n        newItems[idx] |= 1 << (key & 31);\n        return SmallImmutableSet.create(this.items, newItems);\n    }\n    merge(other) {\n        const merged = this.items | other.items;\n        if (this.additionalItems === emptyArr && other.additionalItems === emptyArr) {\n            // fast path\n            if (merged === this.items) {\n                return this;\n            }\n            if (merged === other.items) {\n                return other;\n            }\n            return SmallImmutableSet.create(merged, emptyArr);\n        }\n        // This can be optimized, but it's not a common case\n        const newItems = [];\n        for (let i = 0; i < Math.max(this.additionalItems.length, other.additionalItems.length); i++) {\n            const item1 = this.additionalItems[i] || 0;\n            const item2 = other.additionalItems[i] || 0;\n            newItems.push(item1 | item2);\n        }\n        return SmallImmutableSet.create(merged, newItems);\n    }\n    intersects(other) {\n        if ((this.items & other.items) !== 0) {\n            return true;\n        }\n        for (let i = 0; i < Math.min(this.additionalItems.length, other.additionalItems.length); i++) {\n            if ((this.additionalItems[i] & other.additionalItems[i]) !== 0) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\nexport const identityKeyProvider = {\n    getKey(value) {\n        return value;\n    }\n};\n/**\n * Assigns values a unique incrementing key.\n*/\nexport class DenseKeyProvider {\n    constructor() {\n        this.items = new Map();\n    }\n    getKey(value) {\n        let existing = this.items.get(value);\n        if (existing === undefined) {\n            existing = this.items.size;\n            this.items.set(value, existing);\n        }\n        return existing;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * An event describing that a model has been reset to a new value.\n * @internal\n */\nexport class ModelRawFlush {\n    constructor() {\n        this.changeType = 1 /* RawContentChangedType.Flush */;\n    }\n}\n/**\n * Represents text injected on a line\n * @internal\n */\nexport class LineInjectedText {\n    static applyInjectedText(lineText, injectedTexts) {\n        if (!injectedTexts || injectedTexts.length === 0) {\n            return lineText;\n        }\n        let result = '';\n        let lastOriginalOffset = 0;\n        for (const injectedText of injectedTexts) {\n            result += lineText.substring(lastOriginalOffset, injectedText.column - 1);\n            lastOriginalOffset = injectedText.column - 1;\n            result += injectedText.options.content;\n        }\n        result += lineText.substring(lastOriginalOffset);\n        return result;\n    }\n    static fromDecorations(decorations) {\n        const result = [];\n        for (const decoration of decorations) {\n            if (decoration.options.before && decoration.options.before.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.startLineNumber, decoration.range.startColumn, decoration.options.before, 0));\n            }\n            if (decoration.options.after && decoration.options.after.content.length > 0) {\n                result.push(new LineInjectedText(decoration.ownerId, decoration.range.endLineNumber, decoration.range.endColumn, decoration.options.after, 1));\n            }\n        }\n        result.sort((a, b) => {\n            if (a.lineNumber === b.lineNumber) {\n                if (a.column === b.column) {\n                    return a.order - b.order;\n                }\n                return a.column - b.column;\n            }\n            return a.lineNumber - b.lineNumber;\n        });\n        return result;\n    }\n    constructor(ownerId, lineNumber, column, options, order) {\n        this.ownerId = ownerId;\n        this.lineNumber = lineNumber;\n        this.column = column;\n        this.options = options;\n        this.order = order;\n    }\n}\n/**\n * An event describing that a line has changed in a model.\n * @internal\n */\nexport class ModelRawLineChanged {\n    constructor(lineNumber, detail, injectedText) {\n        this.changeType = 2 /* RawContentChangedType.LineChanged */;\n        this.lineNumber = lineNumber;\n        this.detail = detail;\n        this.injectedText = injectedText;\n    }\n}\n/**\n * An event describing that line(s) have been deleted in a model.\n * @internal\n */\nexport class ModelRawLinesDeleted {\n    constructor(fromLineNumber, toLineNumber) {\n        this.changeType = 3 /* RawContentChangedType.LinesDeleted */;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n    }\n}\n/**\n * An event describing that line(s) have been inserted in a model.\n * @internal\n */\nexport class ModelRawLinesInserted {\n    constructor(fromLineNumber, toLineNumber, detail, injectedTexts) {\n        this.changeType = 4 /* RawContentChangedType.LinesInserted */;\n        this.injectedTexts = injectedTexts;\n        this.fromLineNumber = fromLineNumber;\n        this.toLineNumber = toLineNumber;\n        this.detail = detail;\n    }\n}\n/**\n * An event describing that a model has had its EOL changed.\n * @internal\n */\nexport class ModelRawEOLChanged {\n    constructor() {\n        this.changeType = 5 /* RawContentChangedType.EOLChanged */;\n    }\n}\n/**\n * An event describing a change in the text of a model.\n * @internal\n */\nexport class ModelRawContentChangedEvent {\n    constructor(changes, versionId, isUndoing, isRedoing) {\n        this.changes = changes;\n        this.versionId = versionId;\n        this.isUndoing = isUndoing;\n        this.isRedoing = isRedoing;\n        this.resultingSelection = null;\n    }\n    containsEvent(type) {\n        for (let i = 0, len = this.changes.length; i < len; i++) {\n            const change = this.changes[i];\n            if (change.changeType === type) {\n                return true;\n            }\n        }\n        return false;\n    }\n    static merge(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        return new ModelRawContentChangedEvent(changes, versionId, isUndoing, isRedoing);\n    }\n}\n/**\n * An event describing a change in injected text.\n * @internal\n */\nexport class ModelInjectedTextChangedEvent {\n    constructor(changes) {\n        this.changes = changes;\n    }\n}\n/**\n * @internal\n */\nexport class InternalModelContentChangeEvent {\n    constructor(rawContentChangedEvent, contentChangedEvent) {\n        this.rawContentChangedEvent = rawContentChangedEvent;\n        this.contentChangedEvent = contentChangedEvent;\n    }\n    merge(other) {\n        const rawContentChangedEvent = ModelRawContentChangedEvent.merge(this.rawContentChangedEvent, other.rawContentChangedEvent);\n        const contentChangedEvent = InternalModelContentChangeEvent._mergeChangeEvents(this.contentChangedEvent, other.contentChangedEvent);\n        return new InternalModelContentChangeEvent(rawContentChangedEvent, contentChangedEvent);\n    }\n    static _mergeChangeEvents(a, b) {\n        const changes = [].concat(a.changes).concat(b.changes);\n        const eol = b.eol;\n        const versionId = b.versionId;\n        const isUndoing = (a.isUndoing || b.isUndoing);\n        const isRedoing = (a.isRedoing || b.isRedoing);\n        const isFlush = (a.isFlush || b.isFlush);\n        const isEolChange = a.isEolChange && b.isEolChange; // both must be true to not confuse listeners who skip such edits\n        return {\n            changes: changes,\n            eol: eol,\n            isEolChange: isEolChange,\n            versionId: versionId,\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush,\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { createDecorator } from '../../instantiation/common/instantiation.js';\nexport const IUndoRedoService = createDecorator('undoRedoService');\nexport class ResourceEditStackSnapshot {\n    constructor(resource, elements) {\n        this.resource = resource;\n        this.elements = elements;\n    }\n}\nexport class UndoRedoGroup {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoGroup._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoGroup(); }\n}\nexport class UndoRedoSource {\n    static { this._ID = 0; }\n    constructor() {\n        this.id = UndoRedoSource._ID++;\n        this.order = 1;\n    }\n    nextOrder() {\n        if (this.id === 0) {\n            return 0;\n        }\n        return this.order++;\n    }\n    static { this.None = new UndoRedoSource(); }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as buffer from '../../../base/common/buffer.js';\nimport { decodeUTF16LE } from './stringBuilder.js';\nfunction escapeNewLine(str) {\n    return (str\n        .replace(/\\n/g, '\\\\n')\n        .replace(/\\r/g, '\\\\r'));\n}\nexport class TextChange {\n    get oldLength() {\n        return this.oldText.length;\n    }\n    get oldEnd() {\n        return this.oldPosition + this.oldText.length;\n    }\n    get newLength() {\n        return this.newText.length;\n    }\n    get newEnd() {\n        return this.newPosition + this.newText.length;\n    }\n    constructor(oldPosition, oldText, newPosition, newText) {\n        this.oldPosition = oldPosition;\n        this.oldText = oldText;\n        this.newPosition = newPosition;\n        this.newText = newText;\n    }\n    toString() {\n        if (this.oldText.length === 0) {\n            return `(insert@${this.oldPosition} \"${escapeNewLine(this.newText)}\")`;\n        }\n        if (this.newText.length === 0) {\n            return `(delete@${this.oldPosition} \"${escapeNewLine(this.oldText)}\")`;\n        }\n        return `(replace@${this.oldPosition} \"${escapeNewLine(this.oldText)}\" with \"${escapeNewLine(this.newText)}\")`;\n    }\n    static _writeStringSize(str) {\n        return (4 + 2 * str.length);\n    }\n    static _writeString(b, str, offset) {\n        const len = str.length;\n        buffer.writeUInt32BE(b, len, offset);\n        offset += 4;\n        for (let i = 0; i < len; i++) {\n            buffer.writeUInt16LE(b, str.charCodeAt(i), offset);\n            offset += 2;\n        }\n        return offset;\n    }\n    static _readString(b, offset) {\n        const len = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        return decodeUTF16LE(b, offset, len);\n    }\n    writeSize() {\n        return (+4 // oldPosition\n            + 4 // newPosition\n            + TextChange._writeStringSize(this.oldText)\n            + TextChange._writeStringSize(this.newText));\n    }\n    write(b, offset) {\n        buffer.writeUInt32BE(b, this.oldPosition, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.newPosition, offset);\n        offset += 4;\n        offset = TextChange._writeString(b, this.oldText, offset);\n        offset = TextChange._writeString(b, this.newText, offset);\n        return offset;\n    }\n    static read(b, offset, dest) {\n        const oldPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const newPosition = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const oldText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(oldText);\n        const newText = TextChange._readString(b, offset);\n        offset += TextChange._writeStringSize(newText);\n        dest.push(new TextChange(oldPosition, oldText, newPosition, newText));\n        return offset;\n    }\n}\nexport function compressConsecutiveTextChanges(prevEdits, currEdits) {\n    if (prevEdits === null || prevEdits.length === 0) {\n        return currEdits;\n    }\n    const compressor = new TextChangeCompressor(prevEdits, currEdits);\n    return compressor.compress();\n}\nclass TextChangeCompressor {\n    constructor(prevEdits, currEdits) {\n        this._prevEdits = prevEdits;\n        this._currEdits = currEdits;\n        this._result = [];\n        this._resultLen = 0;\n        this._prevLen = this._prevEdits.length;\n        this._prevDeltaOffset = 0;\n        this._currLen = this._currEdits.length;\n        this._currDeltaOffset = 0;\n    }\n    compress() {\n        let prevIndex = 0;\n        let currIndex = 0;\n        let prevEdit = this._getPrev(prevIndex);\n        let currEdit = this._getCurr(currIndex);\n        while (prevIndex < this._prevLen || currIndex < this._currLen) {\n            if (prevEdit === null) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (currEdit === null) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldEnd <= prevEdit.newPosition) {\n                this._acceptCurr(currEdit);\n                currEdit = this._getCurr(++currIndex);\n                continue;\n            }\n            if (prevEdit.newEnd <= currEdit.oldPosition) {\n                this._acceptPrev(prevEdit);\n                prevEdit = this._getPrev(++prevIndex);\n                continue;\n            }\n            if (currEdit.oldPosition < prevEdit.newPosition) {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newPosition - currEdit.oldPosition);\n                this._acceptCurr(e1);\n                currEdit = e2;\n                continue;\n            }\n            if (prevEdit.newPosition < currEdit.oldPosition) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldPosition - prevEdit.newPosition);\n                this._acceptPrev(e1);\n                prevEdit = e2;\n                continue;\n            }\n            // At this point, currEdit.oldPosition === prevEdit.newPosition\n            let mergePrev;\n            let mergeCurr;\n            if (currEdit.oldEnd === prevEdit.newEnd) {\n                mergePrev = prevEdit;\n                mergeCurr = currEdit;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = this._getCurr(++currIndex);\n            }\n            else if (currEdit.oldEnd < prevEdit.newEnd) {\n                const [e1, e2] = TextChangeCompressor._splitPrev(prevEdit, currEdit.oldLength);\n                mergePrev = e1;\n                mergeCurr = currEdit;\n                prevEdit = e2;\n                currEdit = this._getCurr(++currIndex);\n            }\n            else {\n                const [e1, e2] = TextChangeCompressor._splitCurr(currEdit, prevEdit.newLength);\n                mergePrev = prevEdit;\n                mergeCurr = e1;\n                prevEdit = this._getPrev(++prevIndex);\n                currEdit = e2;\n            }\n            this._result[this._resultLen++] = new TextChange(mergePrev.oldPosition, mergePrev.oldText, mergeCurr.newPosition, mergeCurr.newText);\n            this._prevDeltaOffset += mergePrev.newLength - mergePrev.oldLength;\n            this._currDeltaOffset += mergeCurr.newLength - mergeCurr.oldLength;\n        }\n        const merged = TextChangeCompressor._merge(this._result);\n        const cleaned = TextChangeCompressor._removeNoOps(merged);\n        return cleaned;\n    }\n    _acceptCurr(currEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebaseCurr(this._prevDeltaOffset, currEdit);\n        this._currDeltaOffset += currEdit.newLength - currEdit.oldLength;\n    }\n    _getCurr(currIndex) {\n        return (currIndex < this._currLen ? this._currEdits[currIndex] : null);\n    }\n    _acceptPrev(prevEdit) {\n        this._result[this._resultLen++] = TextChangeCompressor._rebasePrev(this._currDeltaOffset, prevEdit);\n        this._prevDeltaOffset += prevEdit.newLength - prevEdit.oldLength;\n    }\n    _getPrev(prevIndex) {\n        return (prevIndex < this._prevLen ? this._prevEdits[prevIndex] : null);\n    }\n    static _rebaseCurr(prevDeltaOffset, currEdit) {\n        return new TextChange(currEdit.oldPosition - prevDeltaOffset, currEdit.oldText, currEdit.newPosition, currEdit.newText);\n    }\n    static _rebasePrev(currDeltaOffset, prevEdit) {\n        return new TextChange(prevEdit.oldPosition, prevEdit.oldText, prevEdit.newPosition + currDeltaOffset, prevEdit.newText);\n    }\n    static _splitPrev(edit, offset) {\n        const preText = edit.newText.substr(0, offset);\n        const postText = edit.newText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, edit.oldText, edit.newPosition, preText),\n            new TextChange(edit.oldEnd, '', edit.newPosition + offset, postText)\n        ];\n    }\n    static _splitCurr(edit, offset) {\n        const preText = edit.oldText.substr(0, offset);\n        const postText = edit.oldText.substr(offset);\n        return [\n            new TextChange(edit.oldPosition, preText, edit.newPosition, edit.newText),\n            new TextChange(edit.oldPosition + offset, postText, edit.newEnd, '')\n        ];\n    }\n    static _merge(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        let prev = edits[0];\n        for (let i = 1; i < edits.length; i++) {\n            const curr = edits[i];\n            if (prev.oldEnd === curr.oldPosition) {\n                // Merge into `prev`\n                prev = new TextChange(prev.oldPosition, prev.oldText + curr.oldText, prev.newPosition, prev.newText + curr.newText);\n            }\n            else {\n                result[resultLen++] = prev;\n                prev = curr;\n            }\n        }\n        result[resultLen++] = prev;\n        return result;\n    }\n    static _removeNoOps(edits) {\n        if (edits.length === 0) {\n            return edits;\n        }\n        const result = [];\n        let resultLen = 0;\n        for (let i = 0; i < edits.length; i++) {\n            const edit = edits[i];\n            if (edit.oldText === edit.newText) {\n                continue;\n            }\n            result[resultLen++] = edit;\n        }\n        return result;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\n/**\n * A column in a position is the gap between two adjacent characters. The methods here\n * work with a concept called \"visible column\". A visible column is a very rough approximation\n * of the horizontal screen position of a column. For example, using a tab size of 4:\n * ```txt\n * |<TAB>|<TAB>|T|ext\n * |     |     | \\---- column = 4, visible column = 9\n * |     |     \\------ column = 3, visible column = 8\n * |     \\------------ column = 2, visible column = 4\n * \\------------------ column = 1, visible column = 0\n * ```\n *\n * **NOTE**: Visual columns do not work well for RTL text or variable-width fonts or characters.\n *\n * **NOTE**: These methods work and make sense both on the model and on the view model.\n */\nexport class CursorColumns {\n    static _nextVisibleColumn(codePoint, visibleColumn, tabSize) {\n        if (codePoint === 9 /* CharCode.Tab */) {\n            return CursorColumns.nextRenderTabStop(visibleColumn, tabSize);\n        }\n        if (strings.isFullWidthCharacter(codePoint) || strings.isEmojiImprecise(codePoint)) {\n            return visibleColumn + 2;\n        }\n        return visibleColumn + 1;\n    }\n    /**\n     * Returns a visible column from a column.\n     * @see {@link CursorColumns}\n     */\n    static visibleColumnFromColumn(lineContent, column, tabSize) {\n        const textLen = Math.min(column - 1, lineContent.length);\n        const text = lineContent.substring(0, textLen);\n        const iterator = new strings.GraphemeIterator(text);\n        let result = 0;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(text, textLen, iterator.offset);\n            iterator.nextGraphemeLength();\n            result = this._nextVisibleColumn(codePoint, result, tabSize);\n        }\n        return result;\n    }\n    /**\n     * Returns a column from a visible column.\n     * @see {@link CursorColumns}\n     */\n    static columnFromVisibleColumn(lineContent, visibleColumn, tabSize) {\n        if (visibleColumn <= 0) {\n            return 1;\n        }\n        const lineContentLength = lineContent.length;\n        const iterator = new strings.GraphemeIterator(lineContent);\n        let beforeVisibleColumn = 0;\n        let beforeColumn = 1;\n        while (!iterator.eol()) {\n            const codePoint = strings.getNextCodePoint(lineContent, lineContentLength, iterator.offset);\n            iterator.nextGraphemeLength();\n            const afterVisibleColumn = this._nextVisibleColumn(codePoint, beforeVisibleColumn, tabSize);\n            const afterColumn = iterator.offset + 1;\n            if (afterVisibleColumn >= visibleColumn) {\n                const beforeDelta = visibleColumn - beforeVisibleColumn;\n                const afterDelta = afterVisibleColumn - visibleColumn;\n                if (afterDelta < beforeDelta) {\n                    return afterColumn;\n                }\n                else {\n                    return beforeColumn;\n                }\n            }\n            beforeVisibleColumn = afterVisibleColumn;\n            beforeColumn = afterColumn;\n        }\n        // walked the entire string\n        return lineContentLength + 1;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextRenderTabStop(visibleColumn, tabSize) {\n        return visibleColumn + tabSize - visibleColumn % tabSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static nextIndentTabStop(visibleColumn, indentSize) {\n        return visibleColumn + indentSize - visibleColumn % indentSize;\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevRenderTabStop(column, tabSize) {\n        return Math.max(0, column - 1 - (column - 1) % tabSize);\n    }\n    /**\n     * ATTENTION: This works with 0-based columns (as opposed to the regular 1-based columns)\n     * @see {@link CursorColumns}\n     */\n    static prevIndentTabStop(column, indentSize) {\n        return Math.max(0, column - 1 - (column - 1) % indentSize);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class BracketInfo {\n    constructor(range, \n    /** 0-based level */\n    nestingLevel, nestingLevelOfEqualBracketType, isInvalid) {\n        this.range = range;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.isInvalid = isInvalid;\n    }\n}\nexport class BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /** 0-based */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode) {\n        this.range = range;\n        this.openingBracketRange = openingBracketRange;\n        this.closingBracketRange = closingBracketRange;\n        this.nestingLevel = nestingLevel;\n        this.nestingLevelOfEqualBracketType = nestingLevelOfEqualBracketType;\n        this.bracketPairNode = bracketPairNode;\n    }\n    get openingBracketInfo() {\n        return this.bracketPairNode.openingBracket.bracketInfo;\n    }\n}\nexport class BracketPairWithMinIndentationInfo extends BracketPairInfo {\n    constructor(range, openingBracketRange, closingBracketRange, \n    /**\n     * 0-based\n    */\n    nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode, \n    /**\n     * -1 if not requested, otherwise the size of the minimum indentation in the bracket pair in terms of visible columns.\n    */\n    minVisibleColumnIndentation) {\n        super(range, openingBracketRange, closingBracketRange, nestingLevel, nestingLevelOfEqualBracketType, bracketPairNode);\n        this.minVisibleColumnIndentation = minVisibleColumnIndentation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../../base/common/event.js';\nimport { Disposable } from '../../../../../base/common/lifecycle.js';\nimport { BracketInfo, BracketPairWithMinIndentationInfo } from '../../../textModelBracketPairs.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { LanguageAgnosticBracketTokens } from './brackets.js';\nimport { lengthAdd, lengthGreaterThanEqual, lengthLessThan, lengthLessThanEqual, lengthsToRange, lengthZero, positionToLength, toLength } from './length.js';\nimport { parseDocument } from './parser.js';\nimport { DenseKeyProvider } from './smallImmutableSet.js';\nimport { FastTokenizer, TextBufferTokenizer } from './tokenizer.js';\nimport { CallbackIterable } from '../../../../../base/common/arrays.js';\nimport { combineTextEditInfos } from './combineTextEditInfos.js';\nexport class BracketPairsTree extends Disposable {\n    didLanguageChange(languageId) {\n        return this.brackets.didLanguageChange(languageId);\n    }\n    constructor(textModel, getLanguageConfiguration) {\n        super();\n        this.textModel = textModel;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.didChangeEmitter = new Emitter();\n        this.denseKeyProvider = new DenseKeyProvider();\n        this.brackets = new LanguageAgnosticBracketTokens(this.denseKeyProvider, this.getLanguageConfiguration);\n        this.onDidChange = this.didChangeEmitter.event;\n        this.queuedTextEditsForInitialAstWithoutTokens = [];\n        this.queuedTextEdits = [];\n        if (!textModel.tokenization.hasTokens) {\n            const brackets = this.brackets.getSingleLanguageBracketTokens(this.textModel.getLanguageId());\n            const tokenizer = new FastTokenizer(this.textModel.getValue(), brackets);\n            this.initialAstWithoutTokens = parseDocument(tokenizer, [], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n        else if (textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            // Skip the initial ast, as there is no flickering.\n            // Directly create the tree with token information.\n            this.initialAstWithoutTokens = undefined;\n            this.astWithTokens = this.parseDocumentFromTextBuffer([], undefined, false);\n        }\n        else {\n            // We missed some token changes already, so we cannot use the fast tokenizer + delta increments\n            this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer([], undefined, true);\n            this.astWithTokens = this.initialAstWithoutTokens;\n        }\n    }\n    //#region TextModel events\n    handleDidChangeBackgroundTokenizationState() {\n        if (this.textModel.tokenization.backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n            const wasUndefined = this.initialAstWithoutTokens === undefined;\n            // Clear the initial tree as we can use the tree with token information now.\n            this.initialAstWithoutTokens = undefined;\n            if (!wasUndefined) {\n                this.didChangeEmitter.fire();\n            }\n        }\n    }\n    handleDidChangeTokens({ ranges }) {\n        const edits = ranges.map(r => new TextEditInfo(toLength(r.fromLineNumber - 1, 0), toLength(r.toLineNumber, 0), toLength(r.toLineNumber - r.fromLineNumber + 1, 0)));\n        this.handleEdits(edits, true);\n        if (!this.initialAstWithoutTokens) {\n            this.didChangeEmitter.fire();\n        }\n    }\n    handleContentChanged(change) {\n        const edits = TextEditInfo.fromModelContentChanges(change.changes);\n        this.handleEdits(edits, false);\n    }\n    handleEdits(edits, tokenChange) {\n        // Lazily queue the edits and only apply them when the tree is accessed.\n        const result = combineTextEditInfos(this.queuedTextEdits, edits);\n        this.queuedTextEdits = result;\n        if (this.initialAstWithoutTokens && !tokenChange) {\n            this.queuedTextEditsForInitialAstWithoutTokens = combineTextEditInfos(this.queuedTextEditsForInitialAstWithoutTokens, edits);\n        }\n    }\n    //#endregion\n    flushQueue() {\n        if (this.queuedTextEdits.length > 0) {\n            this.astWithTokens = this.parseDocumentFromTextBuffer(this.queuedTextEdits, this.astWithTokens, false);\n            this.queuedTextEdits = [];\n        }\n        if (this.queuedTextEditsForInitialAstWithoutTokens.length > 0) {\n            if (this.initialAstWithoutTokens) {\n                this.initialAstWithoutTokens = this.parseDocumentFromTextBuffer(this.queuedTextEditsForInitialAstWithoutTokens, this.initialAstWithoutTokens, false);\n            }\n            this.queuedTextEditsForInitialAstWithoutTokens = [];\n        }\n    }\n    /**\n     * @pure (only if isPure = true)\n    */\n    parseDocumentFromTextBuffer(edits, previousAst, immutable) {\n        // Is much faster if `isPure = false`.\n        const isPure = false;\n        const previousAstClone = isPure ? previousAst?.deepClone() : previousAst;\n        const tokenizer = new TextBufferTokenizer(this.textModel, this.brackets);\n        const result = parseDocument(tokenizer, edits, previousAstClone, immutable);\n        return result;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets) {\n        this.flushQueue();\n        const startOffset = toLength(range.startLineNumber - 1, range.startColumn - 1);\n        const endOffset = toLength(range.endLineNumber - 1, range.endColumn - 1);\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            collectBrackets(node, lengthZero, node.length, startOffset, endOffset, cb, 0, 0, new Map(), onlyColorizedBrackets);\n        });\n    }\n    getBracketPairsInRange(range, includeMinIndentation) {\n        this.flushQueue();\n        const startLength = positionToLength(range.getStartPosition());\n        const endLength = positionToLength(range.getEndPosition());\n        return new CallbackIterable(cb => {\n            const node = this.initialAstWithoutTokens || this.astWithTokens;\n            const context = new CollectBracketPairsContext(cb, includeMinIndentation, this.textModel);\n            collectBracketPairs(node, lengthZero, node.length, startLength, endLength, context, 0, new Map());\n        });\n    }\n    getFirstBracketAfter(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketAfter(node, lengthZero, node.length, positionToLength(position));\n    }\n    getFirstBracketBefore(position) {\n        this.flushQueue();\n        const node = this.initialAstWithoutTokens || this.astWithTokens;\n        return getFirstBracketBefore(node, lengthZero, node.length, positionToLength(position));\n    }\n}\nfunction getFirstBracketBefore(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        const lengths = [];\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            lengths.push({ nodeOffsetStart, nodeOffsetEnd });\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        for (let i = lengths.length - 1; i >= 0; i--) {\n            const { nodeOffsetStart, nodeOffsetEnd } = lengths[i];\n            if (lengthLessThan(nodeOffsetStart, position)) {\n                const result = getFirstBracketBefore(node.children[i], nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction getFirstBracketAfter(node, nodeOffsetStart, nodeOffsetEnd, position) {\n    if (node.kind === 4 /* AstNodeKind.List */ || node.kind === 2 /* AstNodeKind.Pair */) {\n        for (const child of node.children) {\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThan(position, nodeOffsetEnd)) {\n                const result = getFirstBracketAfter(child, nodeOffsetStart, nodeOffsetEnd, position);\n                if (result) {\n                    return result;\n                }\n            }\n            nodeOffsetStart = nodeOffsetEnd;\n        }\n        return null;\n    }\n    else if (node.kind === 3 /* AstNodeKind.UnexpectedClosingBracket */) {\n        return null;\n    }\n    else if (node.kind === 1 /* AstNodeKind.Bracket */) {\n        const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n        return {\n            bracketInfo: node.bracketInfo,\n            range\n        };\n    }\n    return null;\n}\nfunction collectBrackets(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, nestingLevelOfEqualBracketType, levelPerBracketType, onlyColorizedBrackets, parentPairIsIncomplete = false) {\n    if (level > 200) {\n        return true;\n    }\n    whileLoop: while (true) {\n        switch (node.kind) {\n            case 4 /* AstNodeKind.List */: {\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd) {\n                            // No child after this child in the requested window, don't recurse\n                            node = child;\n                            continue whileLoop;\n                        }\n                        const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, level, 0, levelPerBracketType, onlyColorizedBrackets);\n                        if (!shouldContinue) {\n                            return false;\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                return true;\n            }\n            case 2 /* AstNodeKind.Pair */: {\n                const colorize = !onlyColorizedBrackets || !node.closingBracket || node.closingBracket.bracketInfo.closesColorized(node.openingBracket.bracketInfo);\n                let levelPerBracket = 0;\n                if (levelPerBracketType) {\n                    let existing = levelPerBracketType.get(node.openingBracket.text);\n                    if (existing === undefined) {\n                        existing = 0;\n                    }\n                    levelPerBracket = existing;\n                    if (colorize) {\n                        existing++;\n                        levelPerBracketType.set(node.openingBracket.text, existing);\n                    }\n                }\n                const childCount = node.childrenLength;\n                for (let i = 0; i < childCount; i++) {\n                    const child = node.getChild(i);\n                    if (!child) {\n                        continue;\n                    }\n                    nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n                    if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                        lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                        const childEndsAfterEnd = lengthGreaterThanEqual(nodeOffsetEnd, endOffset);\n                        if (childEndsAfterEnd && child.kind !== 1 /* AstNodeKind.Bracket */) {\n                            // No child after this child in the requested window, don't recurse\n                            // Don't do this for brackets because of unclosed/unopened brackets\n                            node = child;\n                            if (colorize) {\n                                level++;\n                                nestingLevelOfEqualBracketType = levelPerBracket + 1;\n                            }\n                            else {\n                                nestingLevelOfEqualBracketType = levelPerBracket;\n                            }\n                            continue whileLoop;\n                        }\n                        if (colorize || child.kind !== 1 /* AstNodeKind.Bracket */ || !node.closingBracket) {\n                            const shouldContinue = collectBrackets(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, push, colorize ? level + 1 : level, colorize ? levelPerBracket + 1 : levelPerBracket, levelPerBracketType, onlyColorizedBrackets, !node.closingBracket);\n                            if (!shouldContinue) {\n                                return false;\n                            }\n                        }\n                    }\n                    nodeOffsetStart = nodeOffsetEnd;\n                }\n                levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n                return true;\n            }\n            case 3 /* AstNodeKind.UnexpectedClosingBracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, 0, true));\n            }\n            case 1 /* AstNodeKind.Bracket */: {\n                const range = lengthsToRange(nodeOffsetStart, nodeOffsetEnd);\n                return push(new BracketInfo(range, level - 1, nestingLevelOfEqualBracketType - 1, parentPairIsIncomplete));\n            }\n            case 0 /* AstNodeKind.Text */:\n                return true;\n        }\n    }\n}\nclass CollectBracketPairsContext {\n    constructor(push, includeMinIndentation, textModel) {\n        this.push = push;\n        this.includeMinIndentation = includeMinIndentation;\n        this.textModel = textModel;\n    }\n}\nfunction collectBracketPairs(node, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level, levelPerBracketType) {\n    if (level > 200) {\n        return true;\n    }\n    let shouldContinue = true;\n    if (node.kind === 2 /* AstNodeKind.Pair */) {\n        let levelPerBracket = 0;\n        if (levelPerBracketType) {\n            let existing = levelPerBracketType.get(node.openingBracket.text);\n            if (existing === undefined) {\n                existing = 0;\n            }\n            levelPerBracket = existing;\n            existing++;\n            levelPerBracketType.set(node.openingBracket.text, existing);\n        }\n        const openingBracketEnd = lengthAdd(nodeOffsetStart, node.openingBracket.length);\n        let minIndentation = -1;\n        if (context.includeMinIndentation) {\n            minIndentation = node.computeMinIndentation(nodeOffsetStart, context.textModel);\n        }\n        shouldContinue = context.push(new BracketPairWithMinIndentationInfo(lengthsToRange(nodeOffsetStart, nodeOffsetEnd), lengthsToRange(nodeOffsetStart, openingBracketEnd), node.closingBracket\n            ? lengthsToRange(lengthAdd(openingBracketEnd, node.child?.length || lengthZero), nodeOffsetEnd)\n            : undefined, level, levelPerBracket, node, minIndentation));\n        nodeOffsetStart = openingBracketEnd;\n        if (shouldContinue && node.child) {\n            const child = node.child;\n            nodeOffsetEnd = lengthAdd(nodeOffsetStart, child.length);\n            if (lengthLessThanEqual(nodeOffsetStart, endOffset) &&\n                lengthGreaterThanEqual(nodeOffsetEnd, startOffset)) {\n                shouldContinue = collectBracketPairs(child, nodeOffsetStart, nodeOffsetEnd, startOffset, endOffset, context, level + 1, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n        levelPerBracketType?.set(node.openingBracket.text, levelPerBracket);\n    }\n    else {\n        let curOffset = nodeOffsetStart;\n        for (const child of node.children) {\n            const childOffset = curOffset;\n            curOffset = lengthAdd(curOffset, child.length);\n            if (lengthLessThanEqual(childOffset, endOffset) &&\n                lengthLessThanEqual(startOffset, curOffset)) {\n                shouldContinue = collectBracketPairs(child, childOffset, curOffset, startOffset, endOffset, context, level, levelPerBracketType);\n                if (!shouldContinue) {\n                    return false;\n                }\n            }\n        }\n    }\n    return shouldContinue;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CallbackIterable, compareBy } from '../../../../base/common/arrays.js';\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable, DisposableStore, MutableDisposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { ignoreBracketsInToken } from '../../languages/supports.js';\nimport { BracketsUtils } from '../../languages/supports/richEditBrackets.js';\nimport { BracketPairsTree } from './bracketPairsTree/bracketPairsTree.js';\nexport class BracketPairsTextModelPart extends Disposable {\n    get canBuildAST() {\n        const maxSupportedDocumentLength = /* max lines */ 50_000 * /* average column count */ 100;\n        return this.textModel.getValueLength() <= maxSupportedDocumentLength;\n    }\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n        this.bracketPairsTree = this._register(new MutableDisposable());\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.bracketsRequested = false;\n    }\n    //#region TextModel events\n    handleLanguageConfigurationServiceChange(e) {\n        if (!e.languageId || this.bracketPairsTree.value?.object.didLanguageChange(e.languageId)) {\n            this.bracketPairsTree.clear();\n            this.updateBracketPairsTree();\n        }\n    }\n    handleDidChangeOptions(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeLanguage(e) {\n        this.bracketPairsTree.clear();\n        this.updateBracketPairsTree();\n    }\n    handleDidChangeContent(change) {\n        this.bracketPairsTree.value?.object.handleContentChanged(change);\n    }\n    handleDidChangeBackgroundTokenizationState() {\n        this.bracketPairsTree.value?.object.handleDidChangeBackgroundTokenizationState();\n    }\n    handleDidChangeTokens(e) {\n        this.bracketPairsTree.value?.object.handleDidChangeTokens(e);\n    }\n    //#endregion\n    updateBracketPairsTree() {\n        if (this.bracketsRequested && this.canBuildAST) {\n            if (!this.bracketPairsTree.value) {\n                const store = new DisposableStore();\n                this.bracketPairsTree.value = createDisposableRef(store.add(new BracketPairsTree(this.textModel, (languageId) => {\n                    return this.languageConfigurationService.getLanguageConfiguration(languageId);\n                })), store);\n                store.add(this.bracketPairsTree.value.object.onDidChange(e => this.onDidChangeEmitter.fire(e)));\n                this.onDidChangeEmitter.fire();\n            }\n        }\n        else {\n            if (this.bracketPairsTree.value) {\n                this.bracketPairsTree.clear();\n                // Important: Don't call fire if there was no change!\n                this.onDidChangeEmitter.fire();\n            }\n        }\n    }\n    /**\n     * Returns all bracket pairs that intersect the given range.\n     * The result is sorted by the start position.\n    */\n    getBracketPairsInRange(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, false) || CallbackIterable.empty;\n    }\n    getBracketPairsInRangeWithMinIndentation(range) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketPairsInRange(range, true) || CallbackIterable.empty;\n    }\n    getBracketsInRange(range, onlyColorizedBrackets = false) {\n        this.bracketsRequested = true;\n        this.updateBracketPairsTree();\n        return this.bracketPairsTree.value?.object.getBracketsInRange(range, onlyColorizedBrackets) || CallbackIterable.empty;\n    }\n    findMatchingBracketUp(_bracket, _position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        const languageId = this.textModel.getLanguageIdAtPosition(position.lineNumber, position.column);\n        if (this.canBuildAST) {\n            const closingBracketInfo = this.languageConfigurationService\n                .getLanguageConfiguration(languageId)\n                .bracketsNew.getClosingBracketInfo(_bracket);\n            if (!closingBracketInfo) {\n                return null;\n            }\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(_position, _position)).findLast((b) => closingBracketInfo.closes(b.openingBracketInfo));\n            if (bracketPair) {\n                return bracketPair.openingBracketRange;\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const bracket = _bracket.toLowerCase();\n            const bracketsSupport = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n            if (!bracketsSupport) {\n                return null;\n            }\n            const data = bracketsSupport.textIsBracket[bracket];\n            if (!data) {\n                return null;\n            }\n            return stripBracketSearchCanceled(this._findMatchingBracketUp(data, position, createTimeBasedContinueBracketSearchPredicate(maxDuration)));\n        }\n    }\n    matchBracket(position, maxDuration) {\n        if (this.canBuildAST) {\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).filter((item) => item.closingBracketRange !== undefined &&\n                (item.openingBracketRange.containsPosition(position) ||\n                    item.closingBracketRange.containsPosition(position))).findLastMaxBy(compareBy((item) => item.openingBracketRange.containsPosition(position)\n                ? item.openingBracketRange\n                : item.closingBracketRange, Range.compareRangesUsingStarts));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        else {\n            // Fallback to old bracket matching code:\n            const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n            return this._matchBracket(this.textModel.validatePosition(position), continueSearchPredicate);\n        }\n    }\n    _establishBracketSearchOffsets(position, lineTokens, modeBrackets, tokenIndex) {\n        const tokenCount = lineTokens.getCount();\n        const currentLanguageId = lineTokens.getLanguageId(tokenIndex);\n        // limit search to not go before `maxBracketLength`\n        let searchStartOffset = Math.max(0, position.column - 1 - modeBrackets.maxBracketLength);\n        for (let i = tokenIndex - 1; i >= 0; i--) {\n            const tokenEndOffset = lineTokens.getEndOffset(i);\n            if (tokenEndOffset <= searchStartOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchStartOffset = tokenEndOffset;\n                break;\n            }\n        }\n        // limit search to not go after `maxBracketLength`\n        let searchEndOffset = Math.min(lineTokens.getLineContent().length, position.column - 1 + modeBrackets.maxBracketLength);\n        for (let i = tokenIndex + 1; i < tokenCount; i++) {\n            const tokenStartOffset = lineTokens.getStartOffset(i);\n            if (tokenStartOffset >= searchEndOffset) {\n                break;\n            }\n            if (ignoreBracketsInToken(lineTokens.getStandardTokenType(i)) || lineTokens.getLanguageId(i) !== currentLanguageId) {\n                searchEndOffset = tokenStartOffset;\n                break;\n            }\n        }\n        return { searchStartOffset, searchEndOffset };\n    }\n    _matchBracket(position, continueSearchPredicate) {\n        const lineNumber = position.lineNumber;\n        const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n        const lineText = this.textModel.getLineContent(lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        if (tokenIndex < 0) {\n            return null;\n        }\n        const currentModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).brackets;\n        // check that the token is not to be ignored\n        if (currentModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex))) {\n            let { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, currentModeBrackets, tokenIndex);\n            // it might be the case that [currentTokenStart -> currentTokenEnd] contains multiple brackets\n            // `bestResult` will contain the most right-side result\n            let bestResult = null;\n            while (true) {\n                const foundBracket = BracketsUtils.findNextBracketInRange(currentModeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!foundBracket) {\n                    // there are no more brackets in this text\n                    break;\n                }\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, currentModeBrackets.textIsBracket[foundBracketText], currentModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        bestResult = r;\n                    }\n                }\n                searchStartOffset = foundBracket.endColumn - 1;\n            }\n            if (bestResult) {\n                return bestResult;\n            }\n        }\n        // If position is in between two tokens, try also looking in the previous token\n        if (tokenIndex > 0 && lineTokens.getStartOffset(tokenIndex) === position.column - 1) {\n            const prevTokenIndex = tokenIndex - 1;\n            const prevModeBrackets = this.languageConfigurationService.getLanguageConfiguration(lineTokens.getLanguageId(prevTokenIndex)).brackets;\n            // check that previous token is not to be ignored\n            if (prevModeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(prevTokenIndex))) {\n                const { searchStartOffset, searchEndOffset } = this._establishBracketSearchOffsets(position, lineTokens, prevModeBrackets, prevTokenIndex);\n                const foundBracket = BracketsUtils.findPrevBracketInRange(prevModeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                // check that we didn't hit a bracket too far away from position\n                if (foundBracket && foundBracket.startColumn <= position.column && position.column <= foundBracket.endColumn) {\n                    const foundBracketText = lineText.substring(foundBracket.startColumn - 1, foundBracket.endColumn - 1).toLowerCase();\n                    const r = this._matchFoundBracket(foundBracket, prevModeBrackets.textIsBracket[foundBracketText], prevModeBrackets.textIsOpenBracket[foundBracketText], continueSearchPredicate);\n                    if (r) {\n                        if (r instanceof BracketSearchCanceled) {\n                            return null;\n                        }\n                        return r;\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    _matchFoundBracket(foundBracket, data, isOpen, continueSearchPredicate) {\n        if (!data) {\n            return null;\n        }\n        const matched = (isOpen\n            ? this._findMatchingBracketDown(data, foundBracket.getEndPosition(), continueSearchPredicate)\n            : this._findMatchingBracketUp(data, foundBracket.getStartPosition(), continueSearchPredicate));\n        if (!matched) {\n            return null;\n        }\n        if (matched instanceof BracketSearchCanceled) {\n            return matched;\n        }\n        return [foundBracket, matched];\n    }\n    _findMatchingBracketUp(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketUp: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const reversedBracketRegex = bracket.reversedRegex;\n        let count = -1;\n        let totalCallCount = 0;\n        const searchPrevMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchEndOffset = r.startColumn - 1;\n            }\n            return null;\n        };\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchPrevMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    _findMatchingBracketDown(bracket, position, continueSearchPredicate) {\n        // console.log('_findMatchingBracketDown: ', 'bracket: ', JSON.stringify(bracket), 'startPosition: ', String(position));\n        const languageId = bracket.languageId;\n        const bracketRegex = bracket.forwardRegex;\n        let count = 1;\n        let totalCallCount = 0;\n        const searchNextMatchingBracketInRange = (lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(bracketRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                if (bracket.isOpen(hitText)) {\n                    count++;\n                }\n                else if (bracket.isClose(hitText)) {\n                    count--;\n                }\n                if (count === 0) {\n                    return r;\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        const lineCount = this.textModel.getLineCount();\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const searchInToken = (lineTokens.getLanguageId(tokenIndex) === languageId && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return r;\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchNextMatchingBracketInRange(lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return r;\n                }\n            }\n        }\n        return null;\n    }\n    findPrevBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketBefore(position) || null;\n        }\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber >= 1; lineNumber--) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = tokenCount - 1;\n            let searchStartOffset = lineText.length;\n            let searchEndOffset = lineText.length;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex >= 0; tokenIndex--) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && bracketConfig && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchStartOffset\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findPrevBracketInRange(modeBrackets.reversedRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findNextBracket(_position) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            this.bracketsRequested = true;\n            this.updateBracketPairsTree();\n            return this.bracketPairsTree.value?.object.getFirstBracketAfter(position) || null;\n        }\n        const lineCount = this.textModel.getLineCount();\n        let languageId = null;\n        let modeBrackets = null;\n        let bracketConfig = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    bracketConfig = this.languageConfigurationService.getLanguageConfiguration(languageId).bracketsNew;\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return this._toFoundBracket(bracketConfig, r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (bracketConfig && modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return this._toFoundBracket(bracketConfig, r);\n                }\n            }\n        }\n        return null;\n    }\n    findEnclosingBrackets(_position, maxDuration) {\n        const position = this.textModel.validatePosition(_position);\n        if (this.canBuildAST) {\n            const range = Range.fromPositions(position);\n            const bracketPair = this.getBracketPairsInRange(Range.fromPositions(position, position)).findLast((item) => item.closingBracketRange !== undefined && item.range.strictContainsRange(range));\n            if (bracketPair) {\n                return [bracketPair.openingBracketRange, bracketPair.closingBracketRange];\n            }\n            return null;\n        }\n        const continueSearchPredicate = createTimeBasedContinueBracketSearchPredicate(maxDuration);\n        const lineCount = this.textModel.getLineCount();\n        const savedCounts = new Map();\n        let counts = [];\n        const resetCounts = (languageId, modeBrackets) => {\n            if (!savedCounts.has(languageId)) {\n                const tmp = [];\n                for (let i = 0, len = modeBrackets ? modeBrackets.brackets.length : 0; i < len; i++) {\n                    tmp[i] = 0;\n                }\n                savedCounts.set(languageId, tmp);\n            }\n            counts = savedCounts.get(languageId);\n        };\n        let totalCallCount = 0;\n        const searchInRange = (modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset) => {\n            while (true) {\n                if (continueSearchPredicate && (++totalCallCount) % 100 === 0 && !continueSearchPredicate()) {\n                    return BracketSearchCanceled.INSTANCE;\n                }\n                const r = BracketsUtils.findNextBracketInRange(modeBrackets.forwardRegex, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (!r) {\n                    break;\n                }\n                const hitText = lineText.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n                const bracket = modeBrackets.textIsBracket[hitText];\n                if (bracket) {\n                    if (bracket.isOpen(hitText)) {\n                        counts[bracket.index]++;\n                    }\n                    else if (bracket.isClose(hitText)) {\n                        counts[bracket.index]--;\n                    }\n                    if (counts[bracket.index] === -1) {\n                        return this._matchFoundBracket(r, bracket, false, continueSearchPredicate);\n                    }\n                }\n                searchStartOffset = r.endColumn - 1;\n            }\n            return null;\n        };\n        let languageId = null;\n        let modeBrackets = null;\n        for (let lineNumber = position.lineNumber; lineNumber <= lineCount; lineNumber++) {\n            const lineTokens = this.textModel.tokenization.getLineTokens(lineNumber);\n            const tokenCount = lineTokens.getCount();\n            const lineText = this.textModel.getLineContent(lineNumber);\n            let tokenIndex = 0;\n            let searchStartOffset = 0;\n            let searchEndOffset = 0;\n            if (lineNumber === position.lineNumber) {\n                tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n                searchStartOffset = position.column - 1;\n                searchEndOffset = position.column - 1;\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n            }\n            let prevSearchInToken = true;\n            for (; tokenIndex < tokenCount; tokenIndex++) {\n                const tokenLanguageId = lineTokens.getLanguageId(tokenIndex);\n                if (languageId !== tokenLanguageId) {\n                    // language id change!\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                        prevSearchInToken = false;\n                    }\n                    languageId = tokenLanguageId;\n                    modeBrackets = this.languageConfigurationService.getLanguageConfiguration(languageId).brackets;\n                    resetCounts(languageId, modeBrackets);\n                }\n                const searchInToken = (!!modeBrackets && !ignoreBracketsInToken(lineTokens.getStandardTokenType(tokenIndex)));\n                if (searchInToken) {\n                    // this token should be searched\n                    if (prevSearchInToken) {\n                        // the previous token should be searched, simply extend searchEndOffset\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                    else {\n                        // the previous token should not be searched\n                        searchStartOffset = lineTokens.getStartOffset(tokenIndex);\n                        searchEndOffset = lineTokens.getEndOffset(tokenIndex);\n                    }\n                }\n                else {\n                    // this token should not be searched\n                    if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                        const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                        if (r) {\n                            return stripBracketSearchCanceled(r);\n                        }\n                    }\n                }\n                prevSearchInToken = searchInToken;\n            }\n            if (modeBrackets && prevSearchInToken && searchStartOffset !== searchEndOffset) {\n                const r = searchInRange(modeBrackets, lineNumber, lineText, searchStartOffset, searchEndOffset);\n                if (r) {\n                    return stripBracketSearchCanceled(r);\n                }\n            }\n        }\n        return null;\n    }\n    _toFoundBracket(bracketConfig, r) {\n        if (!r) {\n            return null;\n        }\n        let text = this.textModel.getValueInRange(r);\n        text = text.toLowerCase();\n        const bracketInfo = bracketConfig.getBracketInfo(text);\n        if (!bracketInfo) {\n            return null;\n        }\n        return {\n            range: r,\n            bracketInfo\n        };\n    }\n}\nfunction createDisposableRef(object, disposable) {\n    return {\n        object,\n        dispose: () => disposable?.dispose(),\n    };\n}\nfunction createTimeBasedContinueBracketSearchPredicate(maxDuration) {\n    if (typeof maxDuration === 'undefined') {\n        return () => true;\n    }\n    else {\n        const startTime = Date.now();\n        return () => {\n            return (Date.now() - startTime <= maxDuration);\n        };\n    }\n}\nclass BracketSearchCanceled {\n    static { this.INSTANCE = new BracketSearchCanceled(); }\n    constructor() {\n        this._searchCanceledBrand = undefined;\n    }\n}\nfunction stripBracketSearchCanceled(result) {\n    if (result instanceof BracketSearchCanceled) {\n        return null;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nimport { Range } from '../../core/range.js';\nimport { editorBracketHighlightingForeground1, editorBracketHighlightingForeground2, editorBracketHighlightingForeground3, editorBracketHighlightingForeground4, editorBracketHighlightingForeground5, editorBracketHighlightingForeground6, editorBracketHighlightingUnexpectedBracketForeground } from '../../core/editorColorRegistry.js';\nimport { registerThemingParticipant } from '../../../../platform/theme/common/themeService.js';\nexport class ColorizedBracketPairsDecorationProvider extends Disposable {\n    constructor(textModel) {\n        super();\n        this.textModel = textModel;\n        this.colorProvider = new ColorProvider();\n        this.onDidChangeEmitter = new Emitter();\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.colorizationOptions = textModel.getOptions().bracketPairColorizationOptions;\n        this._register(textModel.bracketPairs.onDidChange(e => {\n            this.onDidChangeEmitter.fire();\n        }));\n    }\n    //#region TextModel events\n    handleDidChangeOptions(e) {\n        this.colorizationOptions = this.textModel.getOptions().bracketPairColorizationOptions;\n    }\n    //#endregion\n    getDecorationsInRange(range, ownerId, filterOutValidation, onlyMinimapDecorations) {\n        if (onlyMinimapDecorations) {\n            // Bracket pair colorization decorations are not rendered in the minimap\n            return [];\n        }\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        const result = this.textModel.bracketPairs.getBracketsInRange(range, true).map(bracket => ({\n            id: `bracket${bracket.range.toString()}-${bracket.nestingLevel}`,\n            options: {\n                description: 'BracketPairColorization',\n                inlineClassName: this.colorProvider.getInlineClassName(bracket, this.colorizationOptions.independentColorPoolPerBracketType),\n            },\n            ownerId: 0,\n            range: bracket.range,\n        })).toArray();\n        return result;\n    }\n    getAllDecorations(ownerId, filterOutValidation) {\n        if (ownerId === undefined) {\n            return [];\n        }\n        if (!this.colorizationOptions.enabled) {\n            return [];\n        }\n        return this.getDecorationsInRange(new Range(1, 1, this.textModel.getLineCount(), 1), ownerId, filterOutValidation);\n    }\n}\nclass ColorProvider {\n    constructor() {\n        this.unexpectedClosingBracketClassName = 'unexpected-closing-bracket';\n    }\n    getInlineClassName(bracket, independentColorPoolPerBracketType) {\n        if (bracket.isInvalid) {\n            return this.unexpectedClosingBracketClassName;\n        }\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? bracket.nestingLevelOfEqualBracketType : bracket.nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-highlighting-${level % 30}`;\n    }\n}\nregisterThemingParticipant((theme, collector) => {\n    const colors = [\n        editorBracketHighlightingForeground1,\n        editorBracketHighlightingForeground2,\n        editorBracketHighlightingForeground3,\n        editorBracketHighlightingForeground4,\n        editorBracketHighlightingForeground5,\n        editorBracketHighlightingForeground6\n    ];\n    const colorProvider = new ColorProvider();\n    collector.addRule(`.monaco-editor .${colorProvider.unexpectedClosingBracketClassName} { color: ${theme.getColor(editorBracketHighlightingUnexpectedBracketForeground)}; }`);\n    const colorValues = colors\n        .map(c => theme.getColor(c))\n        .filter((c) => !!c)\n        .filter(c => !c.isTransparent());\n    for (let level = 0; level < 30; level++) {\n        const color = colorValues[level % colorValues.length];\n        collector.addRule(`.monaco-editor .${colorProvider.getInlineClassNameOfLevel(level)} { color: ${color}; }`);\n    }\n});\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nclass SpacesDiffResult {\n    constructor() {\n        this.spacesDiff = 0;\n        this.looksLikeAlignment = false;\n    }\n}\n/**\n * Compute the diff in spaces between two line's indentation.\n */\nfunction spacesDiff(a, aLength, b, bLength, result) {\n    result.spacesDiff = 0;\n    result.looksLikeAlignment = false;\n    // This can go both ways (e.g.):\n    //  - a: \"\\t\"\n    //  - b: \"\\t    \"\n    //  => This should count 1 tab and 4 spaces\n    let i;\n    for (i = 0; i < aLength && i < bLength; i++) {\n        const aCharCode = a.charCodeAt(i);\n        const bCharCode = b.charCodeAt(i);\n        if (aCharCode !== bCharCode) {\n            break;\n        }\n    }\n    let aSpacesCnt = 0, aTabsCount = 0;\n    for (let j = i; j < aLength; j++) {\n        const aCharCode = a.charCodeAt(j);\n        if (aCharCode === 32 /* CharCode.Space */) {\n            aSpacesCnt++;\n        }\n        else {\n            aTabsCount++;\n        }\n    }\n    let bSpacesCnt = 0, bTabsCount = 0;\n    for (let j = i; j < bLength; j++) {\n        const bCharCode = b.charCodeAt(j);\n        if (bCharCode === 32 /* CharCode.Space */) {\n            bSpacesCnt++;\n        }\n        else {\n            bTabsCount++;\n        }\n    }\n    if (aSpacesCnt > 0 && aTabsCount > 0) {\n        return;\n    }\n    if (bSpacesCnt > 0 && bTabsCount > 0) {\n        return;\n    }\n    const tabsDiff = Math.abs(aTabsCount - bTabsCount);\n    const spacesDiff = Math.abs(aSpacesCnt - bSpacesCnt);\n    if (tabsDiff === 0) {\n        // check if the indentation difference might be caused by alignment reasons\n        // sometime folks like to align their code, but this should not be used as a hint\n        result.spacesDiff = spacesDiff;\n        if (spacesDiff > 0 && 0 <= bSpacesCnt - 1 && bSpacesCnt - 1 < a.length && bSpacesCnt < b.length) {\n            if (b.charCodeAt(bSpacesCnt) !== 32 /* CharCode.Space */ && a.charCodeAt(bSpacesCnt - 1) === 32 /* CharCode.Space */) {\n                if (a.charCodeAt(a.length - 1) === 44 /* CharCode.Comma */) {\n                    // This looks like an alignment desire: e.g.\n                    // const a = b + c,\n                    //       d = b - c;\n                    result.looksLikeAlignment = true;\n                }\n            }\n        }\n        return;\n    }\n    if (spacesDiff % tabsDiff === 0) {\n        result.spacesDiff = spacesDiff / tabsDiff;\n        return;\n    }\n}\nexport function guessIndentation(source, defaultTabSize, defaultInsertSpaces) {\n    // Look at most at the first 10k lines\n    const linesCount = Math.min(source.getLineCount(), 10000);\n    let linesIndentedWithTabsCount = 0; // number of lines that contain at least one tab in indentation\n    let linesIndentedWithSpacesCount = 0; // number of lines that contain only spaces in indentation\n    let previousLineText = ''; // content of latest line that contained non-whitespace chars\n    let previousLineIndentation = 0; // index at which latest line contained the first non-whitespace char\n    const ALLOWED_TAB_SIZE_GUESSES = [2, 4, 6, 8, 3, 5, 7]; // prefer even guesses for `tabSize`, limit to [2, 8].\n    const MAX_ALLOWED_TAB_SIZE_GUESS = 8; // max(ALLOWED_TAB_SIZE_GUESSES) = 8\n    const spacesDiffCount = [0, 0, 0, 0, 0, 0, 0, 0, 0]; // `tabSize` scores\n    const tmp = new SpacesDiffResult();\n    for (let lineNumber = 1; lineNumber <= linesCount; lineNumber++) {\n        const currentLineLength = source.getLineLength(lineNumber);\n        const currentLineText = source.getLineContent(lineNumber);\n        // if the text buffer is chunk based, so long lines are cons-string, v8 will flattern the string when we check charCode.\n        // checking charCode on chunks directly is cheaper.\n        const useCurrentLineText = (currentLineLength <= 65536);\n        let currentLineHasContent = false; // does `currentLineText` contain non-whitespace chars\n        let currentLineIndentation = 0; // index at which `currentLineText` contains the first non-whitespace char\n        let currentLineSpacesCount = 0; // count of spaces found in `currentLineText` indentation\n        let currentLineTabsCount = 0; // count of tabs found in `currentLineText` indentation\n        for (let j = 0, lenJ = currentLineLength; j < lenJ; j++) {\n            const charCode = (useCurrentLineText ? currentLineText.charCodeAt(j) : source.getLineCharCode(lineNumber, j));\n            if (charCode === 9 /* CharCode.Tab */) {\n                currentLineTabsCount++;\n            }\n            else if (charCode === 32 /* CharCode.Space */) {\n                currentLineSpacesCount++;\n            }\n            else {\n                // Hit non whitespace character on this line\n                currentLineHasContent = true;\n                currentLineIndentation = j;\n                break;\n            }\n        }\n        // Ignore empty or only whitespace lines\n        if (!currentLineHasContent) {\n            continue;\n        }\n        if (currentLineTabsCount > 0) {\n            linesIndentedWithTabsCount++;\n        }\n        else if (currentLineSpacesCount > 1) {\n            linesIndentedWithSpacesCount++;\n        }\n        spacesDiff(previousLineText, previousLineIndentation, currentLineText, currentLineIndentation, tmp);\n        if (tmp.looksLikeAlignment) {\n            // if defaultInsertSpaces === true && the spaces count == tabSize, we may want to count it as valid indentation\n            //\n            // - item1\n            //   - item2\n            //\n            // otherwise skip this line entirely\n            //\n            // const a = 1,\n            //       b = 2;\n            if (!(defaultInsertSpaces && defaultTabSize === tmp.spacesDiff)) {\n                continue;\n            }\n        }\n        const currentSpacesDiff = tmp.spacesDiff;\n        if (currentSpacesDiff <= MAX_ALLOWED_TAB_SIZE_GUESS) {\n            spacesDiffCount[currentSpacesDiff]++;\n        }\n        previousLineText = currentLineText;\n        previousLineIndentation = currentLineIndentation;\n    }\n    let insertSpaces = defaultInsertSpaces;\n    if (linesIndentedWithTabsCount !== linesIndentedWithSpacesCount) {\n        insertSpaces = (linesIndentedWithTabsCount < linesIndentedWithSpacesCount);\n    }\n    let tabSize = defaultTabSize;\n    // Guess tabSize only if inserting spaces...\n    if (insertSpaces) {\n        let tabSizeScore = (insertSpaces ? 0 : 0.1 * linesCount);\n        // console.log(\"score threshold: \" + tabSizeScore);\n        ALLOWED_TAB_SIZE_GUESSES.forEach((possibleTabSize) => {\n            const possibleTabSizeScore = spacesDiffCount[possibleTabSize];\n            if (possibleTabSizeScore > tabSizeScore) {\n                tabSizeScore = possibleTabSizeScore;\n                tabSize = possibleTabSize;\n            }\n        });\n        // Let a tabSize of 2 win even if it is not the maximum\n        // (only in case 4 was guessed)\n        if (tabSize === 4 && spacesDiffCount[4] > 0 && spacesDiffCount[2] > 0 && spacesDiffCount[2] >= spacesDiffCount[4] / 2) {\n            tabSize = 2;\n        }\n    }\n    // console.log('--------------------------');\n    // console.log('linesIndentedWithTabsCount: ' + linesIndentedWithTabsCount + ', linesIndentedWithSpacesCount: ' + linesIndentedWithSpacesCount);\n    // console.log('spacesDiffCount: ' + spacesDiffCount);\n    // console.log('tabSize: ' + tabSize + ', tabSizeScore: ' + tabSizeScore);\n    return {\n        insertSpaces: insertSpaces,\n        tabSize: tabSize\n    };\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function getNodeColor(node) {\n    return ((node.metadata & 1 /* Constants.ColorMask */) >>> 0 /* Constants.ColorOffset */);\n}\nfunction setNodeColor(node, color) {\n    node.metadata = ((node.metadata & 254 /* Constants.ColorMaskInverse */) | (color << 0 /* Constants.ColorOffset */));\n}\nfunction getNodeIsVisited(node) {\n    return ((node.metadata & 2 /* Constants.IsVisitedMask */) >>> 1 /* Constants.IsVisitedOffset */) === 1;\n}\nfunction setNodeIsVisited(node, value) {\n    node.metadata = ((node.metadata & 253 /* Constants.IsVisitedMaskInverse */) | ((value ? 1 : 0) << 1 /* Constants.IsVisitedOffset */));\n}\nfunction getNodeIsForValidation(node) {\n    return ((node.metadata & 4 /* Constants.IsForValidationMask */) >>> 2 /* Constants.IsForValidationOffset */) === 1;\n}\nfunction setNodeIsForValidation(node, value) {\n    node.metadata = ((node.metadata & 251 /* Constants.IsForValidationMaskInverse */) | ((value ? 1 : 0) << 2 /* Constants.IsForValidationOffset */));\n}\nfunction getNodeIsInGlyphMargin(node) {\n    return ((node.metadata & 64 /* Constants.IsMarginMask */) >>> 6 /* Constants.IsMarginOffset */) === 1;\n}\nfunction setNodeIsInGlyphMargin(node, value) {\n    node.metadata = ((node.metadata & 191 /* Constants.IsMarginMaskInverse */) | ((value ? 1 : 0) << 6 /* Constants.IsMarginOffset */));\n}\nfunction getNodeStickiness(node) {\n    return ((node.metadata & 24 /* Constants.StickinessMask */) >>> 3 /* Constants.StickinessOffset */);\n}\nfunction _setNodeStickiness(node, stickiness) {\n    node.metadata = ((node.metadata & 231 /* Constants.StickinessMaskInverse */) | (stickiness << 3 /* Constants.StickinessOffset */));\n}\nfunction getCollapseOnReplaceEdit(node) {\n    return ((node.metadata & 32 /* Constants.CollapseOnReplaceEditMask */) >>> 5 /* Constants.CollapseOnReplaceEditOffset */) === 1;\n}\nfunction setCollapseOnReplaceEdit(node, value) {\n    node.metadata = ((node.metadata & 223 /* Constants.CollapseOnReplaceEditMaskInverse */) | ((value ? 1 : 0) << 5 /* Constants.CollapseOnReplaceEditOffset */));\n}\nexport class IntervalNode {\n    constructor(id, start, end) {\n        this.metadata = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n        setNodeColor(this, 1 /* NodeColor.Red */);\n        this.start = start;\n        this.end = end;\n        // FORCE_OVERFLOWING_TEST: this.delta = start;\n        this.delta = 0;\n        this.maxEnd = end;\n        this.id = id;\n        this.ownerId = 0;\n        this.options = null;\n        setNodeIsForValidation(this, false);\n        setNodeIsInGlyphMargin(this, false);\n        _setNodeStickiness(this, 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */);\n        setCollapseOnReplaceEdit(this, false);\n        this.cachedVersionId = 0;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = null;\n        setNodeIsVisited(this, false);\n    }\n    reset(versionId, start, end, range) {\n        this.start = start;\n        this.end = end;\n        this.maxEnd = end;\n        this.cachedVersionId = versionId;\n        this.cachedAbsoluteStart = start;\n        this.cachedAbsoluteEnd = end;\n        this.range = range;\n    }\n    setOptions(options) {\n        this.options = options;\n        const className = this.options.className;\n        setNodeIsForValidation(this, (className === \"squiggly-error\" /* ClassName.EditorErrorDecoration */\n            || className === \"squiggly-warning\" /* ClassName.EditorWarningDecoration */\n            || className === \"squiggly-info\" /* ClassName.EditorInfoDecoration */));\n        setNodeIsInGlyphMargin(this, this.options.glyphMarginClassName !== null);\n        _setNodeStickiness(this, this.options.stickiness);\n        setCollapseOnReplaceEdit(this, this.options.collapseOnReplaceEdit);\n    }\n    setCachedOffsets(absoluteStart, absoluteEnd, cachedVersionId) {\n        if (this.cachedVersionId !== cachedVersionId) {\n            this.range = null;\n        }\n        this.cachedVersionId = cachedVersionId;\n        this.cachedAbsoluteStart = absoluteStart;\n        this.cachedAbsoluteEnd = absoluteEnd;\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new IntervalNode(null, 0, 0);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nsetNodeColor(SENTINEL, 0 /* NodeColor.Black */);\nexport class IntervalTree {\n    constructor() {\n        this.root = SENTINEL;\n        this.requestNormalizeDelta = false;\n    }\n    intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return intervalSearch(this, start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        if (this.root === SENTINEL) {\n            return [];\n        }\n        return search(this, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesFromOwner(ownerId) {\n        return collectNodesFromOwner(this, ownerId);\n    }\n    /**\n     * Will not set `cachedAbsoluteStart` nor `cachedAbsoluteEnd` on the returned nodes!\n     */\n    collectNodesPostOrder() {\n        return collectNodesPostOrder(this);\n    }\n    insert(node) {\n        rbTreeInsert(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    delete(node) {\n        rbTreeDelete(this, node);\n        this._normalizeDeltaIfNecessary();\n    }\n    resolveNode(node, cachedVersionId) {\n        const initialNode = node;\n        let delta = 0;\n        while (node !== this.root) {\n            if (node === node.parent.right) {\n                delta += node.parent.delta;\n            }\n            node = node.parent;\n        }\n        const nodeStart = initialNode.start + delta;\n        const nodeEnd = initialNode.end + delta;\n        initialNode.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        // Our strategy is to remove all directly impacted nodes, and then add them back to the tree.\n        // (1) collect all nodes that are intersecting this edit as nodes of interest\n        const nodesOfInterest = searchForEditing(this, offset, offset + length);\n        // (2) remove all nodes that are intersecting this edit\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            rbTreeDelete(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n        // (3) edit all tree nodes except the nodes of interest\n        noOverlapReplace(this, offset, offset + length, textLength);\n        this._normalizeDeltaIfNecessary();\n        // (4) edit the nodes of interest and insert them back in the tree\n        for (let i = 0, len = nodesOfInterest.length; i < len; i++) {\n            const node = nodesOfInterest[i];\n            node.start = node.cachedAbsoluteStart;\n            node.end = node.cachedAbsoluteEnd;\n            nodeAcceptEdit(node, offset, (offset + length), textLength, forceMoveMarkers);\n            node.maxEnd = node.end;\n            rbTreeInsert(this, node);\n        }\n        this._normalizeDeltaIfNecessary();\n    }\n    _normalizeDeltaIfNecessary() {\n        if (!this.requestNormalizeDelta) {\n            return;\n        }\n        this.requestNormalizeDelta = false;\n        normalizeDelta(this);\n    }\n}\n//#region Delta Normalization\nfunction normalizeDelta(T) {\n    let node = T.root;\n    let delta = 0;\n    while (node !== SENTINEL) {\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        node.start = delta + node.start;\n        node.end = delta + node.end;\n        node.delta = 0;\n        recomputeMaxEnd(node);\n        setNodeIsVisited(node, true);\n        // going up from this node\n        setNodeIsVisited(node.left, false);\n        setNodeIsVisited(node.right, false);\n        if (node === node.parent.right) {\n            delta -= node.parent.delta;\n        }\n        node = node.parent;\n    }\n    setNodeIsVisited(T.root, false);\n}\nfunction adjustMarkerBeforeColumn(markerOffset, markerStickToPreviousCharacter, checkOffset, moveSemantics) {\n    if (markerOffset < checkOffset) {\n        return true;\n    }\n    if (markerOffset > checkOffset) {\n        return false;\n    }\n    if (moveSemantics === 1 /* MarkerMoveSemantics.ForceMove */) {\n        return false;\n    }\n    if (moveSemantics === 2 /* MarkerMoveSemantics.ForceStay */) {\n        return true;\n    }\n    return markerStickToPreviousCharacter;\n}\n/**\n * This is a lot more complicated than strictly necessary to maintain the same behaviour\n * as when decorations were implemented using two markers.\n */\nexport function nodeAcceptEdit(node, start, end, textLength, forceMoveMarkers) {\n    const nodeStickiness = getNodeStickiness(node);\n    const startStickToPreviousCharacter = (nodeStickiness === 0 /* TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const endStickToPreviousCharacter = (nodeStickiness === 1 /* TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */\n        || nodeStickiness === 2 /* TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */);\n    const deletingCnt = (end - start);\n    const insertingCnt = textLength;\n    const commonLength = Math.min(deletingCnt, insertingCnt);\n    const nodeStart = node.start;\n    let startDone = false;\n    const nodeEnd = node.end;\n    let endDone = false;\n    if (start <= nodeStart && nodeEnd <= end && getCollapseOnReplaceEdit(node)) {\n        // This edit encompasses the entire decoration range\n        // and the decoration has asked to become collapsed\n        node.start = start;\n        startDone = true;\n        node.end = start;\n        endDone = true;\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : (deletingCnt > 0 ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    if (commonLength > 0 && !forceMoveMarkers) {\n        const moveSemantics = (deletingCnt > insertingCnt ? 2 /* MarkerMoveSemantics.ForceStay */ : 0 /* MarkerMoveSemantics.MarkerDefined */);\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, start + commonLength, moveSemantics)) {\n            endDone = true;\n        }\n    }\n    {\n        const moveSemantics = forceMoveMarkers ? 1 /* MarkerMoveSemantics.ForceMove */ : 0 /* MarkerMoveSemantics.MarkerDefined */;\n        if (!startDone && adjustMarkerBeforeColumn(nodeStart, startStickToPreviousCharacter, end, moveSemantics)) {\n            node.start = start + insertingCnt;\n            startDone = true;\n        }\n        if (!endDone && adjustMarkerBeforeColumn(nodeEnd, endStickToPreviousCharacter, end, moveSemantics)) {\n            node.end = start + insertingCnt;\n            endDone = true;\n        }\n    }\n    // Finish\n    const deltaColumn = (insertingCnt - deletingCnt);\n    if (!startDone) {\n        node.start = Math.max(0, nodeStart + deltaColumn);\n    }\n    if (!endDone) {\n        node.end = Math.max(0, nodeEnd + deltaColumn);\n    }\n    if (node.start > node.end) {\n        node.end = node.start;\n    }\n}\nfunction searchForEditing(T, start, end) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= start) {\n            node.setCachedOffsets(nodeStart, nodeEnd, 0);\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction noOverlapReplace(T, start, end, textLength) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    const editDelta = (textLength - (end - start));\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            recomputeMaxEnd(node);\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < start) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > end) {\n            node.start += editDelta;\n            node.end += editDelta;\n            node.delta += editDelta;\n            if (node.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || node.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n                T.requestNormalizeDelta = true;\n            }\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n}\n//#endregion\n//#region Searching\nfunction collectNodesFromOwner(T, ownerId) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        if (node.ownerId === ownerId) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction collectNodesPostOrder(T) {\n    let node = T.root;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            node = node.right;\n            continue;\n        }\n        // handle current node\n        result[resultLen++] = node;\n        setNodeIsVisited(node, true);\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction search(T, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    let node = T.root;\n    let delta = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (node.left !== SENTINEL && !getNodeIsVisited(node.left)) {\n            // go left\n            node = node.left;\n            continue;\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        nodeEnd = delta + node.end;\n        node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n        let include = true;\n        if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n            include = false;\n        }\n        if (filterOutValidation && getNodeIsForValidation(node)) {\n            include = false;\n        }\n        if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n            include = false;\n        }\n        if (include) {\n            result[resultLen++] = node;\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\nfunction intervalSearch(T, intervalStart, intervalEnd, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n    // https://en.wikipedia.org/wiki/Interval_tree#Augmented_tree\n    // Now, it is known that two intervals A and B overlap only when both\n    // A.low <= B.high and A.high >= B.low. When searching the trees for\n    // nodes overlapping with a given interval, you can immediately skip:\n    //  a) all nodes to the right of nodes whose low value is past the end of the given interval.\n    //  b) all nodes that have their maximum 'high' value below the start of the given interval.\n    let node = T.root;\n    let delta = 0;\n    let nodeMaxEnd = 0;\n    let nodeStart = 0;\n    let nodeEnd = 0;\n    const result = [];\n    let resultLen = 0;\n    while (node !== SENTINEL) {\n        if (getNodeIsVisited(node)) {\n            // going up from this node\n            setNodeIsVisited(node.left, false);\n            setNodeIsVisited(node.right, false);\n            if (node === node.parent.right) {\n                delta -= node.parent.delta;\n            }\n            node = node.parent;\n            continue;\n        }\n        if (!getNodeIsVisited(node.left)) {\n            // first time seeing this node\n            nodeMaxEnd = delta + node.maxEnd;\n            if (nodeMaxEnd < intervalStart) {\n                // cover case b) from above\n                // there is no need to search this node or its children\n                setNodeIsVisited(node, true);\n                continue;\n            }\n            if (node.left !== SENTINEL) {\n                // go left\n                node = node.left;\n                continue;\n            }\n        }\n        // handle current node\n        nodeStart = delta + node.start;\n        if (nodeStart > intervalEnd) {\n            // cover case a) from above\n            // there is no need to search this node or its right subtree\n            setNodeIsVisited(node, true);\n            continue;\n        }\n        nodeEnd = delta + node.end;\n        if (nodeEnd >= intervalStart) {\n            // There is overlap\n            node.setCachedOffsets(nodeStart, nodeEnd, cachedVersionId);\n            let include = true;\n            if (filterOwnerId && node.ownerId && node.ownerId !== filterOwnerId) {\n                include = false;\n            }\n            if (filterOutValidation && getNodeIsForValidation(node)) {\n                include = false;\n            }\n            if (onlyMarginDecorations && !getNodeIsInGlyphMargin(node)) {\n                include = false;\n            }\n            if (include) {\n                result[resultLen++] = node;\n            }\n        }\n        setNodeIsVisited(node, true);\n        if (node.right !== SENTINEL && !getNodeIsVisited(node.right)) {\n            // go right\n            delta += node.delta;\n            node = node.right;\n            continue;\n        }\n    }\n    setNodeIsVisited(T.root, false);\n    return result;\n}\n//#endregion\n//#region Insertion\nfunction rbTreeInsert(T, newNode) {\n    if (T.root === SENTINEL) {\n        newNode.parent = SENTINEL;\n        newNode.left = SENTINEL;\n        newNode.right = SENTINEL;\n        setNodeColor(newNode, 0 /* NodeColor.Black */);\n        T.root = newNode;\n        return T.root;\n    }\n    treeInsert(T, newNode);\n    recomputeMaxEndWalkToRoot(newNode.parent);\n    // repair tree\n    let x = newNode;\n    while (x !== T.root && getNodeColor(x.parent) === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (getNodeColor(y) === 1 /* NodeColor.Red */) {\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(y, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(T, x);\n                }\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent.parent);\n            }\n        }\n    }\n    setNodeColor(T.root, 0 /* NodeColor.Black */);\n    return newNode;\n}\nfunction treeInsert(T, z) {\n    let delta = 0;\n    let x = T.root;\n    const zAbsoluteStart = z.start;\n    const zAbsoluteEnd = z.end;\n    while (true) {\n        const cmp = intervalCompare(zAbsoluteStart, zAbsoluteEnd, x.start + delta, x.end + delta);\n        if (cmp < 0) {\n            // this node should be inserted to the left\n            // => it is not affected by the node's delta\n            if (x.left === SENTINEL) {\n                z.start -= delta;\n                z.end -= delta;\n                z.maxEnd -= delta;\n                x.left = z;\n                break;\n            }\n            else {\n                x = x.left;\n            }\n        }\n        else {\n            // this node should be inserted to the right\n            // => it is not affected by the node's delta\n            if (x.right === SENTINEL) {\n                z.start -= (delta + x.delta);\n                z.end -= (delta + x.delta);\n                z.maxEnd -= (delta + x.delta);\n                x.right = z;\n                break;\n            }\n            else {\n                delta += x.delta;\n                x = x.right;\n            }\n        }\n    }\n    z.parent = x;\n    z.left = SENTINEL;\n    z.right = SENTINEL;\n    setNodeColor(z, 1 /* NodeColor.Red */);\n}\n//#endregion\n//#region Deletion\nfunction rbTreeDelete(T, z) {\n    let x;\n    let y;\n    // RB-DELETE except we don't swap z and y in case c)\n    // i.e. we always delete what's pointed at by z.\n    if (z.left === SENTINEL) {\n        x = z.right;\n        y = z;\n        // x's delta is no longer influenced by z's delta\n        x.delta += z.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        x.start += z.delta;\n        x.end += z.delta;\n    }\n    else if (z.right === SENTINEL) {\n        x = z.left;\n        y = z;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n        // y's delta is no longer influenced by z's delta,\n        // but we don't want to walk the entire right-hand-side subtree of x.\n        // we therefore maintain z's delta in y, and adjust only x\n        x.start += y.delta;\n        x.end += y.delta;\n        x.delta += y.delta;\n        if (x.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || x.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n        y.start += z.delta;\n        y.end += z.delta;\n        y.delta = z.delta;\n        if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n            T.requestNormalizeDelta = true;\n        }\n    }\n    if (y === T.root) {\n        T.root = x;\n        setNodeColor(x, 0 /* NodeColor.Black */);\n        z.detach();\n        resetSentinel();\n        recomputeMaxEnd(x);\n        T.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (getNodeColor(y) === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        setNodeColor(y, getNodeColor(z));\n        if (z === T.root) {\n            T.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n    }\n    z.detach();\n    if (yWasRed) {\n        recomputeMaxEndWalkToRoot(x.parent);\n        if (y !== z) {\n            recomputeMaxEndWalkToRoot(y);\n            recomputeMaxEndWalkToRoot(y.parent);\n        }\n        resetSentinel();\n        return;\n    }\n    recomputeMaxEndWalkToRoot(x);\n    recomputeMaxEndWalkToRoot(x.parent);\n    if (y !== z) {\n        recomputeMaxEndWalkToRoot(y);\n        recomputeMaxEndWalkToRoot(y.parent);\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== T.root && getNodeColor(x) === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                leftRotate(T, x.parent);\n                w = x.parent.right;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.left, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    rightRotate(T, w);\n                    w = x.parent.right;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.right, 0 /* NodeColor.Black */);\n                leftRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (getNodeColor(w) === 1 /* NodeColor.Red */) {\n                setNodeColor(w, 0 /* NodeColor.Black */);\n                setNodeColor(x.parent, 1 /* NodeColor.Red */);\n                rightRotate(T, x.parent);\n                w = x.parent.left;\n            }\n            if (getNodeColor(w.left) === 0 /* NodeColor.Black */ && getNodeColor(w.right) === 0 /* NodeColor.Black */) {\n                setNodeColor(w, 1 /* NodeColor.Red */);\n                x = x.parent;\n            }\n            else {\n                if (getNodeColor(w.left) === 0 /* NodeColor.Black */) {\n                    setNodeColor(w.right, 0 /* NodeColor.Black */);\n                    setNodeColor(w, 1 /* NodeColor.Red */);\n                    leftRotate(T, w);\n                    w = x.parent.left;\n                }\n                setNodeColor(w, getNodeColor(x.parent));\n                setNodeColor(x.parent, 0 /* NodeColor.Black */);\n                setNodeColor(w.left, 0 /* NodeColor.Black */);\n                rightRotate(T, x.parent);\n                x = T.root;\n            }\n        }\n    }\n    setNodeColor(x, 0 /* NodeColor.Black */);\n    resetSentinel();\n}\nfunction leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n    SENTINEL.delta = 0; // optional\n    SENTINEL.start = 0; // optional\n    SENTINEL.end = 0; // optional\n}\n//#endregion\n//#region Rotations\nfunction leftRotate(T, x) {\n    const y = x.right; // set y.\n    y.delta += x.delta; // y's delta is no longer influenced by x's delta\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start += x.delta;\n    y.end += x.delta;\n    x.right = y.left; // turn y's left subtree into x's right subtree.\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent; // link x's parent to y.\n    if (x.parent === SENTINEL) {\n        T.root = y;\n    }\n    else if (x === x.parent.left) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x; // put x on y's left.\n    x.parent = y;\n    recomputeMaxEnd(x);\n    recomputeMaxEnd(y);\n}\nfunction rightRotate(T, y) {\n    const x = y.left;\n    y.delta -= x.delta;\n    if (y.delta < -1073741824 /* Constants.MIN_SAFE_DELTA */ || y.delta > 1073741824 /* Constants.MAX_SAFE_DELTA */) {\n        T.requestNormalizeDelta = true;\n    }\n    y.start -= x.delta;\n    y.end -= x.delta;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    if (y.parent === SENTINEL) {\n        T.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n    recomputeMaxEnd(y);\n    recomputeMaxEnd(x);\n}\n//#endregion\n//#region max end computation\nfunction computeMaxEnd(node) {\n    let maxEnd = node.end;\n    if (node.left !== SENTINEL) {\n        const leftMaxEnd = node.left.maxEnd;\n        if (leftMaxEnd > maxEnd) {\n            maxEnd = leftMaxEnd;\n        }\n    }\n    if (node.right !== SENTINEL) {\n        const rightMaxEnd = node.right.maxEnd + node.delta;\n        if (rightMaxEnd > maxEnd) {\n            maxEnd = rightMaxEnd;\n        }\n    }\n    return maxEnd;\n}\nexport function recomputeMaxEnd(node) {\n    node.maxEnd = computeMaxEnd(node);\n}\nfunction recomputeMaxEndWalkToRoot(node) {\n    while (node !== SENTINEL) {\n        const maxEnd = computeMaxEnd(node);\n        if (node.maxEnd === maxEnd) {\n            // no need to go further\n            return;\n        }\n        node.maxEnd = maxEnd;\n        node = node.parent;\n    }\n}\n//#endregion\n//#region utils\nexport function intervalCompare(aStart, aEnd, bStart, bEnd) {\n    if (aStart === bStart) {\n        return aEnd - bEnd;\n    }\n    return aStart - bStart;\n}\n//#endregion\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class TreeNode {\n    constructor(piece, color) {\n        this.piece = piece;\n        this.color = color;\n        this.size_left = 0;\n        this.lf_left = 0;\n        this.parent = this;\n        this.left = this;\n        this.right = this;\n    }\n    next() {\n        if (this.right !== SENTINEL) {\n            return leftest(this.right);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.left === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    prev() {\n        if (this.left !== SENTINEL) {\n            return righttest(this.left);\n        }\n        let node = this;\n        while (node.parent !== SENTINEL) {\n            if (node.parent.right === node) {\n                break;\n            }\n            node = node.parent;\n        }\n        if (node.parent === SENTINEL) {\n            return SENTINEL;\n        }\n        else {\n            return node.parent;\n        }\n    }\n    detach() {\n        this.parent = null;\n        this.left = null;\n        this.right = null;\n    }\n}\nexport const SENTINEL = new TreeNode(null, 0 /* NodeColor.Black */);\nSENTINEL.parent = SENTINEL;\nSENTINEL.left = SENTINEL;\nSENTINEL.right = SENTINEL;\nSENTINEL.color = 0 /* NodeColor.Black */;\nexport function leftest(node) {\n    while (node.left !== SENTINEL) {\n        node = node.left;\n    }\n    return node;\n}\nexport function righttest(node) {\n    while (node.right !== SENTINEL) {\n        node = node.right;\n    }\n    return node;\n}\nfunction calculateSize(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.size_left + node.piece.length + calculateSize(node.right);\n}\nfunction calculateLF(node) {\n    if (node === SENTINEL) {\n        return 0;\n    }\n    return node.lf_left + node.piece.lineFeedCnt + calculateLF(node.right);\n}\nfunction resetSentinel() {\n    SENTINEL.parent = SENTINEL;\n}\nexport function leftRotate(tree, x) {\n    const y = x.right;\n    // fix size_left\n    y.size_left += x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left += x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    x.right = y.left;\n    if (y.left !== SENTINEL) {\n        y.left.parent = x;\n    }\n    y.parent = x.parent;\n    if (x.parent === SENTINEL) {\n        tree.root = y;\n    }\n    else if (x.parent.left === x) {\n        x.parent.left = y;\n    }\n    else {\n        x.parent.right = y;\n    }\n    y.left = x;\n    x.parent = y;\n}\nexport function rightRotate(tree, y) {\n    const x = y.left;\n    y.left = x.right;\n    if (x.right !== SENTINEL) {\n        x.right.parent = y;\n    }\n    x.parent = y.parent;\n    // fix size_left\n    y.size_left -= x.size_left + (x.piece ? x.piece.length : 0);\n    y.lf_left -= x.lf_left + (x.piece ? x.piece.lineFeedCnt : 0);\n    if (y.parent === SENTINEL) {\n        tree.root = x;\n    }\n    else if (y === y.parent.right) {\n        y.parent.right = x;\n    }\n    else {\n        y.parent.left = x;\n    }\n    x.right = y;\n    y.parent = x;\n}\nexport function rbDelete(tree, z) {\n    let x;\n    let y;\n    if (z.left === SENTINEL) {\n        y = z;\n        x = y.right;\n    }\n    else if (z.right === SENTINEL) {\n        y = z;\n        x = y.left;\n    }\n    else {\n        y = leftest(z.right);\n        x = y.right;\n    }\n    if (y === tree.root) {\n        tree.root = x;\n        // if x is null, we are removing the only node\n        x.color = 0 /* NodeColor.Black */;\n        z.detach();\n        resetSentinel();\n        tree.root.parent = SENTINEL;\n        return;\n    }\n    const yWasRed = (y.color === 1 /* NodeColor.Red */);\n    if (y === y.parent.left) {\n        y.parent.left = x;\n    }\n    else {\n        y.parent.right = x;\n    }\n    if (y === z) {\n        x.parent = y.parent;\n        recomputeTreeMetadata(tree, x);\n    }\n    else {\n        if (y.parent === z) {\n            x.parent = y;\n        }\n        else {\n            x.parent = y.parent;\n        }\n        // as we make changes to x's hierarchy, update size_left of subtree first\n        recomputeTreeMetadata(tree, x);\n        y.left = z.left;\n        y.right = z.right;\n        y.parent = z.parent;\n        y.color = z.color;\n        if (z === tree.root) {\n            tree.root = y;\n        }\n        else {\n            if (z === z.parent.left) {\n                z.parent.left = y;\n            }\n            else {\n                z.parent.right = y;\n            }\n        }\n        if (y.left !== SENTINEL) {\n            y.left.parent = y;\n        }\n        if (y.right !== SENTINEL) {\n            y.right.parent = y;\n        }\n        // update metadata\n        // we replace z with y, so in this sub tree, the length change is z.item.length\n        y.size_left = z.size_left;\n        y.lf_left = z.lf_left;\n        recomputeTreeMetadata(tree, y);\n    }\n    z.detach();\n    if (x.parent.left === x) {\n        const newSizeLeft = calculateSize(x);\n        const newLFLeft = calculateLF(x);\n        if (newSizeLeft !== x.parent.size_left || newLFLeft !== x.parent.lf_left) {\n            const delta = newSizeLeft - x.parent.size_left;\n            const lf_delta = newLFLeft - x.parent.lf_left;\n            x.parent.size_left = newSizeLeft;\n            x.parent.lf_left = newLFLeft;\n            updateTreeMetadata(tree, x.parent, delta, lf_delta);\n        }\n    }\n    recomputeTreeMetadata(tree, x.parent);\n    if (yWasRed) {\n        resetSentinel();\n        return;\n    }\n    // RB-DELETE-FIXUP\n    let w;\n    while (x !== tree.root && x.color === 0 /* NodeColor.Black */) {\n        if (x === x.parent.left) {\n            w = x.parent.right;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent);\n                w = x.parent.right;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.right.color === 0 /* NodeColor.Black */) {\n                    w.left.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    rightRotate(tree, w);\n                    w = x.parent.right;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.right.color = 0 /* NodeColor.Black */;\n                leftRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n        else {\n            w = x.parent.left;\n            if (w.color === 1 /* NodeColor.Red */) {\n                w.color = 0 /* NodeColor.Black */;\n                x.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent);\n                w = x.parent.left;\n            }\n            if (w.left.color === 0 /* NodeColor.Black */ && w.right.color === 0 /* NodeColor.Black */) {\n                w.color = 1 /* NodeColor.Red */;\n                x = x.parent;\n            }\n            else {\n                if (w.left.color === 0 /* NodeColor.Black */) {\n                    w.right.color = 0 /* NodeColor.Black */;\n                    w.color = 1 /* NodeColor.Red */;\n                    leftRotate(tree, w);\n                    w = x.parent.left;\n                }\n                w.color = x.parent.color;\n                x.parent.color = 0 /* NodeColor.Black */;\n                w.left.color = 0 /* NodeColor.Black */;\n                rightRotate(tree, x.parent);\n                x = tree.root;\n            }\n        }\n    }\n    x.color = 0 /* NodeColor.Black */;\n    resetSentinel();\n}\nexport function fixInsert(tree, x) {\n    recomputeTreeMetadata(tree, x);\n    while (x !== tree.root && x.parent.color === 1 /* NodeColor.Red */) {\n        if (x.parent === x.parent.parent.left) {\n            const y = x.parent.parent.right;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.right) {\n                    x = x.parent;\n                    leftRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                rightRotate(tree, x.parent.parent);\n            }\n        }\n        else {\n            const y = x.parent.parent.left;\n            if (y.color === 1 /* NodeColor.Red */) {\n                x.parent.color = 0 /* NodeColor.Black */;\n                y.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                x = x.parent.parent;\n            }\n            else {\n                if (x === x.parent.left) {\n                    x = x.parent;\n                    rightRotate(tree, x);\n                }\n                x.parent.color = 0 /* NodeColor.Black */;\n                x.parent.parent.color = 1 /* NodeColor.Red */;\n                leftRotate(tree, x.parent.parent);\n            }\n        }\n    }\n    tree.root.color = 0 /* NodeColor.Black */;\n}\nexport function updateTreeMetadata(tree, x, delta, lineFeedCntDelta) {\n    // node length change or line feed count change\n    while (x !== tree.root && x !== SENTINEL) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lineFeedCntDelta;\n        }\n        x = x.parent;\n    }\n}\nexport function recomputeTreeMetadata(tree, x) {\n    let delta = 0;\n    let lf_delta = 0;\n    if (x === tree.root) {\n        return;\n    }\n    // go upwards till the node whose left subtree is changed.\n    while (x !== tree.root && x === x.parent.right) {\n        x = x.parent;\n    }\n    if (x === tree.root) {\n        // well, it means we add a node to the end (inorder)\n        return;\n    }\n    // x is the node whose right subtree is changed.\n    x = x.parent;\n    delta = calculateSize(x.left) - x.size_left;\n    lf_delta = calculateLF(x.left) - x.lf_left;\n    x.size_left += delta;\n    x.lf_left += lf_delta;\n    // go upwards till root. O(logN)\n    while (x !== tree.root && (delta !== 0 || lf_delta !== 0)) {\n        if (x.parent.left === x) {\n            x.parent.size_left += delta;\n            x.parent.lf_left += lf_delta;\n        }\n        x = x.parent;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Position } from '../../core/position.js';\nimport { Range } from '../../core/range.js';\nimport { FindMatch } from '../../model.js';\nimport { SENTINEL, TreeNode, fixInsert, leftest, rbDelete, righttest, updateTreeMetadata } from './rbTreeBase.js';\nimport { Searcher, createFindMatch, isValidMatch } from '../textModelSearch.js';\n// const lfRegex = new RegExp(/\\r\\n|\\r|\\n/g);\nconst AverageBufferSize = 65535;\nfunction createUintArray(arr) {\n    let r;\n    if (arr[arr.length - 1] < 65536) {\n        r = new Uint16Array(arr.length);\n    }\n    else {\n        r = new Uint32Array(arr.length);\n    }\n    r.set(arr, 0);\n    return r;\n}\nclass LineStarts {\n    constructor(lineStarts, cr, lf, crlf, isBasicASCII) {\n        this.lineStarts = lineStarts;\n        this.cr = cr;\n        this.lf = lf;\n        this.crlf = crlf;\n        this.isBasicASCII = isBasicASCII;\n    }\n}\nexport function createLineStartsFast(str, readonly = true) {\n    const r = [0];\n    let rLength = 1;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            r[rLength++] = i + 1;\n        }\n    }\n    if (readonly) {\n        return createUintArray(r);\n    }\n    else {\n        return r;\n    }\n}\nexport function createLineStarts(r, str) {\n    r.length = 0;\n    r[0] = 0;\n    let rLength = 1;\n    let cr = 0, lf = 0, crlf = 0;\n    let isBasicASCII = true;\n    for (let i = 0, len = str.length; i < len; i++) {\n        const chr = str.charCodeAt(i);\n        if (chr === 13 /* CharCode.CarriageReturn */) {\n            if (i + 1 < len && str.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */) {\n                // \\r\\n... case\n                crlf++;\n                r[rLength++] = i + 2;\n                i++; // skip \\n\n            }\n            else {\n                cr++;\n                // \\r... case\n                r[rLength++] = i + 1;\n            }\n        }\n        else if (chr === 10 /* CharCode.LineFeed */) {\n            lf++;\n            r[rLength++] = i + 1;\n        }\n        else {\n            if (isBasicASCII) {\n                if (chr !== 9 /* CharCode.Tab */ && (chr < 32 || chr > 126)) {\n                    isBasicASCII = false;\n                }\n            }\n        }\n    }\n    const result = new LineStarts(createUintArray(r), cr, lf, crlf, isBasicASCII);\n    r.length = 0;\n    return result;\n}\nexport class Piece {\n    constructor(bufferIndex, start, end, lineFeedCnt, length) {\n        this.bufferIndex = bufferIndex;\n        this.start = start;\n        this.end = end;\n        this.lineFeedCnt = lineFeedCnt;\n        this.length = length;\n    }\n}\nexport class StringBuffer {\n    constructor(buffer, lineStarts) {\n        this.buffer = buffer;\n        this.lineStarts = lineStarts;\n    }\n}\n/**\n * Readonly snapshot for piece tree.\n * In a real multiple thread environment, to make snapshot reading always work correctly, we need to\n * 1. Make TreeNode.piece immutable, then reading and writing can run in parallel.\n * 2. TreeNode/Buffers normalization should not happen during snapshot reading.\n */\nclass PieceTreeSnapshot {\n    constructor(tree, BOM) {\n        this._pieces = [];\n        this._tree = tree;\n        this._BOM = BOM;\n        this._index = 0;\n        if (tree.root !== SENTINEL) {\n            tree.iterate(tree.root, node => {\n                if (node !== SENTINEL) {\n                    this._pieces.push(node.piece);\n                }\n                return true;\n            });\n        }\n    }\n    read() {\n        if (this._pieces.length === 0) {\n            if (this._index === 0) {\n                this._index++;\n                return this._BOM;\n            }\n            else {\n                return null;\n            }\n        }\n        if (this._index > this._pieces.length - 1) {\n            return null;\n        }\n        if (this._index === 0) {\n            return this._BOM + this._tree.getPieceContent(this._pieces[this._index++]);\n        }\n        return this._tree.getPieceContent(this._pieces[this._index++]);\n    }\n}\nclass PieceTreeSearchCache {\n    constructor(limit) {\n        this._limit = limit;\n        this._cache = [];\n    }\n    get(offset) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartOffset <= offset && nodePos.nodeStartOffset + nodePos.node.piece.length >= offset) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    get2(lineNumber) {\n        for (let i = this._cache.length - 1; i >= 0; i--) {\n            const nodePos = this._cache[i];\n            if (nodePos.nodeStartLineNumber && nodePos.nodeStartLineNumber < lineNumber && nodePos.nodeStartLineNumber + nodePos.node.piece.lineFeedCnt >= lineNumber) {\n                return nodePos;\n            }\n        }\n        return null;\n    }\n    set(nodePosition) {\n        if (this._cache.length >= this._limit) {\n            this._cache.shift();\n        }\n        this._cache.push(nodePosition);\n    }\n    validate(offset) {\n        let hasInvalidVal = false;\n        const tmp = this._cache;\n        for (let i = 0; i < tmp.length; i++) {\n            const nodePos = tmp[i];\n            if (nodePos.node.parent === null || nodePos.nodeStartOffset >= offset) {\n                tmp[i] = null;\n                hasInvalidVal = true;\n                continue;\n            }\n        }\n        if (hasInvalidVal) {\n            const newArr = [];\n            for (const entry of tmp) {\n                if (entry !== null) {\n                    newArr.push(entry);\n                }\n            }\n            this._cache = newArr;\n        }\n    }\n}\nexport class PieceTreeBase {\n    constructor(chunks, eol, eolNormalized) {\n        this.create(chunks, eol, eolNormalized);\n    }\n    create(chunks, eol, eolNormalized) {\n        this._buffers = [\n            new StringBuffer('', [0])\n        ];\n        this._lastChangeBufferPos = { line: 0, column: 0 };\n        this.root = SENTINEL;\n        this._lineCnt = 1;\n        this._length = 0;\n        this._EOL = eol;\n        this._EOLLength = eol.length;\n        this._EOLNormalized = eolNormalized;\n        let lastNode = null;\n        for (let i = 0, len = chunks.length; i < len; i++) {\n            if (chunks[i].buffer.length > 0) {\n                if (!chunks[i].lineStarts) {\n                    chunks[i].lineStarts = createLineStartsFast(chunks[i].buffer);\n                }\n                const piece = new Piece(i + 1, { line: 0, column: 0 }, { line: chunks[i].lineStarts.length - 1, column: chunks[i].buffer.length - chunks[i].lineStarts[chunks[i].lineStarts.length - 1] }, chunks[i].lineStarts.length - 1, chunks[i].buffer.length);\n                this._buffers.push(chunks[i]);\n                lastNode = this.rbInsertRight(lastNode, piece);\n            }\n        }\n        this._searchCache = new PieceTreeSearchCache(1);\n        this._lastVisitedLine = { lineNumber: 0, value: '' };\n        this.computeBufferMetadata();\n    }\n    normalizeEOL(eol) {\n        const averageBufferSize = AverageBufferSize;\n        const min = averageBufferSize - Math.floor(averageBufferSize / 3);\n        const max = min * 2;\n        let tempChunk = '';\n        let tempChunkLen = 0;\n        const chunks = [];\n        this.iterate(this.root, node => {\n            const str = this.getNodeContent(node);\n            const len = str.length;\n            if (tempChunkLen <= min || tempChunkLen + len < max) {\n                tempChunk += str;\n                tempChunkLen += len;\n                return true;\n            }\n            // flush anyways\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n            tempChunk = str;\n            tempChunkLen = len;\n            return true;\n        });\n        if (tempChunkLen > 0) {\n            const text = tempChunk.replace(/\\r\\n|\\r|\\n/g, eol);\n            chunks.push(new StringBuffer(text, createLineStartsFast(text)));\n        }\n        this.create(chunks, eol, true);\n    }\n    // #region Buffer API\n    getEOL() {\n        return this._EOL;\n    }\n    setEOL(newEOL) {\n        this._EOL = newEOL;\n        this._EOLLength = this._EOL.length;\n        this.normalizeEOL(newEOL);\n    }\n    createSnapshot(BOM) {\n        return new PieceTreeSnapshot(this, BOM);\n    }\n    getOffsetAt(lineNumber, column) {\n        let leftLen = 0; // inorder\n        let x = this.root;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left + 1 >= lineNumber) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt + 1 >= lineNumber) {\n                leftLen += x.size_left;\n                // lineNumber >= 2\n                const accumualtedValInCurrentIndex = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                return leftLen += accumualtedValInCurrentIndex + column - 1;\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                leftLen += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return leftLen;\n    }\n    getPositionAt(offset) {\n        offset = Math.floor(offset);\n        offset = Math.max(0, offset);\n        let x = this.root;\n        let lfCnt = 0;\n        const originalOffset = offset;\n        while (x !== SENTINEL) {\n            if (x.size_left !== 0 && x.size_left >= offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                const out = this.getIndexOf(x, offset - x.size_left);\n                lfCnt += x.lf_left + out.index;\n                if (out.index === 0) {\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                return new Position(lfCnt + 1, out.remainder + 1);\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                lfCnt += x.lf_left + x.piece.lineFeedCnt;\n                if (x.right === SENTINEL) {\n                    // last node\n                    const lineStartOffset = this.getOffsetAt(lfCnt + 1, 1);\n                    const column = originalOffset - offset - lineStartOffset;\n                    return new Position(lfCnt + 1, column + 1);\n                }\n                else {\n                    x = x.right;\n                }\n            }\n        }\n        return new Position(1, 1);\n    }\n    getValueInRange(range, eol) {\n        if (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn) {\n            return '';\n        }\n        const startPosition = this.nodeAt2(range.startLineNumber, range.startColumn);\n        const endPosition = this.nodeAt2(range.endLineNumber, range.endColumn);\n        const value = this.getValueInRange2(startPosition, endPosition);\n        if (eol) {\n            if (eol !== this._EOL || !this._EOLNormalized) {\n                return value.replace(/\\r\\n|\\r|\\n/g, eol);\n            }\n            if (eol === this.getEOL() && this._EOLNormalized) {\n                if (eol === '\\r\\n') {\n                }\n                return value;\n            }\n            return value.replace(/\\r\\n|\\r|\\n/g, eol);\n        }\n        return value;\n    }\n    getValueInRange2(startPosition, endPosition) {\n        if (startPosition.node === endPosition.node) {\n            const node = startPosition.node;\n            const buffer = this._buffers[node.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n            return buffer.substring(startOffset + startPosition.remainder, startOffset + endPosition.remainder);\n        }\n        let x = startPosition.node;\n        const buffer = this._buffers[x.piece.bufferIndex].buffer;\n        const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n        let ret = buffer.substring(startOffset + startPosition.remainder, startOffset + x.piece.length);\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (x === endPosition.node) {\n                ret += buffer.substring(startOffset, startOffset + endPosition.remainder);\n                break;\n            }\n            else {\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    getLinesContent() {\n        const lines = [];\n        let linesLength = 0;\n        let currentLine = '';\n        let danglingCR = false;\n        this.iterate(this.root, node => {\n            if (node === SENTINEL) {\n                return true;\n            }\n            const piece = node.piece;\n            let pieceLength = piece.length;\n            if (pieceLength === 0) {\n                return true;\n            }\n            const buffer = this._buffers[piece.bufferIndex].buffer;\n            const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n            const pieceStartLine = piece.start.line;\n            const pieceEndLine = piece.end.line;\n            let pieceStartOffset = lineStarts[pieceStartLine] + piece.start.column;\n            if (danglingCR) {\n                if (buffer.charCodeAt(pieceStartOffset) === 10 /* CharCode.LineFeed */) {\n                    // pretend the \\n was in the previous piece..\n                    pieceStartOffset++;\n                    pieceLength--;\n                }\n                lines[linesLength++] = currentLine;\n                currentLine = '';\n                danglingCR = false;\n                if (pieceLength === 0) {\n                    return true;\n                }\n            }\n            if (pieceStartLine === pieceEndLine) {\n                // this piece has no new lines\n                if (!this._EOLNormalized && buffer.charCodeAt(pieceStartOffset + pieceLength - 1) === 13 /* CharCode.CarriageReturn */) {\n                    danglingCR = true;\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength - 1);\n                }\n                else {\n                    currentLine += buffer.substr(pieceStartOffset, pieceLength);\n                }\n                return true;\n            }\n            // add the text before the first line start in this piece\n            currentLine += (this._EOLNormalized\n                ? buffer.substring(pieceStartOffset, Math.max(pieceStartOffset, lineStarts[pieceStartLine + 1] - this._EOLLength))\n                : buffer.substring(pieceStartOffset, lineStarts[pieceStartLine + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n            lines[linesLength++] = currentLine;\n            for (let line = pieceStartLine + 1; line < pieceEndLine; line++) {\n                currentLine = (this._EOLNormalized\n                    ? buffer.substring(lineStarts[line], lineStarts[line + 1] - this._EOLLength)\n                    : buffer.substring(lineStarts[line], lineStarts[line + 1]).replace(/(\\r\\n|\\r|\\n)$/, ''));\n                lines[linesLength++] = currentLine;\n            }\n            if (!this._EOLNormalized && buffer.charCodeAt(lineStarts[pieceEndLine] + piece.end.column - 1) === 13 /* CharCode.CarriageReturn */) {\n                danglingCR = true;\n                if (piece.end.column === 0) {\n                    // The last line ended with a \\r, let's undo the push, it will be pushed by next iteration\n                    linesLength--;\n                }\n                else {\n                    currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column - 1);\n                }\n            }\n            else {\n                currentLine = buffer.substr(lineStarts[pieceEndLine], piece.end.column);\n            }\n            return true;\n        });\n        if (danglingCR) {\n            lines[linesLength++] = currentLine;\n            currentLine = '';\n        }\n        lines[linesLength++] = currentLine;\n        return lines;\n    }\n    getLength() {\n        return this._length;\n    }\n    getLineCount() {\n        return this._lineCnt;\n    }\n    getLineContent(lineNumber) {\n        if (this._lastVisitedLine.lineNumber === lineNumber) {\n            return this._lastVisitedLine.value;\n        }\n        this._lastVisitedLine.lineNumber = lineNumber;\n        if (lineNumber === this._lineCnt) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber);\n        }\n        else if (this._EOLNormalized) {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber, this._EOLLength);\n        }\n        else {\n            this._lastVisitedLine.value = this.getLineRawContent(lineNumber).replace(/(\\r\\n|\\r|\\n)$/, '');\n        }\n        return this._lastVisitedLine.value;\n    }\n    _getCharCode(nodePos) {\n        if (nodePos.remainder === nodePos.node.piece.length) {\n            // the char we want to fetch is at the head of next node.\n            const matchingNode = nodePos.node.next();\n            if (!matchingNode) {\n                return 0;\n            }\n            const buffer = this._buffers[matchingNode.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(matchingNode.piece.bufferIndex, matchingNode.piece.start);\n            return buffer.buffer.charCodeAt(startOffset);\n        }\n        else {\n            const buffer = this._buffers[nodePos.node.piece.bufferIndex];\n            const startOffset = this.offsetInBuffer(nodePos.node.piece.bufferIndex, nodePos.node.piece.start);\n            const targetOffset = startOffset + nodePos.remainder;\n            return buffer.buffer.charCodeAt(targetOffset);\n        }\n    }\n    getLineCharCode(lineNumber, index) {\n        const nodePos = this.nodeAt2(lineNumber, index + 1);\n        return this._getCharCode(nodePos);\n    }\n    getLineLength(lineNumber) {\n        if (lineNumber === this.getLineCount()) {\n            const startOffset = this.getOffsetAt(lineNumber, 1);\n            return this.getLength() - startOffset;\n        }\n        return this.getOffsetAt(lineNumber + 1, 1) - this.getOffsetAt(lineNumber, 1) - this._EOLLength;\n    }\n    findMatchesInNode(node, searcher, startLineNumber, startColumn, startCursor, endCursor, searchData, captureMatches, limitResultCount, resultLen, result) {\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const startOffsetInBuffer = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start);\n        const start = this.offsetInBuffer(node.piece.bufferIndex, startCursor);\n        const end = this.offsetInBuffer(node.piece.bufferIndex, endCursor);\n        let m;\n        // Reset regex to search from the beginning\n        const ret = { line: 0, column: 0 };\n        let searchText;\n        let offsetInBuffer;\n        if (searcher._wordSeparators) {\n            searchText = buffer.buffer.substring(start, end);\n            offsetInBuffer = (offset) => offset + start;\n            searcher.reset(0);\n        }\n        else {\n            searchText = buffer.buffer;\n            offsetInBuffer = (offset) => offset;\n            searcher.reset(start);\n        }\n        do {\n            m = searcher.next(searchText);\n            if (m) {\n                if (offsetInBuffer(m.index) >= end) {\n                    return resultLen;\n                }\n                this.positionInBuffer(node, offsetInBuffer(m.index) - startOffsetInBuffer, ret);\n                const lineFeedCnt = this.getLineFeedCnt(node.piece.bufferIndex, startCursor, ret);\n                const retStartColumn = ret.line === startCursor.line ? ret.column - startCursor.column + startColumn : ret.column + 1;\n                const retEndColumn = retStartColumn + m[0].length;\n                result[resultLen++] = createFindMatch(new Range(startLineNumber + lineFeedCnt, retStartColumn, startLineNumber + lineFeedCnt, retEndColumn), m, captureMatches);\n                if (offsetInBuffer(m.index) + m[0].length >= end) {\n                    return resultLen;\n                }\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        const result = [];\n        let resultLen = 0;\n        const searcher = new Searcher(searchData.wordSeparators, searchData.regex);\n        let startPosition = this.nodeAt2(searchRange.startLineNumber, searchRange.startColumn);\n        if (startPosition === null) {\n            return [];\n        }\n        const endPosition = this.nodeAt2(searchRange.endLineNumber, searchRange.endColumn);\n        if (endPosition === null) {\n            return [];\n        }\n        let start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        const end = this.positionInBuffer(endPosition.node, endPosition.remainder);\n        if (startPosition.node === endPosition.node) {\n            this.findMatchesInNode(startPosition.node, searcher, searchRange.startLineNumber, searchRange.startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n            return result;\n        }\n        let startLineNumber = searchRange.startLineNumber;\n        let currentNode = startPosition.node;\n        while (currentNode !== endPosition.node) {\n            const lineBreakCnt = this.getLineFeedCnt(currentNode.piece.bufferIndex, start, currentNode.piece.end);\n            if (lineBreakCnt >= 1) {\n                // last line break position\n                const lineStarts = this._buffers[currentNode.piece.bufferIndex].lineStarts;\n                const startOffsetInBuffer = this.offsetInBuffer(currentNode.piece.bufferIndex, currentNode.piece.start);\n                const nextLineStartOffset = lineStarts[start.line + lineBreakCnt];\n                const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n                resultLen = this.findMatchesInNode(currentNode, searcher, startLineNumber, startColumn, start, this.positionInBuffer(currentNode, nextLineStartOffset - startOffsetInBuffer), searchData, captureMatches, limitResultCount, resultLen, result);\n                if (resultLen >= limitResultCount) {\n                    return result;\n                }\n                startLineNumber += lineBreakCnt;\n            }\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            // search for the remaining content\n            if (startLineNumber === searchRange.endLineNumber) {\n                const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n                resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n                return result;\n            }\n            resultLen = this._findMatchesInLine(searchData, searcher, this.getLineContent(startLineNumber).substr(startColumn), startLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            if (resultLen >= limitResultCount) {\n                return result;\n            }\n            startLineNumber++;\n            startPosition = this.nodeAt2(startLineNumber, 1);\n            currentNode = startPosition.node;\n            start = this.positionInBuffer(startPosition.node, startPosition.remainder);\n        }\n        if (startLineNumber === searchRange.endLineNumber) {\n            const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn - 1 : 0;\n            const text = this.getLineContent(startLineNumber).substring(startColumn, searchRange.endColumn - 1);\n            resultLen = this._findMatchesInLine(searchData, searcher, text, searchRange.endLineNumber, startColumn, resultLen, result, captureMatches, limitResultCount);\n            return result;\n        }\n        const startColumn = startLineNumber === searchRange.startLineNumber ? searchRange.startColumn : 1;\n        resultLen = this.findMatchesInNode(endPosition.node, searcher, startLineNumber, startColumn, start, end, searchData, captureMatches, limitResultCount, resultLen, result);\n        return result;\n    }\n    _findMatchesInLine(searchData, searcher, text, lineNumber, deltaOffset, resultLen, result, captureMatches, limitResultCount) {\n        const wordSeparators = searchData.wordSeparators;\n        if (!captureMatches && searchData.simpleSearch) {\n            const searchString = searchData.simpleSearch;\n            const searchStringLen = searchString.length;\n            const textLength = text.length;\n            let lastMatchIndex = -searchStringLen;\n            while ((lastMatchIndex = text.indexOf(searchString, lastMatchIndex + searchStringLen)) !== -1) {\n                if (!wordSeparators || isValidMatch(wordSeparators, text, textLength, lastMatchIndex, searchStringLen)) {\n                    result[resultLen++] = new FindMatch(new Range(lineNumber, lastMatchIndex + 1 + deltaOffset, lineNumber, lastMatchIndex + 1 + searchStringLen + deltaOffset), null);\n                    if (resultLen >= limitResultCount) {\n                        return resultLen;\n                    }\n                }\n            }\n            return resultLen;\n        }\n        let m;\n        // Reset regex to search from the beginning\n        searcher.reset(0);\n        do {\n            m = searcher.next(text);\n            if (m) {\n                result[resultLen++] = createFindMatch(new Range(lineNumber, m.index + 1 + deltaOffset, lineNumber, m.index + 1 + m[0].length + deltaOffset), m, captureMatches);\n                if (resultLen >= limitResultCount) {\n                    return resultLen;\n                }\n            }\n        } while (m);\n        return resultLen;\n    }\n    // #endregion\n    // #region Piece Table\n    insert(offset, value, eolNormalized = false) {\n        this._EOLNormalized = this._EOLNormalized && eolNormalized;\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (this.root !== SENTINEL) {\n            const { node, remainder, nodeStartOffset } = this.nodeAt(offset);\n            const piece = node.piece;\n            const bufferIndex = piece.bufferIndex;\n            const insertPosInBuffer = this.positionInBuffer(node, remainder);\n            if (node.piece.bufferIndex === 0 &&\n                piece.end.line === this._lastChangeBufferPos.line &&\n                piece.end.column === this._lastChangeBufferPos.column &&\n                (nodeStartOffset + piece.length === offset) &&\n                value.length < AverageBufferSize) {\n                // changed buffer\n                this.appendToNode(node, value);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (nodeStartOffset === offset) {\n                this.insertContentToNodeLeft(value, node);\n                this._searchCache.validate(offset);\n            }\n            else if (nodeStartOffset + node.piece.length > offset) {\n                // we are inserting into the middle of a node.\n                const nodesToDel = [];\n                let newRightPiece = new Piece(piece.bufferIndex, insertPosInBuffer, piece.end, this.getLineFeedCnt(piece.bufferIndex, insertPosInBuffer, piece.end), this.offsetInBuffer(bufferIndex, piece.end) - this.offsetInBuffer(bufferIndex, insertPosInBuffer));\n                if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n                    const headOfRight = this.nodeCharCodeAt(node, remainder);\n                    if (headOfRight === 10 /** \\n */) {\n                        const newStart = { line: newRightPiece.start.line + 1, column: 0 };\n                        newRightPiece = new Piece(newRightPiece.bufferIndex, newStart, newRightPiece.end, this.getLineFeedCnt(newRightPiece.bufferIndex, newStart, newRightPiece.end), newRightPiece.length - 1);\n                        value += '\\n';\n                    }\n                }\n                // reuse node for content before insertion point.\n                if (this.shouldCheckCRLF() && this.startWithLF(value)) {\n                    const tailOfLeft = this.nodeCharCodeAt(node, remainder - 1);\n                    if (tailOfLeft === 13 /** \\r */) {\n                        const previousPos = this.positionInBuffer(node, remainder - 1);\n                        this.deleteNodeTail(node, previousPos);\n                        value = '\\r' + value;\n                        if (node.piece.length === 0) {\n                            nodesToDel.push(node);\n                        }\n                    }\n                    else {\n                        this.deleteNodeTail(node, insertPosInBuffer);\n                    }\n                }\n                else {\n                    this.deleteNodeTail(node, insertPosInBuffer);\n                }\n                const newPieces = this.createNewPieces(value);\n                if (newRightPiece.length > 0) {\n                    this.rbInsertRight(node, newRightPiece);\n                }\n                let tmpNode = node;\n                for (let k = 0; k < newPieces.length; k++) {\n                    tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n                }\n                this.deleteNodes(nodesToDel);\n            }\n            else {\n                this.insertContentToNodeRight(value, node);\n            }\n        }\n        else {\n            // insert new node\n            const pieces = this.createNewPieces(value);\n            let node = this.rbInsertLeft(null, pieces[0]);\n            for (let k = 1; k < pieces.length; k++) {\n                node = this.rbInsertRight(node, pieces[k]);\n            }\n        }\n        // todo, this is too brutal. Total line feed count should be updated the same way as lf_left.\n        this.computeBufferMetadata();\n    }\n    delete(offset, cnt) {\n        this._lastVisitedLine.lineNumber = 0;\n        this._lastVisitedLine.value = '';\n        if (cnt <= 0 || this.root === SENTINEL) {\n            return;\n        }\n        const startPosition = this.nodeAt(offset);\n        const endPosition = this.nodeAt(offset + cnt);\n        const startNode = startPosition.node;\n        const endNode = endPosition.node;\n        if (startNode === endNode) {\n            const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n            const endSplitPosInBuffer = this.positionInBuffer(startNode, endPosition.remainder);\n            if (startPosition.nodeStartOffset === offset) {\n                if (cnt === startNode.piece.length) { // delete node\n                    const next = startNode.next();\n                    rbDelete(this, startNode);\n                    this.validateCRLFWithPrevNode(next);\n                    this.computeBufferMetadata();\n                    return;\n                }\n                this.deleteNodeHead(startNode, endSplitPosInBuffer);\n                this._searchCache.validate(offset);\n                this.validateCRLFWithPrevNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            if (startPosition.nodeStartOffset + startNode.piece.length === offset + cnt) {\n                this.deleteNodeTail(startNode, startSplitPosInBuffer);\n                this.validateCRLFWithNextNode(startNode);\n                this.computeBufferMetadata();\n                return;\n            }\n            // delete content in the middle, this node will be splitted to nodes\n            this.shrinkNode(startNode, startSplitPosInBuffer, endSplitPosInBuffer);\n            this.computeBufferMetadata();\n            return;\n        }\n        const nodesToDel = [];\n        const startSplitPosInBuffer = this.positionInBuffer(startNode, startPosition.remainder);\n        this.deleteNodeTail(startNode, startSplitPosInBuffer);\n        this._searchCache.validate(offset);\n        if (startNode.piece.length === 0) {\n            nodesToDel.push(startNode);\n        }\n        // update last touched node\n        const endSplitPosInBuffer = this.positionInBuffer(endNode, endPosition.remainder);\n        this.deleteNodeHead(endNode, endSplitPosInBuffer);\n        if (endNode.piece.length === 0) {\n            nodesToDel.push(endNode);\n        }\n        // delete nodes in between\n        const secondNode = startNode.next();\n        for (let node = secondNode; node !== SENTINEL && node !== endNode; node = node.next()) {\n            nodesToDel.push(node);\n        }\n        const prev = startNode.piece.length === 0 ? startNode.prev() : startNode;\n        this.deleteNodes(nodesToDel);\n        this.validateCRLFWithNextNode(prev);\n        this.computeBufferMetadata();\n    }\n    insertContentToNodeLeft(value, node) {\n        // we are inserting content to the beginning of node\n        const nodesToDel = [];\n        if (this.shouldCheckCRLF() && this.endWithCR(value) && this.startWithLF(node)) {\n            // move `\\n` to new node.\n            const piece = node.piece;\n            const newStart = { line: piece.start.line + 1, column: 0 };\n            const nPiece = new Piece(piece.bufferIndex, newStart, piece.end, this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end), piece.length - 1);\n            node.piece = nPiece;\n            value += '\\n';\n            updateTreeMetadata(this, node, -1, -1);\n            if (node.piece.length === 0) {\n                nodesToDel.push(node);\n            }\n        }\n        const newPieces = this.createNewPieces(value);\n        let newNode = this.rbInsertLeft(node, newPieces[newPieces.length - 1]);\n        for (let k = newPieces.length - 2; k >= 0; k--) {\n            newNode = this.rbInsertLeft(newNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n        this.deleteNodes(nodesToDel);\n    }\n    insertContentToNodeRight(value, node) {\n        // we are inserting to the right of this node.\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            // move \\n to the new node.\n            value += '\\n';\n        }\n        const newPieces = this.createNewPieces(value);\n        const newNode = this.rbInsertRight(node, newPieces[0]);\n        let tmpNode = newNode;\n        for (let k = 1; k < newPieces.length; k++) {\n            tmpNode = this.rbInsertRight(tmpNode, newPieces[k]);\n        }\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    positionInBuffer(node, remainder, ret) {\n        const piece = node.piece;\n        const bufferIndex = node.piece.bufferIndex;\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        const startOffset = lineStarts[piece.start.line] + piece.start.column;\n        const offset = startOffset + remainder;\n        // binary search offset between startOffset and endOffset\n        let low = piece.start.line;\n        let high = piece.end.line;\n        let mid = 0;\n        let midStop = 0;\n        let midStart = 0;\n        while (low <= high) {\n            mid = low + ((high - low) / 2) | 0;\n            midStart = lineStarts[mid];\n            if (mid === high) {\n                break;\n            }\n            midStop = lineStarts[mid + 1];\n            if (offset < midStart) {\n                high = mid - 1;\n            }\n            else if (offset >= midStop) {\n                low = mid + 1;\n            }\n            else {\n                break;\n            }\n        }\n        if (ret) {\n            ret.line = mid;\n            ret.column = offset - midStart;\n            return null;\n        }\n        return {\n            line: mid,\n            column: offset - midStart\n        };\n    }\n    getLineFeedCnt(bufferIndex, start, end) {\n        // we don't need to worry about start: abc\\r|\\n, or abc|\\r, or abc|\\n, or abc|\\r\\n doesn't change the fact that, there is one line break after start.\n        // now let's take care of end: abc\\r|\\n, if end is in between \\r and \\n, we need to add line feed count by 1\n        if (end.column === 0) {\n            return end.line - start.line;\n        }\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        if (end.line === lineStarts.length - 1) { // it means, there is no \\n after end, otherwise, there will be one more lineStart.\n            return end.line - start.line;\n        }\n        const nextLineStartOffset = lineStarts[end.line + 1];\n        const endOffset = lineStarts[end.line] + end.column;\n        if (nextLineStartOffset > endOffset + 1) { // there are more than 1 character after end, which means it can't be \\n\n            return end.line - start.line;\n        }\n        // endOffset + 1 === nextLineStartOffset\n        // character at endOffset is \\n, so we check the character before first\n        // if character at endOffset is \\r, end.column is 0 and we can't get here.\n        const previousCharOffset = endOffset - 1; // end.column > 0 so it's okay.\n        const buffer = this._buffers[bufferIndex].buffer;\n        if (buffer.charCodeAt(previousCharOffset) === 13) {\n            return end.line - start.line + 1;\n        }\n        else {\n            return end.line - start.line;\n        }\n    }\n    offsetInBuffer(bufferIndex, cursor) {\n        const lineStarts = this._buffers[bufferIndex].lineStarts;\n        return lineStarts[cursor.line] + cursor.column;\n    }\n    deleteNodes(nodes) {\n        for (let i = 0; i < nodes.length; i++) {\n            rbDelete(this, nodes[i]);\n        }\n    }\n    createNewPieces(text) {\n        if (text.length > AverageBufferSize) {\n            // the content is large, operations like substring, charCode becomes slow\n            // so here we split it into smaller chunks, just like what we did for CR/LF normalization\n            const newPieces = [];\n            while (text.length > AverageBufferSize) {\n                const lastChar = text.charCodeAt(AverageBufferSize - 1);\n                let splitText;\n                if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n                    // last character is \\r or a high surrogate => keep it back\n                    splitText = text.substring(0, AverageBufferSize - 1);\n                    text = text.substring(AverageBufferSize - 1);\n                }\n                else {\n                    splitText = text.substring(0, AverageBufferSize);\n                    text = text.substring(AverageBufferSize);\n                }\n                const lineStarts = createLineStartsFast(splitText);\n                newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: splitText.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, splitText.length));\n                this._buffers.push(new StringBuffer(splitText, lineStarts));\n            }\n            const lineStarts = createLineStartsFast(text);\n            newPieces.push(new Piece(this._buffers.length, /* buffer index */ { line: 0, column: 0 }, { line: lineStarts.length - 1, column: text.length - lineStarts[lineStarts.length - 1] }, lineStarts.length - 1, text.length));\n            this._buffers.push(new StringBuffer(text, lineStarts));\n            return newPieces;\n        }\n        let startOffset = this._buffers[0].buffer.length;\n        const lineStarts = createLineStartsFast(text, false);\n        let start = this._lastChangeBufferPos;\n        if (this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 1] === startOffset\n            && startOffset !== 0\n            && this.startWithLF(text)\n            && this.endWithCR(this._buffers[0].buffer) // todo, we can check this._lastChangeBufferPos's column as it's the last one\n        ) {\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line, column: this._lastChangeBufferPos.column + 1 };\n            start = this._lastChangeBufferPos;\n            for (let i = 0; i < lineStarts.length; i++) {\n                lineStarts[i] += startOffset + 1;\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += '_' + text;\n            startOffset += 1;\n        }\n        else {\n            if (startOffset !== 0) {\n                for (let i = 0; i < lineStarts.length; i++) {\n                    lineStarts[i] += startOffset;\n                }\n            }\n            this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n            this._buffers[0].buffer += text;\n        }\n        const endOffset = this._buffers[0].buffer.length;\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = endOffset - this._buffers[0].lineStarts[endIndex];\n        const endPos = { line: endIndex, column: endColumn };\n        const newPiece = new Piece(0, /** todo@peng */ start, endPos, this.getLineFeedCnt(0, start, endPos), endOffset - startOffset);\n        this._lastChangeBufferPos = endPos;\n        return [newPiece];\n    }\n    getLineRawContent(lineNumber, endOffset = 0) {\n        let x = this.root;\n        let ret = '';\n        const cache = this._searchCache.get2(lineNumber);\n        if (cache) {\n            x = cache.node;\n            const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber - 1);\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n            if (cache.nodeStartLineNumber + x.piece.lineFeedCnt === lineNumber) {\n                ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n            }\n            else {\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - cache.nodeStartLineNumber);\n                return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n            }\n        }\n        else {\n            let nodeStartOffset = 0;\n            const originalLineNumber = lineNumber;\n            while (x !== SENTINEL) {\n                if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                    x = x.left;\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    nodeStartOffset += x.size_left;\n                    this._searchCache.set({\n                        node: x,\n                        nodeStartOffset,\n                        nodeStartLineNumber: originalLineNumber - (lineNumber - 1 - x.lf_left)\n                    });\n                    return buffer.substring(startOffset + prevAccumulatedValue, startOffset + accumulatedValue - endOffset);\n                }\n                else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                    const prevAccumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                    const buffer = this._buffers[x.piece.bufferIndex].buffer;\n                    const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                    ret = buffer.substring(startOffset + prevAccumulatedValue, startOffset + x.piece.length);\n                    break;\n                }\n                else {\n                    lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                    nodeStartOffset += x.size_left + x.piece.length;\n                    x = x.right;\n                }\n            }\n        }\n        // search in order, to find the node contains end column\n        x = x.next();\n        while (x !== SENTINEL) {\n            const buffer = this._buffers[x.piece.bufferIndex].buffer;\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substring(startOffset, startOffset + accumulatedValue - endOffset);\n                return ret;\n            }\n            else {\n                const startOffset = this.offsetInBuffer(x.piece.bufferIndex, x.piece.start);\n                ret += buffer.substr(startOffset, x.piece.length);\n            }\n            x = x.next();\n        }\n        return ret;\n    }\n    computeBufferMetadata() {\n        let x = this.root;\n        let lfCnt = 1;\n        let len = 0;\n        while (x !== SENTINEL) {\n            lfCnt += x.lf_left + x.piece.lineFeedCnt;\n            len += x.size_left + x.piece.length;\n            x = x.right;\n        }\n        this._lineCnt = lfCnt;\n        this._length = len;\n        this._searchCache.validate(this._length);\n    }\n    // #region node operations\n    getIndexOf(node, accumulatedValue) {\n        const piece = node.piece;\n        const pos = this.positionInBuffer(node, accumulatedValue);\n        const lineCnt = pos.line - piece.start.line;\n        if (this.offsetInBuffer(piece.bufferIndex, piece.end) - this.offsetInBuffer(piece.bufferIndex, piece.start) === accumulatedValue) {\n            // we are checking the end of this node, so a CRLF check is necessary.\n            const realLineCnt = this.getLineFeedCnt(node.piece.bufferIndex, piece.start, pos);\n            if (realLineCnt !== lineCnt) {\n                // aha yes, CRLF\n                return { index: realLineCnt, remainder: 0 };\n            }\n        }\n        return { index: lineCnt, remainder: pos.column };\n    }\n    getAccumulatedValue(node, index) {\n        if (index < 0) {\n            return 0;\n        }\n        const piece = node.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const expectedLineStartIndex = piece.start.line + index + 1;\n        if (expectedLineStartIndex > piece.end.line) {\n            return lineStarts[piece.end.line] + piece.end.column - lineStarts[piece.start.line] - piece.start.column;\n        }\n        else {\n            return lineStarts[expectedLineStartIndex] - lineStarts[piece.start.line] - piece.start.column;\n        }\n    }\n    deleteNodeTail(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalEndOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const newEnd = pos;\n        const newEndOffset = this.offsetInBuffer(piece.bufferIndex, newEnd);\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = newEndOffset - originalEndOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    deleteNodeHead(node, pos) {\n        const piece = node.piece;\n        const originalLFCnt = piece.lineFeedCnt;\n        const originalStartOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const newStart = pos;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n        const newStartOffset = this.offsetInBuffer(piece.bufferIndex, newStart);\n        const lf_delta = newLineFeedCnt - originalLFCnt;\n        const size_delta = originalStartOffset - newStartOffset;\n        const newLength = piece.length + size_delta;\n        node.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, size_delta, lf_delta);\n    }\n    shrinkNode(node, start, end) {\n        const piece = node.piece;\n        const originalStartPos = piece.start;\n        const originalEndPos = piece.end;\n        // old piece, originalStartPos, start\n        const oldLength = piece.length;\n        const oldLFCnt = piece.lineFeedCnt;\n        const newEnd = start;\n        const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, piece.start, newEnd);\n        const newLength = this.offsetInBuffer(piece.bufferIndex, start) - this.offsetInBuffer(piece.bufferIndex, originalStartPos);\n        node.piece = new Piece(piece.bufferIndex, piece.start, newEnd, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, node, newLength - oldLength, newLineFeedCnt - oldLFCnt);\n        // new right piece, end, originalEndPos\n        const newPiece = new Piece(piece.bufferIndex, end, originalEndPos, this.getLineFeedCnt(piece.bufferIndex, end, originalEndPos), this.offsetInBuffer(piece.bufferIndex, originalEndPos) - this.offsetInBuffer(piece.bufferIndex, end));\n        const newNode = this.rbInsertRight(node, newPiece);\n        this.validateCRLFWithPrevNode(newNode);\n    }\n    appendToNode(node, value) {\n        if (this.adjustCarriageReturnFromNext(value, node)) {\n            value += '\\n';\n        }\n        const hitCRLF = this.shouldCheckCRLF() && this.startWithLF(value) && this.endWithCR(node);\n        const startOffset = this._buffers[0].buffer.length;\n        this._buffers[0].buffer += value;\n        const lineStarts = createLineStartsFast(value, false);\n        for (let i = 0; i < lineStarts.length; i++) {\n            lineStarts[i] += startOffset;\n        }\n        if (hitCRLF) {\n            const prevStartOffset = this._buffers[0].lineStarts[this._buffers[0].lineStarts.length - 2];\n            this._buffers[0].lineStarts.pop();\n            // _lastChangeBufferPos is already wrong\n            this._lastChangeBufferPos = { line: this._lastChangeBufferPos.line - 1, column: startOffset - prevStartOffset };\n        }\n        this._buffers[0].lineStarts = this._buffers[0].lineStarts.concat(lineStarts.slice(1));\n        const endIndex = this._buffers[0].lineStarts.length - 1;\n        const endColumn = this._buffers[0].buffer.length - this._buffers[0].lineStarts[endIndex];\n        const newEnd = { line: endIndex, column: endColumn };\n        const newLength = node.piece.length + value.length;\n        const oldLineFeedCnt = node.piece.lineFeedCnt;\n        const newLineFeedCnt = this.getLineFeedCnt(0, node.piece.start, newEnd);\n        const lf_delta = newLineFeedCnt - oldLineFeedCnt;\n        node.piece = new Piece(node.piece.bufferIndex, node.piece.start, newEnd, newLineFeedCnt, newLength);\n        this._lastChangeBufferPos = newEnd;\n        updateTreeMetadata(this, node, value.length, lf_delta);\n    }\n    nodeAt(offset) {\n        let x = this.root;\n        const cache = this._searchCache.get(offset);\n        if (cache) {\n            return {\n                node: cache.node,\n                nodeStartOffset: cache.nodeStartOffset,\n                remainder: offset - cache.nodeStartOffset\n            };\n        }\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.size_left > offset) {\n                x = x.left;\n            }\n            else if (x.size_left + x.piece.length >= offset) {\n                nodeStartOffset += x.size_left;\n                const ret = {\n                    node: x,\n                    remainder: offset - x.size_left,\n                    nodeStartOffset\n                };\n                this._searchCache.set(ret);\n                return ret;\n            }\n            else {\n                offset -= x.size_left + x.piece.length;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        return null;\n    }\n    nodeAt2(lineNumber, column) {\n        let x = this.root;\n        let nodeStartOffset = 0;\n        while (x !== SENTINEL) {\n            if (x.left !== SENTINEL && x.lf_left >= lineNumber - 1) {\n                x = x.left;\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt > lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                const accumulatedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 1);\n                nodeStartOffset += x.size_left;\n                return {\n                    node: x,\n                    remainder: Math.min(prevAccumualtedValue + column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else if (x.lf_left + x.piece.lineFeedCnt === lineNumber - 1) {\n                const prevAccumualtedValue = this.getAccumulatedValue(x, lineNumber - x.lf_left - 2);\n                if (prevAccumualtedValue + column - 1 <= x.piece.length) {\n                    return {\n                        node: x,\n                        remainder: prevAccumualtedValue + column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length - prevAccumualtedValue;\n                    break;\n                }\n            }\n            else {\n                lineNumber -= x.lf_left + x.piece.lineFeedCnt;\n                nodeStartOffset += x.size_left + x.piece.length;\n                x = x.right;\n            }\n        }\n        // search in order, to find the node contains position.column\n        x = x.next();\n        while (x !== SENTINEL) {\n            if (x.piece.lineFeedCnt > 0) {\n                const accumulatedValue = this.getAccumulatedValue(x, 0);\n                const nodeStartOffset = this.offsetOfNode(x);\n                return {\n                    node: x,\n                    remainder: Math.min(column - 1, accumulatedValue),\n                    nodeStartOffset\n                };\n            }\n            else {\n                if (x.piece.length >= column - 1) {\n                    const nodeStartOffset = this.offsetOfNode(x);\n                    return {\n                        node: x,\n                        remainder: column - 1,\n                        nodeStartOffset\n                    };\n                }\n                else {\n                    column -= x.piece.length;\n                }\n            }\n            x = x.next();\n        }\n        return null;\n    }\n    nodeCharCodeAt(node, offset) {\n        if (node.piece.lineFeedCnt < 1) {\n            return -1;\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const newOffset = this.offsetInBuffer(node.piece.bufferIndex, node.piece.start) + offset;\n        return buffer.buffer.charCodeAt(newOffset);\n    }\n    offsetOfNode(node) {\n        if (!node) {\n            return 0;\n        }\n        let pos = node.size_left;\n        while (node !== this.root) {\n            if (node.parent.right === node) {\n                pos += node.parent.size_left + node.parent.piece.length;\n            }\n            node = node.parent;\n        }\n        return pos;\n    }\n    // #endregion\n    // #region CRLF\n    shouldCheckCRLF() {\n        return !(this._EOLNormalized && this._EOL === '\\n');\n    }\n    startWithLF(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(0) === 10;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        const piece = val.piece;\n        const lineStarts = this._buffers[piece.bufferIndex].lineStarts;\n        const line = piece.start.line;\n        const startOffset = lineStarts[line] + piece.start.column;\n        if (line === lineStarts.length - 1) {\n            // last line, so there is no line feed at the end of this line\n            return false;\n        }\n        const nextLineOffset = lineStarts[line + 1];\n        if (nextLineOffset > startOffset + 1) {\n            return false;\n        }\n        return this._buffers[piece.bufferIndex].buffer.charCodeAt(startOffset) === 10;\n    }\n    endWithCR(val) {\n        if (typeof val === 'string') {\n            return val.charCodeAt(val.length - 1) === 13;\n        }\n        if (val === SENTINEL || val.piece.lineFeedCnt === 0) {\n            return false;\n        }\n        return this.nodeCharCodeAt(val, val.piece.length - 1) === 13;\n    }\n    validateCRLFWithPrevNode(nextNode) {\n        if (this.shouldCheckCRLF() && this.startWithLF(nextNode)) {\n            const node = nextNode.prev();\n            if (this.endWithCR(node)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    validateCRLFWithNextNode(node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(node)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                this.fixCRLF(node, nextNode);\n            }\n        }\n    }\n    fixCRLF(prev, next) {\n        const nodesToDel = [];\n        // update node\n        const lineStarts = this._buffers[prev.piece.bufferIndex].lineStarts;\n        let newEnd;\n        if (prev.piece.end.column === 0) {\n            // it means, last line ends with \\r, not \\r\\n\n            newEnd = { line: prev.piece.end.line - 1, column: lineStarts[prev.piece.end.line] - lineStarts[prev.piece.end.line - 1] - 1 };\n        }\n        else {\n            // \\r\\n\n            newEnd = { line: prev.piece.end.line, column: prev.piece.end.column - 1 };\n        }\n        const prevNewLength = prev.piece.length - 1;\n        const prevNewLFCnt = prev.piece.lineFeedCnt - 1;\n        prev.piece = new Piece(prev.piece.bufferIndex, prev.piece.start, newEnd, prevNewLFCnt, prevNewLength);\n        updateTreeMetadata(this, prev, -1, -1);\n        if (prev.piece.length === 0) {\n            nodesToDel.push(prev);\n        }\n        // update nextNode\n        const newStart = { line: next.piece.start.line + 1, column: 0 };\n        const newLength = next.piece.length - 1;\n        const newLineFeedCnt = this.getLineFeedCnt(next.piece.bufferIndex, newStart, next.piece.end);\n        next.piece = new Piece(next.piece.bufferIndex, newStart, next.piece.end, newLineFeedCnt, newLength);\n        updateTreeMetadata(this, next, -1, -1);\n        if (next.piece.length === 0) {\n            nodesToDel.push(next);\n        }\n        // create new piece which contains \\r\\n\n        const pieces = this.createNewPieces('\\r\\n');\n        this.rbInsertRight(prev, pieces[0]);\n        // delete empty nodes\n        for (let i = 0; i < nodesToDel.length; i++) {\n            rbDelete(this, nodesToDel[i]);\n        }\n    }\n    adjustCarriageReturnFromNext(value, node) {\n        if (this.shouldCheckCRLF() && this.endWithCR(value)) {\n            const nextNode = node.next();\n            if (this.startWithLF(nextNode)) {\n                // move `\\n` forward\n                value += '\\n';\n                if (nextNode.piece.length === 1) {\n                    rbDelete(this, nextNode);\n                }\n                else {\n                    const piece = nextNode.piece;\n                    const newStart = { line: piece.start.line + 1, column: 0 };\n                    const newLength = piece.length - 1;\n                    const newLineFeedCnt = this.getLineFeedCnt(piece.bufferIndex, newStart, piece.end);\n                    nextNode.piece = new Piece(piece.bufferIndex, newStart, piece.end, newLineFeedCnt, newLength);\n                    updateTreeMetadata(this, nextNode, -1, -1);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    // #endregion\n    // #endregion\n    // #region Tree operations\n    iterate(node, callback) {\n        if (node === SENTINEL) {\n            return callback(SENTINEL);\n        }\n        const leftRet = this.iterate(node.left, callback);\n        if (!leftRet) {\n            return leftRet;\n        }\n        return callback(node) && this.iterate(node.right, callback);\n    }\n    getNodeContent(node) {\n        if (node === SENTINEL) {\n            return '';\n        }\n        const buffer = this._buffers[node.piece.bufferIndex];\n        const piece = node.piece;\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    getPieceContent(piece) {\n        const buffer = this._buffers[piece.bufferIndex];\n        const startOffset = this.offsetInBuffer(piece.bufferIndex, piece.start);\n        const endOffset = this.offsetInBuffer(piece.bufferIndex, piece.end);\n        const currentContent = buffer.buffer.substring(startOffset, endOffset);\n        return currentContent;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b    <----   a    b\n     *                         /\n     *                        z\n     */\n    rbInsertRight(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        const x = this.root;\n        if (x === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.right === SENTINEL) {\n            node.right = z;\n            z.parent = node;\n        }\n        else {\n            const nextNode = leftest(node.right);\n            nextNode.left = z;\n            z.parent = nextNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n    /**\n     *      node              node\n     *     /  \\              /  \\\n     *    a   b     ---->   a    b\n     *                       \\\n     *                        z\n     */\n    rbInsertLeft(node, p) {\n        const z = new TreeNode(p, 1 /* NodeColor.Red */);\n        z.left = SENTINEL;\n        z.right = SENTINEL;\n        z.parent = SENTINEL;\n        z.size_left = 0;\n        z.lf_left = 0;\n        if (this.root === SENTINEL) {\n            this.root = z;\n            z.color = 0 /* NodeColor.Black */;\n        }\n        else if (node.left === SENTINEL) {\n            node.left = z;\n            z.parent = node;\n        }\n        else {\n            const prevNode = righttest(node.left); // a\n            prevNode.right = z;\n            z.parent = prevNode;\n        }\n        fixInsert(this, z);\n        return z;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Emitter } from '../../../../base/common/event.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { Range } from '../../core/range.js';\nimport { ApplyEditsResult } from '../../model.js';\nimport { PieceTreeBase } from './pieceTreeBase.js';\nimport { countEOL } from '../../core/eolCounter.js';\nimport { TextChange } from '../../core/textChange.js';\nimport { Disposable } from '../../../../base/common/lifecycle.js';\nexport class PieceTreeTextBuffer extends Disposable {\n    constructor(chunks, BOM, eol, containsRTL, containsUnusualLineTerminators, isBasicASCII, eolNormalized) {\n        super();\n        this._onDidChangeContent = this._register(new Emitter());\n        this._BOM = BOM;\n        this._mightContainNonBasicASCII = !isBasicASCII;\n        this._mightContainRTL = containsRTL;\n        this._mightContainUnusualLineTerminators = containsUnusualLineTerminators;\n        this._pieceTree = new PieceTreeBase(chunks, eol, eolNormalized);\n    }\n    mightContainRTL() {\n        return this._mightContainRTL;\n    }\n    mightContainUnusualLineTerminators() {\n        return this._mightContainUnusualLineTerminators;\n    }\n    resetMightContainUnusualLineTerminators() {\n        this._mightContainUnusualLineTerminators = false;\n    }\n    mightContainNonBasicASCII() {\n        return this._mightContainNonBasicASCII;\n    }\n    getBOM() {\n        return this._BOM;\n    }\n    getEOL() {\n        return this._pieceTree.getEOL();\n    }\n    createSnapshot(preserveBOM) {\n        return this._pieceTree.createSnapshot(preserveBOM ? this._BOM : '');\n    }\n    getOffsetAt(lineNumber, column) {\n        return this._pieceTree.getOffsetAt(lineNumber, column);\n    }\n    getPositionAt(offset) {\n        return this._pieceTree.getPositionAt(offset);\n    }\n    getRangeAt(start, length) {\n        const end = start + length;\n        const startPosition = this.getPositionAt(start);\n        const endPosition = this.getPositionAt(end);\n        return new Range(startPosition.lineNumber, startPosition.column, endPosition.lineNumber, endPosition.column);\n    }\n    getValueInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return '';\n        }\n        const lineEnding = this._getEndOfLine(eol);\n        return this._pieceTree.getValueInRange(range, lineEnding);\n    }\n    getValueLengthInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (range.isEmpty()) {\n            return 0;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            return (range.endColumn - range.startColumn);\n        }\n        const startOffset = this.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this.getOffsetAt(range.endLineNumber, range.endColumn);\n        // offsets use the text EOL, so we need to compensate for length differences\n        // if the requested EOL doesn't match the text EOL\n        let eolOffsetCompensation = 0;\n        const desiredEOL = this._getEndOfLine(eol);\n        const actualEOL = this.getEOL();\n        if (desiredEOL.length !== actualEOL.length) {\n            const delta = desiredEOL.length - actualEOL.length;\n            const eolCount = range.endLineNumber - range.startLineNumber;\n            eolOffsetCompensation = delta * eolCount;\n        }\n        return endOffset - startOffset + eolOffsetCompensation;\n    }\n    getCharacterCountInRange(range, eol = 0 /* EndOfLinePreference.TextDefined */) {\n        if (this._mightContainNonBasicASCII) {\n            // we must count by iterating\n            let result = 0;\n            const fromLineNumber = range.startLineNumber;\n            const toLineNumber = range.endLineNumber;\n            for (let lineNumber = fromLineNumber; lineNumber <= toLineNumber; lineNumber++) {\n                const lineContent = this.getLineContent(lineNumber);\n                const fromOffset = (lineNumber === fromLineNumber ? range.startColumn - 1 : 0);\n                const toOffset = (lineNumber === toLineNumber ? range.endColumn - 1 : lineContent.length);\n                for (let offset = fromOffset; offset < toOffset; offset++) {\n                    if (strings.isHighSurrogate(lineContent.charCodeAt(offset))) {\n                        result = result + 1;\n                        offset = offset + 1;\n                    }\n                    else {\n                        result = result + 1;\n                    }\n                }\n            }\n            result += this._getEndOfLine(eol).length * (toLineNumber - fromLineNumber);\n            return result;\n        }\n        return this.getValueLengthInRange(range, eol);\n    }\n    getLength() {\n        return this._pieceTree.getLength();\n    }\n    getLineCount() {\n        return this._pieceTree.getLineCount();\n    }\n    getLinesContent() {\n        return this._pieceTree.getLinesContent();\n    }\n    getLineContent(lineNumber) {\n        return this._pieceTree.getLineContent(lineNumber);\n    }\n    getLineCharCode(lineNumber, index) {\n        return this._pieceTree.getLineCharCode(lineNumber, index);\n    }\n    getLineLength(lineNumber) {\n        return this._pieceTree.getLineLength(lineNumber);\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        const result = strings.firstNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 1;\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        const result = strings.lastNonWhitespaceIndex(this.getLineContent(lineNumber));\n        if (result === -1) {\n            return 0;\n        }\n        return result + 2;\n    }\n    _getEndOfLine(eol) {\n        switch (eol) {\n            case 1 /* EndOfLinePreference.LF */:\n                return '\\n';\n            case 2 /* EndOfLinePreference.CRLF */:\n                return '\\r\\n';\n            case 0 /* EndOfLinePreference.TextDefined */:\n                return this.getEOL();\n            default:\n                throw new Error('Unknown EOL preference');\n        }\n    }\n    setEOL(newEOL) {\n        this._pieceTree.setEOL(newEOL);\n    }\n    applyEdits(rawOperations, recordTrimAutoWhitespace, computeUndoEdits) {\n        let mightContainRTL = this._mightContainRTL;\n        let mightContainUnusualLineTerminators = this._mightContainUnusualLineTerminators;\n        let mightContainNonBasicASCII = this._mightContainNonBasicASCII;\n        let canReduceOperations = true;\n        let operations = [];\n        for (let i = 0; i < rawOperations.length; i++) {\n            const op = rawOperations[i];\n            if (canReduceOperations && op._isTracked) {\n                canReduceOperations = false;\n            }\n            const validatedRange = op.range;\n            if (op.text) {\n                let textMightContainNonBasicASCII = true;\n                if (!mightContainNonBasicASCII) {\n                    textMightContainNonBasicASCII = !strings.isBasicASCII(op.text);\n                    mightContainNonBasicASCII = textMightContainNonBasicASCII;\n                }\n                if (!mightContainRTL && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains RTL\n                    mightContainRTL = strings.containsRTL(op.text);\n                }\n                if (!mightContainUnusualLineTerminators && textMightContainNonBasicASCII) {\n                    // check if the new inserted text contains unusual line terminators\n                    mightContainUnusualLineTerminators = strings.containsUnusualLineTerminators(op.text);\n                }\n            }\n            let validText = '';\n            let eolCount = 0;\n            let firstLineLength = 0;\n            let lastLineLength = 0;\n            if (op.text) {\n                let strEOL;\n                [eolCount, firstLineLength, lastLineLength, strEOL] = countEOL(op.text);\n                const bufferEOL = this.getEOL();\n                const expectedStrEOL = (bufferEOL === '\\r\\n' ? 2 /* StringEOL.CRLF */ : 1 /* StringEOL.LF */);\n                if (strEOL === 0 /* StringEOL.Unknown */ || strEOL === expectedStrEOL) {\n                    validText = op.text;\n                }\n                else {\n                    validText = op.text.replace(/\\r\\n|\\r|\\n/g, bufferEOL);\n                }\n            }\n            operations[i] = {\n                sortIndex: i,\n                identifier: op.identifier || null,\n                range: validatedRange,\n                rangeOffset: this.getOffsetAt(validatedRange.startLineNumber, validatedRange.startColumn),\n                rangeLength: this.getValueLengthInRange(validatedRange),\n                text: validText,\n                eolCount: eolCount,\n                firstLineLength: firstLineLength,\n                lastLineLength: lastLineLength,\n                forceMoveMarkers: Boolean(op.forceMoveMarkers),\n                isAutoWhitespaceEdit: op.isAutoWhitespaceEdit || false\n            };\n        }\n        // Sort operations ascending\n        operations.sort(PieceTreeTextBuffer._sortOpsAscending);\n        let hasTouchingRanges = false;\n        for (let i = 0, count = operations.length - 1; i < count; i++) {\n            const rangeEnd = operations[i].range.getEndPosition();\n            const nextRangeStart = operations[i + 1].range.getStartPosition();\n            if (nextRangeStart.isBeforeOrEqual(rangeEnd)) {\n                if (nextRangeStart.isBefore(rangeEnd)) {\n                    // overlapping ranges\n                    throw new Error('Overlapping ranges are not allowed!');\n                }\n                hasTouchingRanges = true;\n            }\n        }\n        if (canReduceOperations) {\n            operations = this._reduceOperations(operations);\n        }\n        // Delta encode operations\n        const reverseRanges = (computeUndoEdits || recordTrimAutoWhitespace ? PieceTreeTextBuffer._getInverseEditRanges(operations) : []);\n        const newTrimAutoWhitespaceCandidates = [];\n        if (recordTrimAutoWhitespace) {\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                if (op.isAutoWhitespaceEdit && op.range.isEmpty()) {\n                    // Record already the future line numbers that might be auto whitespace removal candidates on next edit\n                    for (let lineNumber = reverseRange.startLineNumber; lineNumber <= reverseRange.endLineNumber; lineNumber++) {\n                        let currentLineContent = '';\n                        if (lineNumber === reverseRange.startLineNumber) {\n                            currentLineContent = this.getLineContent(op.range.startLineNumber);\n                            if (strings.firstNonWhitespaceIndex(currentLineContent) !== -1) {\n                                continue;\n                            }\n                        }\n                        newTrimAutoWhitespaceCandidates.push({ lineNumber: lineNumber, oldContent: currentLineContent });\n                    }\n                }\n            }\n        }\n        let reverseOperations = null;\n        if (computeUndoEdits) {\n            let reverseRangeDeltaOffset = 0;\n            reverseOperations = [];\n            for (let i = 0; i < operations.length; i++) {\n                const op = operations[i];\n                const reverseRange = reverseRanges[i];\n                const bufferText = this.getValueInRange(op.range);\n                const reverseRangeOffset = op.rangeOffset + reverseRangeDeltaOffset;\n                reverseRangeDeltaOffset += (op.text.length - bufferText.length);\n                reverseOperations[i] = {\n                    sortIndex: op.sortIndex,\n                    identifier: op.identifier,\n                    range: reverseRange,\n                    text: bufferText,\n                    textChange: new TextChange(op.rangeOffset, bufferText, reverseRangeOffset, op.text)\n                };\n            }\n            // Can only sort reverse operations when the order is not significant\n            if (!hasTouchingRanges) {\n                reverseOperations.sort((a, b) => a.sortIndex - b.sortIndex);\n            }\n        }\n        this._mightContainRTL = mightContainRTL;\n        this._mightContainUnusualLineTerminators = mightContainUnusualLineTerminators;\n        this._mightContainNonBasicASCII = mightContainNonBasicASCII;\n        const contentChanges = this._doApplyEdits(operations);\n        let trimAutoWhitespaceLineNumbers = null;\n        if (recordTrimAutoWhitespace && newTrimAutoWhitespaceCandidates.length > 0) {\n            // sort line numbers auto whitespace removal candidates for next edit descending\n            newTrimAutoWhitespaceCandidates.sort((a, b) => b.lineNumber - a.lineNumber);\n            trimAutoWhitespaceLineNumbers = [];\n            for (let i = 0, len = newTrimAutoWhitespaceCandidates.length; i < len; i++) {\n                const lineNumber = newTrimAutoWhitespaceCandidates[i].lineNumber;\n                if (i > 0 && newTrimAutoWhitespaceCandidates[i - 1].lineNumber === lineNumber) {\n                    // Do not have the same line number twice\n                    continue;\n                }\n                const prevContent = newTrimAutoWhitespaceCandidates[i].oldContent;\n                const lineContent = this.getLineContent(lineNumber);\n                if (lineContent.length === 0 || lineContent === prevContent || strings.firstNonWhitespaceIndex(lineContent) !== -1) {\n                    continue;\n                }\n                trimAutoWhitespaceLineNumbers.push(lineNumber);\n            }\n        }\n        this._onDidChangeContent.fire();\n        return new ApplyEditsResult(reverseOperations, contentChanges, trimAutoWhitespaceLineNumbers);\n    }\n    /**\n     * Transform operations such that they represent the same logic edit,\n     * but that they also do not cause OOM crashes.\n     */\n    _reduceOperations(operations) {\n        if (operations.length < 1000) {\n            // We know from empirical testing that a thousand edits work fine regardless of their shape.\n            return operations;\n        }\n        // At one point, due to how events are emitted and how each operation is handled,\n        // some operations can trigger a high amount of temporary string allocations,\n        // that will immediately get edited again.\n        // e.g. a formatter inserting ridiculous ammounts of \\n on a model with a single line\n        // Therefore, the strategy is to collapse all the operations into a huge single edit operation\n        return [this._toSingleEditOperation(operations)];\n    }\n    _toSingleEditOperation(operations) {\n        let forceMoveMarkers = false;\n        const firstEditRange = operations[0].range;\n        const lastEditRange = operations[operations.length - 1].range;\n        const entireEditRange = new Range(firstEditRange.startLineNumber, firstEditRange.startColumn, lastEditRange.endLineNumber, lastEditRange.endColumn);\n        let lastEndLineNumber = firstEditRange.startLineNumber;\n        let lastEndColumn = firstEditRange.startColumn;\n        const result = [];\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const operation = operations[i];\n            const range = operation.range;\n            forceMoveMarkers = forceMoveMarkers || operation.forceMoveMarkers;\n            // (1) -- Push old text\n            result.push(this.getValueInRange(new Range(lastEndLineNumber, lastEndColumn, range.startLineNumber, range.startColumn)));\n            // (2) -- Push new text\n            if (operation.text.length > 0) {\n                result.push(operation.text);\n            }\n            lastEndLineNumber = range.endLineNumber;\n            lastEndColumn = range.endColumn;\n        }\n        const text = result.join('');\n        const [eolCount, firstLineLength, lastLineLength] = countEOL(text);\n        return {\n            sortIndex: 0,\n            identifier: operations[0].identifier,\n            range: entireEditRange,\n            rangeOffset: this.getOffsetAt(entireEditRange.startLineNumber, entireEditRange.startColumn),\n            rangeLength: this.getValueLengthInRange(entireEditRange, 0 /* EndOfLinePreference.TextDefined */),\n            text: text,\n            eolCount: eolCount,\n            firstLineLength: firstLineLength,\n            lastLineLength: lastLineLength,\n            forceMoveMarkers: forceMoveMarkers,\n            isAutoWhitespaceEdit: false\n        };\n    }\n    _doApplyEdits(operations) {\n        operations.sort(PieceTreeTextBuffer._sortOpsDescending);\n        const contentChanges = [];\n        // operations are from bottom to top\n        for (let i = 0; i < operations.length; i++) {\n            const op = operations[i];\n            const startLineNumber = op.range.startLineNumber;\n            const startColumn = op.range.startColumn;\n            const endLineNumber = op.range.endLineNumber;\n            const endColumn = op.range.endColumn;\n            if (startLineNumber === endLineNumber && startColumn === endColumn && op.text.length === 0) {\n                // no-op\n                continue;\n            }\n            if (op.text) {\n                // replacement\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n                this._pieceTree.insert(op.rangeOffset, op.text, true);\n            }\n            else {\n                // deletion\n                this._pieceTree.delete(op.rangeOffset, op.rangeLength);\n            }\n            const contentChangeRange = new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            contentChanges.push({\n                range: contentChangeRange,\n                rangeLength: op.rangeLength,\n                text: op.text,\n                rangeOffset: op.rangeOffset,\n                forceMoveMarkers: op.forceMoveMarkers\n            });\n        }\n        return contentChanges;\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._pieceTree.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    /**\n     * Assumes `operations` are validated and sorted ascending\n     */\n    static _getInverseEditRanges(operations) {\n        const result = [];\n        let prevOpEndLineNumber = 0;\n        let prevOpEndColumn = 0;\n        let prevOp = null;\n        for (let i = 0, len = operations.length; i < len; i++) {\n            const op = operations[i];\n            let startLineNumber;\n            let startColumn;\n            if (prevOp) {\n                if (prevOp.range.endLineNumber === op.range.startLineNumber) {\n                    startLineNumber = prevOpEndLineNumber;\n                    startColumn = prevOpEndColumn + (op.range.startColumn - prevOp.range.endColumn);\n                }\n                else {\n                    startLineNumber = prevOpEndLineNumber + (op.range.startLineNumber - prevOp.range.endLineNumber);\n                    startColumn = op.range.startColumn;\n                }\n            }\n            else {\n                startLineNumber = op.range.startLineNumber;\n                startColumn = op.range.startColumn;\n            }\n            let resultRange;\n            if (op.text.length > 0) {\n                // the operation inserts something\n                const lineCount = op.eolCount + 1;\n                if (lineCount === 1) {\n                    // single line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn + op.firstLineLength);\n                }\n                else {\n                    // multi line insert\n                    resultRange = new Range(startLineNumber, startColumn, startLineNumber + lineCount - 1, op.lastLineLength + 1);\n                }\n            }\n            else {\n                // There is nothing to insert\n                resultRange = new Range(startLineNumber, startColumn, startLineNumber, startColumn);\n            }\n            prevOpEndLineNumber = resultRange.endLineNumber;\n            prevOpEndColumn = resultRange.endColumn;\n            result.push(resultRange);\n            prevOp = op;\n        }\n        return result;\n    }\n    static _sortOpsAscending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return a.sortIndex - b.sortIndex;\n        }\n        return r;\n    }\n    static _sortOpsDescending(a, b) {\n        const r = Range.compareRangesUsingEnds(a.range, b.range);\n        if (r === 0) {\n            return b.sortIndex - a.sortIndex;\n        }\n        return -r;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport { StringBuffer, createLineStarts, createLineStartsFast } from './pieceTreeBase.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer.js';\nclass PieceTreeTextBufferFactory {\n    constructor(_chunks, _bom, _cr, _lf, _crlf, _containsRTL, _containsUnusualLineTerminators, _isBasicASCII, _normalizeEOL) {\n        this._chunks = _chunks;\n        this._bom = _bom;\n        this._cr = _cr;\n        this._lf = _lf;\n        this._crlf = _crlf;\n        this._containsRTL = _containsRTL;\n        this._containsUnusualLineTerminators = _containsUnusualLineTerminators;\n        this._isBasicASCII = _isBasicASCII;\n        this._normalizeEOL = _normalizeEOL;\n    }\n    _getEOL(defaultEOL) {\n        const totalEOLCount = this._cr + this._lf + this._crlf;\n        const totalCRCount = this._cr + this._crlf;\n        if (totalEOLCount === 0) {\n            // This is an empty file or a file with precisely one line\n            return (defaultEOL === 1 /* DefaultEndOfLine.LF */ ? '\\n' : '\\r\\n');\n        }\n        if (totalCRCount > totalEOLCount / 2) {\n            // More than half of the file contains \\r\\n ending lines\n            return '\\r\\n';\n        }\n        // At least one line more ends in \\n\n        return '\\n';\n    }\n    create(defaultEOL) {\n        const eol = this._getEOL(defaultEOL);\n        const chunks = this._chunks;\n        if (this._normalizeEOL &&\n            ((eol === '\\r\\n' && (this._cr > 0 || this._lf > 0))\n                || (eol === '\\n' && (this._cr > 0 || this._crlf > 0)))) {\n            // Normalize pieces\n            for (let i = 0, len = chunks.length; i < len; i++) {\n                const str = chunks[i].buffer.replace(/\\r\\n|\\r|\\n/g, eol);\n                const newLineStart = createLineStartsFast(str);\n                chunks[i] = new StringBuffer(str, newLineStart);\n            }\n        }\n        const textBuffer = new PieceTreeTextBuffer(chunks, this._bom, eol, this._containsRTL, this._containsUnusualLineTerminators, this._isBasicASCII, this._normalizeEOL);\n        return { textBuffer: textBuffer, disposable: textBuffer };\n    }\n}\nexport class PieceTreeTextBufferBuilder {\n    constructor() {\n        this.chunks = [];\n        this.BOM = '';\n        this._hasPreviousChar = false;\n        this._previousChar = 0;\n        this._tmpLineStarts = [];\n        this.cr = 0;\n        this.lf = 0;\n        this.crlf = 0;\n        this.containsRTL = false;\n        this.containsUnusualLineTerminators = false;\n        this.isBasicASCII = true;\n    }\n    acceptChunk(chunk) {\n        if (chunk.length === 0) {\n            return;\n        }\n        if (this.chunks.length === 0) {\n            if (strings.startsWithUTF8BOM(chunk)) {\n                this.BOM = strings.UTF8_BOM_CHARACTER;\n                chunk = chunk.substr(1);\n            }\n        }\n        const lastChar = chunk.charCodeAt(chunk.length - 1);\n        if (lastChar === 13 /* CharCode.CarriageReturn */ || (lastChar >= 0xD800 && lastChar <= 0xDBFF)) {\n            // last character is \\r or a high surrogate => keep it back\n            this._acceptChunk1(chunk.substr(0, chunk.length - 1), false);\n            this._hasPreviousChar = true;\n            this._previousChar = lastChar;\n        }\n        else {\n            this._acceptChunk1(chunk, false);\n            this._hasPreviousChar = false;\n            this._previousChar = lastChar;\n        }\n    }\n    _acceptChunk1(chunk, allowEmptyStrings) {\n        if (!allowEmptyStrings && chunk.length === 0) {\n            // Nothing to do\n            return;\n        }\n        if (this._hasPreviousChar) {\n            this._acceptChunk2(String.fromCharCode(this._previousChar) + chunk);\n        }\n        else {\n            this._acceptChunk2(chunk);\n        }\n    }\n    _acceptChunk2(chunk) {\n        const lineStarts = createLineStarts(this._tmpLineStarts, chunk);\n        this.chunks.push(new StringBuffer(chunk, lineStarts.lineStarts));\n        this.cr += lineStarts.cr;\n        this.lf += lineStarts.lf;\n        this.crlf += lineStarts.crlf;\n        if (!lineStarts.isBasicASCII) {\n            // this chunk contains non basic ASCII characters\n            this.isBasicASCII = false;\n            if (!this.containsRTL) {\n                this.containsRTL = strings.containsRTL(chunk);\n            }\n            if (!this.containsUnusualLineTerminators) {\n                this.containsUnusualLineTerminators = strings.containsUnusualLineTerminators(chunk);\n            }\n        }\n    }\n    finish(normalizeEOL = true) {\n        this._finish();\n        return new PieceTreeTextBufferFactory(this.chunks, this.BOM, this.cr, this.lf, this.crlf, this.containsRTL, this.containsUnusualLineTerminators, this.isBasicASCII, normalizeEOL);\n    }\n    _finish() {\n        if (this.chunks.length === 0) {\n            this._acceptChunk1('', true);\n        }\n        if (this._hasPreviousChar) {\n            this._hasPreviousChar = false;\n            // recreate last chunk\n            const lastChunk = this.chunks[this.chunks.length - 1];\n            lastChunk.buffer += String.fromCharCode(this._previousChar);\n            const newLineStarts = createLineStartsFast(lastChunk.buffer);\n            lastChunk.lineStarts = newLineStarts;\n            if (this._previousChar === 13 /* CharCode.CarriageReturn */) {\n                this.cr++;\n            }\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { arrayInsert } from '../../../base/common/arrays.js';\n/**\n * An array that avoids being sparse by always\n * filling up unused indices with a default value.\n */\nexport class FixedArray {\n    constructor(_default) {\n        this._default = _default;\n        this._store = [];\n    }\n    get(index) {\n        if (index < this._store.length) {\n            return this._store[index];\n        }\n        return this._default;\n    }\n    set(index, value) {\n        while (index >= this._store.length) {\n            this._store[this._store.length] = this._default;\n        }\n        this._store[index] = value;\n    }\n    replace(index, oldLength, newLength) {\n        if (index >= this._store.length) {\n            return;\n        }\n        if (oldLength === 0) {\n            this.insert(index, newLength);\n            return;\n        }\n        else if (newLength === 0) {\n            this.delete(index, oldLength);\n            return;\n        }\n        const before = this._store.slice(0, index);\n        const after = this._store.slice(index + oldLength);\n        const insertArr = arrayFill(newLength, this._default);\n        this._store = before.concat(insertArr, after);\n    }\n    delete(deleteIndex, deleteCount) {\n        if (deleteCount === 0 || deleteIndex >= this._store.length) {\n            return;\n        }\n        this._store.splice(deleteIndex, deleteCount);\n    }\n    insert(insertIndex, insertCount) {\n        if (insertCount === 0 || insertIndex >= this._store.length) {\n            return;\n        }\n        const arr = [];\n        for (let i = 0; i < insertCount; i++) {\n            arr[i] = this._default;\n        }\n        this._store = arrayInsert(this._store, insertIndex, arr);\n    }\n}\nfunction arrayFill(length, value) {\n    const arr = [];\n    for (let i = 0; i < length; i++) {\n        arr[i] = value;\n    }\n    return arr;\n}\n","/**\n * Represents contiguous tokens over a contiguous range of lines.\n */\nexport class ContiguousMultilineTokens {\n    /**\n     * (Inclusive) start line number for these tokens.\n     */\n    get startLineNumber() {\n        return this._startLineNumber;\n    }\n    /**\n     * (Inclusive) end line number for these tokens.\n     */\n    get endLineNumber() {\n        return this._startLineNumber + this._tokens.length - 1;\n    }\n    constructor(startLineNumber, tokens) {\n        this._startLineNumber = startLineNumber;\n        this._tokens = tokens;\n    }\n    /**\n     * @see {@link _tokens}\n     */\n    getLineTokens(lineNumber) {\n        return this._tokens[lineNumber - this._startLineNumber];\n    }\n    appendLineTokens(lineTokens) {\n        this._tokens.push(lineTokens);\n    }\n}\n","import { ContiguousMultilineTokens } from './contiguousMultilineTokens.js';\nexport class ContiguousMultilineTokensBuilder {\n    constructor() {\n        this._tokens = [];\n    }\n    add(lineNumber, lineTokens) {\n        if (this._tokens.length > 0) {\n            const last = this._tokens[this._tokens.length - 1];\n            if (last.endLineNumber + 1 === lineNumber) {\n                // append\n                last.appendLineTokens(lineTokens);\n                return;\n            }\n        }\n        this._tokens.push(new ContiguousMultilineTokens(lineNumber, [lineTokens]));\n    }\n    finalize() {\n        return this._tokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { runWhenGlobalIdle } from '../../../base/common/async.js';\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { setTimeout0 } from '../../../base/common/platform.js';\nimport { StopWatch } from '../../../base/common/stopwatch.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { OffsetRange } from '../core/offsetRange.js';\nimport { nullTokenizeEncoded } from '../languages/nullTokenize.js';\nimport { FixedArray } from './fixedArray.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nexport class TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport) {\n        this.tokenizationSupport = tokenizationSupport;\n        this.initialState = this.tokenizationSupport.getInitialState();\n        this.store = new TrackingTokenizationStateStore(lineCount);\n    }\n    getStartState(lineNumber) {\n        return this.store.getStartState(lineNumber, this.initialState);\n    }\n    getFirstInvalidLine() {\n        return this.store.getFirstInvalidLine(this.initialState);\n    }\n}\nexport class TokenizerWithStateStoreAndTextModel extends TokenizerWithStateStore {\n    constructor(lineCount, tokenizationSupport, _textModel, _languageIdCodec) {\n        super(lineCount, tokenizationSupport);\n        this._textModel = _textModel;\n        this._languageIdCodec = _languageIdCodec;\n    }\n    updateTokensUntilLine(builder, lineNumber) {\n        const languageId = this._textModel.getLanguageId();\n        while (true) {\n            const lineToTokenize = this.getFirstInvalidLine();\n            if (!lineToTokenize || lineToTokenize.lineNumber > lineNumber) {\n                break;\n            }\n            const text = this._textModel.getLineContent(lineToTokenize.lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineToTokenize.startState);\n            builder.add(lineToTokenize.lineNumber, r.tokens);\n            this.store.setEndState(lineToTokenize.lineNumber, r.endState);\n        }\n    }\n    /** assumes state is up to date */\n    getTokenTypeIfInsertingCharacter(position, character) {\n        // TODO@hediet: use tokenizeLineWithEdit\n        const lineStartState = this.getStartState(position.lineNumber);\n        if (!lineStartState) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const languageId = this._textModel.getLanguageId();\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        // Create the text as if `character` was inserted\n        const text = (lineContent.substring(0, position.column - 1)\n            + character\n            + lineContent.substring(position.column - 1));\n        const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, lineStartState);\n        const lineTokens = new LineTokens(r.tokens, text, this._languageIdCodec);\n        if (lineTokens.getCount() === 0) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        return lineTokens.getStandardTokenType(tokenIndex);\n    }\n    /** assumes state is up to date */\n    tokenizeLineWithEdit(position, length, newText) {\n        const lineNumber = position.lineNumber;\n        const column = position.column;\n        const lineStartState = this.getStartState(lineNumber);\n        if (!lineStartState) {\n            return null;\n        }\n        const curLineContent = this._textModel.getLineContent(lineNumber);\n        const newLineContent = curLineContent.substring(0, column - 1)\n            + newText + curLineContent.substring(column - 1 + length);\n        const languageId = this._textModel.getLanguageIdAtPosition(lineNumber, 0);\n        const result = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, newLineContent, true, lineStartState);\n        const lineTokens = new LineTokens(result.tokens, newLineContent, this._languageIdCodec);\n        return lineTokens;\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        return (lineNumber < firstInvalidLineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        const firstInvalidLineNumber = this.store.getFirstInvalidEndStateLineNumberOrMax();\n        if (lineNumber < firstInvalidLineNumber) {\n            return true;\n        }\n        if (lineNumber === firstInvalidLineNumber\n            && this._textModel.getLineLength(lineNumber) < 2048 /* Constants.CHEAP_TOKENIZATION_LENGTH_LIMIT */) {\n            return true;\n        }\n        return false;\n    }\n    /**\n     * The result is not cached.\n     */\n    tokenizeHeuristically(builder, startLineNumber, endLineNumber) {\n        if (endLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // nothing to do\n            return { heuristicTokens: false };\n        }\n        if (startLineNumber <= this.store.getFirstInvalidEndStateLineNumberOrMax()) {\n            // tokenization has reached the viewport start...\n            this.updateTokensUntilLine(builder, endLineNumber);\n            return { heuristicTokens: false };\n        }\n        let state = this.guessStartState(startLineNumber);\n        const languageId = this._textModel.getLanguageId();\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const text = this._textModel.getLineContent(lineNumber);\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, text, true, state);\n            builder.add(lineNumber, r.tokens);\n            state = r.endState;\n        }\n        return { heuristicTokens: true };\n    }\n    guessStartState(lineNumber) {\n        let nonWhitespaceColumn = this._textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n        const likelyRelevantLines = [];\n        let initialState = null;\n        for (let i = lineNumber - 1; nonWhitespaceColumn > 1 && i >= 1; i--) {\n            const newNonWhitespaceIndex = this._textModel.getLineFirstNonWhitespaceColumn(i);\n            // Ignore lines full of whitespace\n            if (newNonWhitespaceIndex === 0) {\n                continue;\n            }\n            if (newNonWhitespaceIndex < nonWhitespaceColumn) {\n                likelyRelevantLines.push(this._textModel.getLineContent(i));\n                nonWhitespaceColumn = newNonWhitespaceIndex;\n                initialState = this.getStartState(i);\n                if (initialState) {\n                    break;\n                }\n            }\n        }\n        if (!initialState) {\n            initialState = this.tokenizationSupport.getInitialState();\n        }\n        likelyRelevantLines.reverse();\n        const languageId = this._textModel.getLanguageId();\n        let state = initialState;\n        for (const line of likelyRelevantLines) {\n            const r = safeTokenize(this._languageIdCodec, languageId, this.tokenizationSupport, line, false, state);\n            state = r.endState;\n        }\n        return state;\n    }\n}\n/**\n * **Invariant:**\n * If the text model is retokenized from line 1 to {@link getFirstInvalidEndStateLineNumber}() - 1,\n * then the recomputed end state for line l will be equal to {@link getEndState}(l).\n */\nexport class TrackingTokenizationStateStore {\n    constructor(lineCount) {\n        this.lineCount = lineCount;\n        this._tokenizationStateStore = new TokenizationStateStore();\n        this._invalidEndStatesLineNumbers = new RangePriorityQueueImpl();\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(1, lineCount + 1));\n    }\n    getEndState(lineNumber) {\n        return this._tokenizationStateStore.getEndState(lineNumber);\n    }\n    /**\n     * @returns if the end state has changed.\n     */\n    setEndState(lineNumber, state) {\n        if (!state) {\n            throw new BugIndicatingError('Cannot set null/undefined state');\n        }\n        this._invalidEndStatesLineNumbers.delete(lineNumber);\n        const r = this._tokenizationStateStore.setEndState(lineNumber, state);\n        if (r && lineNumber < this.lineCount) {\n            // because the state changed, we cannot trust the next state anymore and have to invalidate it.\n            this._invalidEndStatesLineNumbers.addRange(new OffsetRange(lineNumber + 1, lineNumber + 2));\n        }\n        return r;\n    }\n    acceptChange(range, newLineCount) {\n        this.lineCount += newLineCount - range.length;\n        this._tokenizationStateStore.acceptChange(range, newLineCount);\n        this._invalidEndStatesLineNumbers.addRangeAndResize(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive), newLineCount);\n    }\n    acceptChanges(changes) {\n        for (const c of changes) {\n            const [eolCount] = countEOL(c.text);\n            this.acceptChange(new LineRange(c.range.startLineNumber, c.range.endLineNumber + 1), eolCount + 1);\n        }\n    }\n    invalidateEndStateRange(range) {\n        this._invalidEndStatesLineNumbers.addRange(new OffsetRange(range.startLineNumber, range.endLineNumberExclusive));\n    }\n    getFirstInvalidEndStateLineNumber() { return this._invalidEndStatesLineNumbers.min; }\n    getFirstInvalidEndStateLineNumberOrMax() {\n        return this.getFirstInvalidEndStateLineNumber() || Number.MAX_SAFE_INTEGER;\n    }\n    allStatesValid() { return this._invalidEndStatesLineNumbers.min === null; }\n    getStartState(lineNumber, initialState) {\n        if (lineNumber === 1) {\n            return initialState;\n        }\n        return this.getEndState(lineNumber - 1);\n    }\n    getFirstInvalidLine(initialState) {\n        const lineNumber = this.getFirstInvalidEndStateLineNumber();\n        if (lineNumber === null) {\n            return null;\n        }\n        const startState = this.getStartState(lineNumber, initialState);\n        if (!startState) {\n            throw new BugIndicatingError('Start state must be defined');\n        }\n        return { lineNumber, startState };\n    }\n}\nexport class TokenizationStateStore {\n    constructor() {\n        this._lineEndStates = new FixedArray(null);\n    }\n    getEndState(lineNumber) {\n        return this._lineEndStates.get(lineNumber);\n    }\n    setEndState(lineNumber, state) {\n        const oldState = this._lineEndStates.get(lineNumber);\n        if (oldState && oldState.equals(state)) {\n            return false;\n        }\n        this._lineEndStates.set(lineNumber, state);\n        return true;\n    }\n    acceptChange(range, newLineCount) {\n        let length = range.length;\n        if (newLineCount > 0 && length > 0) {\n            // Keep the last state, even though it is unrelated.\n            // But if the new state happens to agree with this last state, then we know we can stop tokenizing.\n            length--;\n            newLineCount--;\n        }\n        this._lineEndStates.replace(range.startLineNumber, length, newLineCount);\n    }\n}\nexport class RangePriorityQueueImpl {\n    constructor() {\n        this._ranges = [];\n    }\n    get min() {\n        if (this._ranges.length === 0) {\n            return null;\n        }\n        return this._ranges[0].start;\n    }\n    delete(value) {\n        const idx = this._ranges.findIndex(r => r.contains(value));\n        if (idx !== -1) {\n            const range = this._ranges[idx];\n            if (range.start === value) {\n                if (range.endExclusive === value + 1) {\n                    this._ranges.splice(idx, 1);\n                }\n                else {\n                    this._ranges[idx] = new OffsetRange(value + 1, range.endExclusive);\n                }\n            }\n            else {\n                if (range.endExclusive === value + 1) {\n                    this._ranges[idx] = new OffsetRange(range.start, value);\n                }\n                else {\n                    this._ranges.splice(idx, 1, new OffsetRange(range.start, value), new OffsetRange(value + 1, range.endExclusive));\n                }\n            }\n        }\n    }\n    addRange(range) {\n        OffsetRange.addRange(range, this._ranges);\n    }\n    addRangeAndResize(range, newLength) {\n        let idxFirstMightBeIntersecting = 0;\n        while (!(idxFirstMightBeIntersecting >= this._ranges.length || range.start <= this._ranges[idxFirstMightBeIntersecting].endExclusive)) {\n            idxFirstMightBeIntersecting++;\n        }\n        let idxFirstIsAfter = idxFirstMightBeIntersecting;\n        while (!(idxFirstIsAfter >= this._ranges.length || range.endExclusive < this._ranges[idxFirstIsAfter].start)) {\n            idxFirstIsAfter++;\n        }\n        const delta = newLength - range.length;\n        for (let i = idxFirstIsAfter; i < this._ranges.length; i++) {\n            this._ranges[i] = this._ranges[i].delta(delta);\n        }\n        if (idxFirstMightBeIntersecting === idxFirstIsAfter) {\n            const newRange = new OffsetRange(range.start, range.start + newLength);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, 0, newRange);\n            }\n        }\n        else {\n            const start = Math.min(range.start, this._ranges[idxFirstMightBeIntersecting].start);\n            const endEx = Math.max(range.endExclusive, this._ranges[idxFirstIsAfter - 1].endExclusive);\n            const newRange = new OffsetRange(start, endEx + delta);\n            if (!newRange.isEmpty) {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting, newRange);\n            }\n            else {\n                this._ranges.splice(idxFirstMightBeIntersecting, idxFirstIsAfter - idxFirstMightBeIntersecting);\n            }\n        }\n    }\n    toString() {\n        return this._ranges.map(r => r.toString()).join(' + ');\n    }\n}\nfunction safeTokenize(languageIdCodec, languageId, tokenizationSupport, text, hasEOL, state) {\n    let r = null;\n    if (tokenizationSupport) {\n        try {\n            r = tokenizationSupport.tokenizeEncoded(text, hasEOL, state.clone());\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n    }\n    if (!r) {\n        r = nullTokenizeEncoded(languageIdCodec.encodeLanguageId(languageId), state);\n    }\n    LineTokens.convertToEndOffset(r.tokens, text.length);\n    return r;\n}\nexport class DefaultBackgroundTokenizer {\n    constructor(_tokenizerWithStateStore, _backgroundTokenStore) {\n        this._tokenizerWithStateStore = _tokenizerWithStateStore;\n        this._backgroundTokenStore = _backgroundTokenStore;\n        this._isDisposed = false;\n        this._isScheduled = false;\n    }\n    dispose() {\n        this._isDisposed = true;\n    }\n    handleChanges() {\n        this._beginBackgroundTokenization();\n    }\n    _beginBackgroundTokenization() {\n        if (this._isScheduled || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n            return;\n        }\n        this._isScheduled = true;\n        runWhenGlobalIdle((deadline) => {\n            this._isScheduled = false;\n            this._backgroundTokenizeWithDeadline(deadline);\n        });\n    }\n    /**\n     * Tokenize until the deadline occurs, but try to yield every 1-2ms.\n     */\n    _backgroundTokenizeWithDeadline(deadline) {\n        // Read the time remaining from the `deadline` immediately because it is unclear\n        // if the `deadline` object will be valid after execution leaves this function.\n        const endTime = Date.now() + deadline.timeRemaining();\n        const execute = () => {\n            if (this._isDisposed || !this._tokenizerWithStateStore._textModel.isAttachedToEditor() || !this._hasLinesToTokenize()) {\n                // disposed in the meantime or detached or finished\n                return;\n            }\n            this._backgroundTokenizeForAtLeast1ms();\n            if (Date.now() < endTime) {\n                // There is still time before reaching the deadline, so yield to the browser and then\n                // continue execution\n                setTimeout0(execute);\n            }\n            else {\n                // The deadline has been reached, so schedule a new idle callback if necessary\n                this._beginBackgroundTokenization();\n            }\n        };\n        execute();\n    }\n    /**\n     * Tokenize for at least 1ms.\n     */\n    _backgroundTokenizeForAtLeast1ms() {\n        const lineCount = this._tokenizerWithStateStore._textModel.getLineCount();\n        const builder = new ContiguousMultilineTokensBuilder();\n        const sw = StopWatch.create(false);\n        do {\n            if (sw.elapsed() > 1) {\n                // the comparison is intentionally > 1 and not >= 1 to ensure that\n                // a full millisecond has elapsed, given how microseconds are rounded\n                // to milliseconds\n                break;\n            }\n            const tokenizedLineNumber = this._tokenizeOneInvalidLine(builder);\n            if (tokenizedLineNumber >= lineCount) {\n                break;\n            }\n        } while (this._hasLinesToTokenize());\n        this._backgroundTokenStore.setTokens(builder.finalize());\n        this.checkFinished();\n    }\n    _hasLinesToTokenize() {\n        if (!this._tokenizerWithStateStore) {\n            return false;\n        }\n        return !this._tokenizerWithStateStore.store.allStatesValid();\n    }\n    _tokenizeOneInvalidLine(builder) {\n        const firstInvalidLine = this._tokenizerWithStateStore?.getFirstInvalidLine();\n        if (!firstInvalidLine) {\n            return this._tokenizerWithStateStore._textModel.getLineCount() + 1;\n        }\n        this._tokenizerWithStateStore.updateTokensUntilLine(builder, firstInvalidLine.lineNumber);\n        return firstInvalidLine.lineNumber;\n    }\n    checkFinished() {\n        if (this._isDisposed) {\n            return;\n        }\n        if (this._tokenizerWithStateStore.store.allStatesValid()) {\n            this._backgroundTokenStore.backgroundTokenizationFinished();\n        }\n    }\n    requestTokens(startLineNumber, endLineNumberExclusive) {\n        this._tokenizerWithStateStore.store.invalidateEndStateRange(new LineRange(startLineNumber, endLineNumberExclusive));\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { equals } from '../../../base/common/arrays.js';\nimport { RunOnceScheduler } from '../../../base/common/async.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable } from '../../../base/common/lifecycle.js';\nimport { LineRange } from '../core/lineRange.js';\n/**\n * @internal\n */\nexport class AttachedViews {\n    constructor() {\n        this._onDidChangeVisibleRanges = new Emitter();\n        this.onDidChangeVisibleRanges = this._onDidChangeVisibleRanges.event;\n        this._views = new Set();\n    }\n    attachView() {\n        const view = new AttachedViewImpl((state) => {\n            this._onDidChangeVisibleRanges.fire({ view, state });\n        });\n        this._views.add(view);\n        return view;\n    }\n    detachView(view) {\n        this._views.delete(view);\n        this._onDidChangeVisibleRanges.fire({ view, state: undefined });\n    }\n}\nclass AttachedViewImpl {\n    constructor(handleStateChange) {\n        this.handleStateChange = handleStateChange;\n    }\n    setVisibleLines(visibleLines, stabilized) {\n        const visibleLineRanges = visibleLines.map((line) => new LineRange(line.startLineNumber, line.endLineNumber + 1));\n        this.handleStateChange({ visibleLineRanges, stabilized });\n    }\n}\nexport class AttachedViewHandler extends Disposable {\n    get lineRanges() { return this._lineRanges; }\n    constructor(_refreshTokens) {\n        super();\n        this._refreshTokens = _refreshTokens;\n        this.runner = this._register(new RunOnceScheduler(() => this.update(), 50));\n        this._computedLineRanges = [];\n        this._lineRanges = [];\n    }\n    update() {\n        if (equals(this._computedLineRanges, this._lineRanges, (a, b) => a.equals(b))) {\n            return;\n        }\n        this._computedLineRanges = this._lineRanges;\n        this._refreshTokens();\n    }\n    handleStateChange(state) {\n        this._lineRanges = state.visibleLineRanges;\n        if (state.stabilized) {\n            this.runner.cancel();\n            this.update();\n        }\n        else {\n            this.runner.schedule();\n        }\n    }\n}\nexport class AbstractTokens extends Disposable {\n    get backgroundTokenizationState() {\n        return this._backgroundTokenizationState;\n    }\n    constructor(_languageIdCodec, _textModel, getLanguageId) {\n        super();\n        this._languageIdCodec = _languageIdCodec;\n        this._textModel = _textModel;\n        this.getLanguageId = getLanguageId;\n        this._backgroundTokenizationState = 1 /* BackgroundTokenizationState.InProgress */;\n        this._onDidChangeBackgroundTokenizationState = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeBackgroundTokenizationState = this._onDidChangeBackgroundTokenizationState.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        /** @internal, should not be exposed by the text model! */\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n    }\n    tokenizeIfCheap(lineNumber) {\n        if (this.isCheapToTokenize(lineNumber)) {\n            this.forceTokenization(lineNumber);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TreeSitterTokenizationRegistry } from '../languages.js';\nimport { LineTokens } from '../tokens/lineTokens.js';\nimport { AbstractTokens } from './tokens.js';\nexport class TreeSitterTokens extends AbstractTokens {\n    constructor(_treeSitterService, languageIdCodec, textModel, languageId) {\n        super(languageIdCodec, textModel, languageId);\n        this._treeSitterService = _treeSitterService;\n        this._tokenizationSupport = null;\n        this._initialize();\n    }\n    _initialize() {\n        const newLanguage = this.getLanguageId();\n        if (!this._tokenizationSupport || this._lastLanguageId !== newLanguage) {\n            this._lastLanguageId = newLanguage;\n            this._tokenizationSupport = TreeSitterTokenizationRegistry.get(newLanguage);\n        }\n    }\n    getLineTokens(lineNumber) {\n        const content = this._textModel.getLineContent(lineNumber);\n        if (this._tokenizationSupport) {\n            const rawTokens = this._tokenizationSupport.tokenizeEncoded(lineNumber, this._textModel);\n            if (rawTokens) {\n                return new LineTokens(rawTokens, content, this._languageIdCodec);\n            }\n        }\n        return LineTokens.createEmpty(content, this._languageIdCodec);\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        this._initialize();\n    }\n    handleDidChangeAttached() {\n        // TODO @alexr00 implement for background tokenization\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n    }\n    forceTokenization(lineNumber) {\n        // TODO @alexr00 implement\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    isCheapToTokenize(lineNumber) {\n        // TODO @alexr00 update for background tokenization\n        return true;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        // TODO @alexr00 implement once we have custom parsing and don't just feed in the whole text model value\n        return 0 /* StandardTokenType.Other */;\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        // TODO @alexr00 understand what this is for and implement\n        return null;\n    }\n    get hasTokens() {\n        // TODO @alexr00 once we have a token store, implement properly\n        const hasTree = this._treeSitterService.getParseResult(this._textModel) !== undefined;\n        return hasTree;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { LineTokens } from './lineTokens.js';\nexport const EMPTY_LINE_TOKENS = (new Uint32Array(0)).buffer;\nexport class ContiguousTokensEditing {\n    static deleteBeginning(lineTokens, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        return ContiguousTokensEditing.delete(lineTokens, 0, toChIndex);\n    }\n    static deleteEnding(lineTokens, fromChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const lineTextLength = tokens[tokens.length - 2];\n        return ContiguousTokensEditing.delete(lineTokens, fromChIndex, lineTextLength);\n    }\n    static delete(lineTokens, fromChIndex, toChIndex) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS || fromChIndex === toChIndex) {\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        // special case: deleting everything\n        if (fromChIndex === 0 && tokens[tokens.length - 2] === toChIndex) {\n            return EMPTY_LINE_TOKENS;\n        }\n        const fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, fromChIndex);\n        const fromTokenStartOffset = (fromTokenIndex > 0 ? tokens[(fromTokenIndex - 1) << 1] : 0);\n        const fromTokenEndOffset = tokens[fromTokenIndex << 1];\n        if (toChIndex < fromTokenEndOffset) {\n            // the delete range is inside a single token\n            const delta = (toChIndex - fromChIndex);\n            for (let i = fromTokenIndex; i < tokensCount; i++) {\n                tokens[i << 1] -= delta;\n            }\n            return lineTokens;\n        }\n        let dest;\n        let lastEnd;\n        if (fromTokenStartOffset !== fromChIndex) {\n            tokens[fromTokenIndex << 1] = fromChIndex;\n            dest = ((fromTokenIndex + 1) << 1);\n            lastEnd = fromChIndex;\n        }\n        else {\n            dest = (fromTokenIndex << 1);\n            lastEnd = fromTokenStartOffset;\n        }\n        const delta = (toChIndex - fromChIndex);\n        for (let tokenIndex = fromTokenIndex + 1; tokenIndex < tokensCount; tokenIndex++) {\n            const tokenEndOffset = tokens[tokenIndex << 1] - delta;\n            if (tokenEndOffset > lastEnd) {\n                tokens[dest++] = tokenEndOffset;\n                tokens[dest++] = tokens[(tokenIndex << 1) + 1];\n                lastEnd = tokenEndOffset;\n            }\n        }\n        if (dest === tokens.length) {\n            // nothing to trim\n            return lineTokens;\n        }\n        const tmp = new Uint32Array(dest);\n        tmp.set(tokens.subarray(0, dest), 0);\n        return tmp.buffer;\n    }\n    static append(lineTokens, _otherTokens) {\n        if (_otherTokens === EMPTY_LINE_TOKENS) {\n            return lineTokens;\n        }\n        if (lineTokens === EMPTY_LINE_TOKENS) {\n            return _otherTokens;\n        }\n        if (lineTokens === null) {\n            return lineTokens;\n        }\n        if (_otherTokens === null) {\n            // cannot determine combined line length...\n            return null;\n        }\n        const myTokens = toUint32Array(lineTokens);\n        const otherTokens = toUint32Array(_otherTokens);\n        const otherTokensCount = (otherTokens.length >>> 1);\n        const result = new Uint32Array(myTokens.length + otherTokens.length);\n        result.set(myTokens, 0);\n        let dest = myTokens.length;\n        const delta = myTokens[myTokens.length - 2];\n        for (let i = 0; i < otherTokensCount; i++) {\n            result[dest++] = otherTokens[(i << 1)] + delta;\n            result[dest++] = otherTokens[(i << 1) + 1];\n        }\n        return result.buffer;\n    }\n    static insert(lineTokens, chIndex, textLength) {\n        if (lineTokens === null || lineTokens === EMPTY_LINE_TOKENS) {\n            // nothing to do\n            return lineTokens;\n        }\n        const tokens = toUint32Array(lineTokens);\n        const tokensCount = (tokens.length >>> 1);\n        let fromTokenIndex = LineTokens.findIndexInTokensArray(tokens, chIndex);\n        if (fromTokenIndex > 0) {\n            const fromTokenStartOffset = tokens[(fromTokenIndex - 1) << 1];\n            if (fromTokenStartOffset === chIndex) {\n                fromTokenIndex--;\n            }\n        }\n        for (let tokenIndex = fromTokenIndex; tokenIndex < tokensCount; tokenIndex++) {\n            tokens[tokenIndex << 1] += textLength;\n        }\n        return lineTokens;\n    }\n}\nexport function toUint32Array(arr) {\n    if (arr instanceof Uint32Array) {\n        return arr;\n    }\n    else {\n        return new Uint32Array(arr);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { Position } from '../core/position.js';\nimport { ContiguousTokensEditing, EMPTY_LINE_TOKENS, toUint32Array } from './contiguousTokensEditing.js';\nimport { LineTokens } from './lineTokens.js';\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\n/**\n * Represents contiguous tokens in a text model.\n */\nexport class ContiguousTokensStore {\n    constructor(languageIdCodec) {\n        this._lineTokens = [];\n        this._len = 0;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._lineTokens = [];\n        this._len = 0;\n    }\n    get hasTokens() {\n        return this._lineTokens.length > 0;\n    }\n    getTokens(topLevelLanguageId, lineIndex, lineText) {\n        let rawLineTokens = null;\n        if (lineIndex < this._len) {\n            rawLineTokens = this._lineTokens[lineIndex];\n        }\n        if (rawLineTokens !== null && rawLineTokens !== EMPTY_LINE_TOKENS) {\n            return new LineTokens(toUint32Array(rawLineTokens), lineText, this._languageIdCodec);\n        }\n        const lineTokens = new Uint32Array(2);\n        lineTokens[0] = lineText.length;\n        lineTokens[1] = getDefaultMetadata(this._languageIdCodec.encodeLanguageId(topLevelLanguageId));\n        return new LineTokens(lineTokens, lineText, this._languageIdCodec);\n    }\n    static _massageTokens(topLevelLanguageId, lineTextLength, _tokens) {\n        const tokens = _tokens ? toUint32Array(_tokens) : null;\n        if (lineTextLength === 0) {\n            let hasDifferentLanguageId = false;\n            if (tokens && tokens.length > 1) {\n                hasDifferentLanguageId = (TokenMetadata.getLanguageId(tokens[1]) !== topLevelLanguageId);\n            }\n            if (!hasDifferentLanguageId) {\n                return EMPTY_LINE_TOKENS;\n            }\n        }\n        if (!tokens || tokens.length === 0) {\n            const tokens = new Uint32Array(2);\n            tokens[0] = lineTextLength;\n            tokens[1] = getDefaultMetadata(topLevelLanguageId);\n            return tokens.buffer;\n        }\n        // Ensure the last token covers the end of the text\n        tokens[tokens.length - 2] = lineTextLength;\n        if (tokens.byteOffset === 0 && tokens.byteLength === tokens.buffer.byteLength) {\n            // Store directly the ArrayBuffer pointer to save an object\n            return tokens.buffer;\n        }\n        return tokens;\n    }\n    _ensureLine(lineIndex) {\n        while (lineIndex >= this._len) {\n            this._lineTokens[this._len] = null;\n            this._len++;\n        }\n    }\n    _deleteLines(start, deleteCount) {\n        if (deleteCount === 0) {\n            return;\n        }\n        if (start + deleteCount > this._len) {\n            deleteCount = this._len - start;\n        }\n        this._lineTokens.splice(start, deleteCount);\n        this._len -= deleteCount;\n    }\n    _insertLines(insertIndex, insertCount) {\n        if (insertCount === 0) {\n            return;\n        }\n        const lineTokens = [];\n        for (let i = 0; i < insertCount; i++) {\n            lineTokens[i] = null;\n        }\n        this._lineTokens = arrays.arrayInsert(this._lineTokens, insertIndex, lineTokens);\n        this._len += insertCount;\n    }\n    setTokens(topLevelLanguageId, lineIndex, lineTextLength, _tokens, checkEquality) {\n        const tokens = ContiguousTokensStore._massageTokens(this._languageIdCodec.encodeLanguageId(topLevelLanguageId), lineTextLength, _tokens);\n        this._ensureLine(lineIndex);\n        const oldTokens = this._lineTokens[lineIndex];\n        this._lineTokens[lineIndex] = tokens;\n        if (checkEquality) {\n            return !ContiguousTokensStore._equals(oldTokens, tokens);\n        }\n        return false;\n    }\n    static _equals(_a, _b) {\n        if (!_a || !_b) {\n            return !_a && !_b;\n        }\n        const a = toUint32Array(_a);\n        const b = toUint32Array(_b);\n        if (a.length !== b.length) {\n            return false;\n        }\n        for (let i = 0, len = a.length; i < len; i++) {\n            if (a[i] !== b[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    //#region Editing\n    acceptEdit(range, eolCount, firstLineLength) {\n        this._acceptDeleteRange(range);\n        this._acceptInsertText(new Position(range.startLineNumber, range.startColumn), eolCount, firstLineLength);\n    }\n    _acceptDeleteRange(range) {\n        const firstLineIndex = range.startLineNumber - 1;\n        if (firstLineIndex >= this._len) {\n            return;\n        }\n        if (range.startLineNumber === range.endLineNumber) {\n            if (range.startColumn === range.endColumn) {\n                // Nothing to delete\n                return;\n            }\n            this._lineTokens[firstLineIndex] = ContiguousTokensEditing.delete(this._lineTokens[firstLineIndex], range.startColumn - 1, range.endColumn - 1);\n            return;\n        }\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[firstLineIndex], range.startColumn - 1);\n        const lastLineIndex = range.endLineNumber - 1;\n        let lastLineTokens = null;\n        if (lastLineIndex < this._len) {\n            lastLineTokens = ContiguousTokensEditing.deleteBeginning(this._lineTokens[lastLineIndex], range.endColumn - 1);\n        }\n        // Take remaining text on last line and append it to remaining text on first line\n        this._lineTokens[firstLineIndex] = ContiguousTokensEditing.append(this._lineTokens[firstLineIndex], lastLineTokens);\n        // Delete middle lines\n        this._deleteLines(range.startLineNumber, range.endLineNumber - range.startLineNumber);\n    }\n    _acceptInsertText(position, eolCount, firstLineLength) {\n        if (eolCount === 0 && firstLineLength === 0) {\n            // Nothing to insert\n            return;\n        }\n        const lineIndex = position.lineNumber - 1;\n        if (lineIndex >= this._len) {\n            return;\n        }\n        if (eolCount === 0) {\n            // Inserting text on one line\n            this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n            return;\n        }\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.deleteEnding(this._lineTokens[lineIndex], position.column - 1);\n        this._lineTokens[lineIndex] = ContiguousTokensEditing.insert(this._lineTokens[lineIndex], position.column - 1, firstLineLength);\n        this._insertLines(position.lineNumber, eolCount);\n    }\n    //#endregion\n    setMultilineTokens(tokens, textModel) {\n        if (tokens.length === 0) {\n            return { changes: [] };\n        }\n        const ranges = [];\n        for (let i = 0, len = tokens.length; i < len; i++) {\n            const element = tokens[i];\n            let minChangedLineNumber = 0;\n            let maxChangedLineNumber = 0;\n            let hasChange = false;\n            for (let lineNumber = element.startLineNumber; lineNumber <= element.endLineNumber; lineNumber++) {\n                if (hasChange) {\n                    this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), false);\n                    maxChangedLineNumber = lineNumber;\n                }\n                else {\n                    const lineHasChange = this.setTokens(textModel.getLanguageId(), lineNumber - 1, textModel.getLineLength(lineNumber), element.getLineTokens(lineNumber), true);\n                    if (lineHasChange) {\n                        hasChange = true;\n                        minChangedLineNumber = lineNumber;\n                        maxChangedLineNumber = lineNumber;\n                    }\n                }\n            }\n            if (hasChange) {\n                ranges.push({ fromLineNumber: minChangedLineNumber, toLineNumber: maxChangedLineNumber, });\n            }\n        }\n        return { changes: ranges };\n    }\n}\nfunction getDefaultMetadata(topLevelLanguageId) {\n    return ((topLevelLanguageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)\n        // If there is no grammar, we just take a guess and try to match brackets.\n        | (1024 /* MetadataConsts.BALANCED_BRACKETS_MASK */)) >>> 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as arrays from '../../../base/common/arrays.js';\nimport { LineTokens } from './lineTokens.js';\n/**\n * Represents sparse tokens in a text model.\n */\nexport class SparseTokensStore {\n    constructor(languageIdCodec) {\n        this._pieces = [];\n        this._isComplete = false;\n        this._languageIdCodec = languageIdCodec;\n    }\n    flush() {\n        this._pieces = [];\n        this._isComplete = false;\n    }\n    isEmpty() {\n        return (this._pieces.length === 0);\n    }\n    set(pieces, isComplete) {\n        this._pieces = pieces || [];\n        this._isComplete = isComplete;\n    }\n    setPartial(_range, pieces) {\n        // console.log(`setPartial ${_range} ${pieces.map(p => p.toString()).join(', ')}`);\n        let range = _range;\n        if (pieces.length > 0) {\n            const _firstRange = pieces[0].getRange();\n            const _lastRange = pieces[pieces.length - 1].getRange();\n            if (!_firstRange || !_lastRange) {\n                return _range;\n            }\n            range = _range.plusRange(_firstRange).plusRange(_lastRange);\n        }\n        let insertPosition = null;\n        for (let i = 0, len = this._pieces.length; i < len; i++) {\n            const piece = this._pieces[i];\n            if (piece.endLineNumber < range.startLineNumber) {\n                // this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // this piece is after the range, so mark the spot before this piece\n                // as a good insertion position and stop looping\n                insertPosition = insertPosition || { index: i };\n                break;\n            }\n            // this piece might intersect with the range\n            piece.removeTokens(range);\n            if (piece.isEmpty()) {\n                // remove the piece if it became empty\n                this._pieces.splice(i, 1);\n                i--;\n                len--;\n                continue;\n            }\n            if (piece.endLineNumber < range.startLineNumber) {\n                // after removal, this piece is before the range\n                continue;\n            }\n            if (piece.startLineNumber > range.endLineNumber) {\n                // after removal, this piece is after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            // after removal, this piece contains the range\n            const [a, b] = piece.split(range);\n            if (a.isEmpty()) {\n                // this piece is actually after the range\n                insertPosition = insertPosition || { index: i };\n                continue;\n            }\n            if (b.isEmpty()) {\n                // this piece is actually before the range\n                continue;\n            }\n            this._pieces.splice(i, 1, a, b);\n            i++;\n            len++;\n            insertPosition = insertPosition || { index: i };\n        }\n        insertPosition = insertPosition || { index: this._pieces.length };\n        if (pieces.length > 0) {\n            this._pieces = arrays.arrayInsert(this._pieces, insertPosition.index, pieces);\n        }\n        // console.log(`I HAVE ${this._pieces.length} pieces`);\n        // console.log(`${this._pieces.map(p => p.toString()).join('\\n')}`);\n        return range;\n    }\n    isComplete() {\n        return this._isComplete;\n    }\n    addSparseTokens(lineNumber, aTokens) {\n        if (aTokens.getLineContent().length === 0) {\n            // Don't do anything for empty lines\n            return aTokens;\n        }\n        const pieces = this._pieces;\n        if (pieces.length === 0) {\n            return aTokens;\n        }\n        const pieceIndex = SparseTokensStore._findFirstPieceWithLine(pieces, lineNumber);\n        const bTokens = pieces[pieceIndex].getLineTokens(lineNumber);\n        if (!bTokens) {\n            return aTokens;\n        }\n        const aLen = aTokens.getCount();\n        const bLen = bTokens.getCount();\n        let aIndex = 0;\n        const result = [];\n        let resultLen = 0;\n        let lastEndOffset = 0;\n        const emitToken = (endOffset, metadata) => {\n            if (endOffset === lastEndOffset) {\n                return;\n            }\n            lastEndOffset = endOffset;\n            result[resultLen++] = endOffset;\n            result[resultLen++] = metadata;\n        };\n        for (let bIndex = 0; bIndex < bLen; bIndex++) {\n            const bStartCharacter = bTokens.getStartCharacter(bIndex);\n            const bEndCharacter = bTokens.getEndCharacter(bIndex);\n            const bMetadata = bTokens.getMetadata(bIndex);\n            const bMask = (((bMetadata & 1 /* MetadataConsts.SEMANTIC_USE_ITALIC */) ? 2048 /* MetadataConsts.ITALIC_MASK */ : 0)\n                | ((bMetadata & 2 /* MetadataConsts.SEMANTIC_USE_BOLD */) ? 4096 /* MetadataConsts.BOLD_MASK */ : 0)\n                | ((bMetadata & 4 /* MetadataConsts.SEMANTIC_USE_UNDERLINE */) ? 8192 /* MetadataConsts.UNDERLINE_MASK */ : 0)\n                | ((bMetadata & 8 /* MetadataConsts.SEMANTIC_USE_STRIKETHROUGH */) ? 16384 /* MetadataConsts.STRIKETHROUGH_MASK */ : 0)\n                | ((bMetadata & 16 /* MetadataConsts.SEMANTIC_USE_FOREGROUND */) ? 16744448 /* MetadataConsts.FOREGROUND_MASK */ : 0)\n                | ((bMetadata & 32 /* MetadataConsts.SEMANTIC_USE_BACKGROUND */) ? 4278190080 /* MetadataConsts.BACKGROUND_MASK */ : 0)) >>> 0;\n            const aMask = (~bMask) >>> 0;\n            // push any token from `a` that is before `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) <= bStartCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n                aIndex++;\n            }\n            // push the token from `a` if it intersects the token from `b`\n            if (aIndex < aLen && aTokens.getStartOffset(aIndex) < bStartCharacter) {\n                emitToken(bStartCharacter, aTokens.getMetadata(aIndex));\n            }\n            // skip any tokens from `a` that are contained inside `b`\n            while (aIndex < aLen && aTokens.getEndOffset(aIndex) < bEndCharacter) {\n                emitToken(aTokens.getEndOffset(aIndex), (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                aIndex++;\n            }\n            if (aIndex < aLen) {\n                emitToken(bEndCharacter, (aTokens.getMetadata(aIndex) & aMask) | (bMetadata & bMask));\n                if (aTokens.getEndOffset(aIndex) === bEndCharacter) {\n                    // `a` ends exactly at the same spot as `b`!\n                    aIndex++;\n                }\n            }\n            else {\n                const aMergeIndex = Math.min(Math.max(0, aIndex - 1), aLen - 1);\n                // push the token from `b`\n                emitToken(bEndCharacter, (aTokens.getMetadata(aMergeIndex) & aMask) | (bMetadata & bMask));\n            }\n        }\n        // push the remaining tokens from `a`\n        while (aIndex < aLen) {\n            emitToken(aTokens.getEndOffset(aIndex), aTokens.getMetadata(aIndex));\n            aIndex++;\n        }\n        return new LineTokens(new Uint32Array(result), aTokens.getLineContent(), this._languageIdCodec);\n    }\n    static _findFirstPieceWithLine(pieces, lineNumber) {\n        let low = 0;\n        let high = pieces.length - 1;\n        while (low < high) {\n            let mid = low + Math.floor((high - low) / 2);\n            if (pieces[mid].endLineNumber < lineNumber) {\n                low = mid + 1;\n            }\n            else if (pieces[mid].startLineNumber > lineNumber) {\n                high = mid - 1;\n            }\n            else {\n                while (mid > low && pieces[mid - 1].startLineNumber <= lineNumber && lineNumber <= pieces[mid - 1].endLineNumber) {\n                    mid--;\n                }\n                return mid;\n            }\n        }\n        return low;\n    }\n    acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode) {\n        for (const piece of this._pieces) {\n            piece.acceptEdit(range, eolCount, firstLineLength, lastLineLength, firstCharCode);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TokenizationTextModelPart_1;\nimport { BugIndicatingError, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter, Event } from '../../../base/common/event.js';\nimport { DisposableMap, DisposableStore, MutableDisposable } from '../../../base/common/lifecycle.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { LineRange } from '../core/lineRange.js';\nimport { Position } from '../core/position.js';\nimport { getWordAtText } from '../core/wordHelper.js';\nimport { TokenizationRegistry, TreeSitterTokenizationRegistry } from '../languages.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { DefaultBackgroundTokenizer, TokenizerWithStateStoreAndTextModel, TrackingTokenizationStateStore } from './textModelTokens.js';\nimport { AbstractTokens, AttachedViewHandler } from './tokens.js';\nimport { TreeSitterTokens } from './treeSitterTokens.js';\nimport { ITreeSitterParserService } from '../services/treeSitterParserService.js';\nimport { ContiguousMultilineTokensBuilder } from '../tokens/contiguousMultilineTokensBuilder.js';\nimport { ContiguousTokensStore } from '../tokens/contiguousTokensStore.js';\nimport { SparseTokensStore } from '../tokens/sparseTokensStore.js';\nlet TokenizationTextModelPart = TokenizationTextModelPart_1 = class TokenizationTextModelPart extends TextModelPart {\n    constructor(_textModel, _bracketPairsTextModelPart, _languageId, _attachedViews, _languageService, _languageConfigurationService, _treeSitterService) {\n        super();\n        this._textModel = _textModel;\n        this._bracketPairsTextModelPart = _bracketPairsTextModelPart;\n        this._languageId = _languageId;\n        this._attachedViews = _attachedViews;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this._treeSitterService = _treeSitterService;\n        this._semanticTokens = new SparseTokensStore(this._languageService.languageIdCodec);\n        this._onDidChangeLanguage = this._register(new Emitter());\n        this.onDidChangeLanguage = this._onDidChangeLanguage.event;\n        this._onDidChangeLanguageConfiguration = this._register(new Emitter());\n        this.onDidChangeLanguageConfiguration = this._onDidChangeLanguageConfiguration.event;\n        this._onDidChangeTokens = this._register(new Emitter());\n        this.onDidChangeTokens = this._onDidChangeTokens.event;\n        this._tokensDisposables = this._register(new DisposableStore());\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            if (e.affects(this._languageId)) {\n                this._onDidChangeLanguageConfiguration.fire({});\n            }\n        }));\n        // We just look at registry changes to determine whether to use tree sitter.\n        // This means that removing a language from the setting will not cause a switch to textmate and will require a reload.\n        // Adding a language to the setting will not need a reload, however.\n        this._register(Event.filter(TreeSitterTokenizationRegistry.onDidChange, (e) => e.changedLanguages.includes(this._languageId))(() => {\n            this.createPreferredTokenProvider();\n        }));\n        this.createPreferredTokenProvider();\n    }\n    createGrammarTokens() {\n        return this._register(new GrammarTokens(this._languageService.languageIdCodec, this._textModel, () => this._languageId, this._attachedViews));\n    }\n    createTreeSitterTokens() {\n        return this._register(new TreeSitterTokens(this._treeSitterService, this._languageService.languageIdCodec, this._textModel, () => this._languageId));\n    }\n    createTokens(useTreeSitter) {\n        const needsReset = this._tokens !== undefined;\n        this._tokens?.dispose();\n        this._tokens = useTreeSitter ? this.createTreeSitterTokens() : this.createGrammarTokens();\n        this._tokensDisposables.clear();\n        this._tokensDisposables.add(this._tokens.onDidChangeTokens(e => {\n            this._emitModelTokensChangedEvent(e);\n        }));\n        this._tokensDisposables.add(this._tokens.onDidChangeBackgroundTokenizationState(e => {\n            this._bracketPairsTextModelPart.handleDidChangeBackgroundTokenizationState();\n        }));\n        if (needsReset) {\n            // We need to reset the tokenization, as the new token provider otherwise won't have a chance to provide tokens until some action happens in the editor.\n            this._tokens.resetTokenization();\n        }\n    }\n    createPreferredTokenProvider() {\n        if (TreeSitterTokenizationRegistry.get(this._languageId)) {\n            if (!(this._tokens instanceof TreeSitterTokens)) {\n                this.createTokens(true);\n            }\n        }\n        else {\n            if (!(this._tokens instanceof GrammarTokens)) {\n                this.createTokens(false);\n            }\n        }\n    }\n    handleLanguageConfigurationServiceChange(e) {\n        if (e.affects(this._languageId)) {\n            this._onDidChangeLanguageConfiguration.fire({});\n        }\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            this._semanticTokens.flush();\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength, lastLineLength] = countEOL(c.text);\n                this._semanticTokens.acceptEdit(c.range, eolCount, firstLineLength, lastLineLength, c.text.length > 0 ? c.text.charCodeAt(0) : 0 /* CharCode.Null */);\n            }\n        }\n        this._tokens.handleDidChangeContent(e);\n    }\n    handleDidChangeAttached() {\n        this._tokens.handleDidChangeAttached();\n    }\n    /**\n     * Includes grammar and semantic tokens.\n     */\n    getLineTokens(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        const syntacticTokens = this._tokens.getLineTokens(lineNumber);\n        return this._semanticTokens.addSparseTokens(lineNumber, syntacticTokens);\n    }\n    _emitModelTokensChangedEvent(e) {\n        if (!this._textModel._isDisposing()) {\n            this._bracketPairsTextModelPart.handleDidChangeTokens(e);\n            this._onDidChangeTokens.fire(e);\n        }\n    }\n    // #region Grammar Tokens\n    validateLineNumber(lineNumber) {\n        if (lineNumber < 1 || lineNumber > this._textModel.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n    resetTokenization() {\n        this._tokens.resetTokenization();\n    }\n    get backgroundTokenizationState() {\n        return this._tokens.backgroundTokenizationState;\n    }\n    forceTokenization(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.forceTokenization(lineNumber);\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        return this._tokens.isCheapToTokenize(lineNumber);\n    }\n    tokenizeIfCheap(lineNumber) {\n        this.validateLineNumber(lineNumber);\n        this._tokens.tokenizeIfCheap(lineNumber);\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        return this._tokens.getTokenTypeIfInsertingCharacter(lineNumber, column, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        return this._tokens.tokenizeLineWithEdit(position, length, newText);\n    }\n    // #endregion\n    // #region Semantic Tokens\n    setSemanticTokens(tokens, isComplete) {\n        this._semanticTokens.set(tokens, isComplete);\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: tokens !== null,\n            ranges: [{ fromLineNumber: 1, toLineNumber: this._textModel.getLineCount() }],\n        });\n    }\n    hasCompleteSemanticTokens() {\n        return this._semanticTokens.isComplete();\n    }\n    hasSomeSemanticTokens() {\n        return !this._semanticTokens.isEmpty();\n    }\n    setPartialSemanticTokens(range, tokens) {\n        if (this.hasCompleteSemanticTokens()) {\n            return;\n        }\n        const changedRange = this._textModel.validateRange(this._semanticTokens.setPartial(range, tokens));\n        this._emitModelTokensChangedEvent({\n            semanticTokensApplied: true,\n            ranges: [\n                {\n                    fromLineNumber: changedRange.startLineNumber,\n                    toLineNumber: changedRange.endLineNumber,\n                },\n            ],\n        });\n    }\n    // #endregion\n    // #region Utility Methods\n    getWordAtPosition(_position) {\n        this.assertNotDisposed();\n        const position = this._textModel.validatePosition(_position);\n        const lineContent = this._textModel.getLineContent(position.lineNumber);\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n        // (1). First try checking right biased word\n        const [rbStartOffset, rbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex);\n        const rightBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex)).getWordDefinition(), lineContent.substring(rbStartOffset, rbEndOffset), rbStartOffset);\n        // Make sure the result touches the original passed in position\n        if (rightBiasedWord &&\n            rightBiasedWord.startColumn <= _position.column &&\n            _position.column <= rightBiasedWord.endColumn) {\n            return rightBiasedWord;\n        }\n        // (2). Else, if we were at a language boundary, check the left biased word\n        if (tokenIndex > 0 && rbStartOffset === position.column - 1) {\n            // edge case, where `position` sits between two tokens belonging to two different languages\n            const [lbStartOffset, lbEndOffset] = TokenizationTextModelPart_1._findLanguageBoundaries(lineTokens, tokenIndex - 1);\n            const leftBiasedWord = getWordAtText(position.column, this.getLanguageConfiguration(lineTokens.getLanguageId(tokenIndex - 1)).getWordDefinition(), lineContent.substring(lbStartOffset, lbEndOffset), lbStartOffset);\n            // Make sure the result touches the original passed in position\n            if (leftBiasedWord &&\n                leftBiasedWord.startColumn <= _position.column &&\n                _position.column <= leftBiasedWord.endColumn) {\n                return leftBiasedWord;\n            }\n        }\n        return null;\n    }\n    getLanguageConfiguration(languageId) {\n        return this._languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    static _findLanguageBoundaries(lineTokens, tokenIndex) {\n        const languageId = lineTokens.getLanguageId(tokenIndex);\n        // go left until a different language is hit\n        let startOffset = 0;\n        for (let i = tokenIndex; i >= 0 && lineTokens.getLanguageId(i) === languageId; i--) {\n            startOffset = lineTokens.getStartOffset(i);\n        }\n        // go right until a different language is hit\n        let endOffset = lineTokens.getLineContent().length;\n        for (let i = tokenIndex, tokenCount = lineTokens.getCount(); i < tokenCount && lineTokens.getLanguageId(i) === languageId; i++) {\n            endOffset = lineTokens.getEndOffset(i);\n        }\n        return [startOffset, endOffset];\n    }\n    getWordUntilPosition(position) {\n        const wordAtPosition = this.getWordAtPosition(position);\n        if (!wordAtPosition) {\n            return { word: '', startColumn: position.column, endColumn: position.column, };\n        }\n        return {\n            word: wordAtPosition.word.substr(0, position.column - wordAtPosition.startColumn),\n            startColumn: wordAtPosition.startColumn,\n            endColumn: position.column,\n        };\n    }\n    // #endregion\n    // #region Language Id handling\n    getLanguageId() {\n        return this._languageId;\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        const lineTokens = this.getLineTokens(position.lineNumber);\n        return lineTokens.getLanguageId(lineTokens.findTokenIndexAtOffset(position.column - 1));\n    }\n    setLanguageId(languageId, source = 'api') {\n        if (this._languageId === languageId) {\n            // There's nothing to do\n            return;\n        }\n        const e = {\n            oldLanguage: this._languageId,\n            newLanguage: languageId,\n            source\n        };\n        this._languageId = languageId;\n        this._bracketPairsTextModelPart.handleDidChangeLanguage(e);\n        this._tokens.resetTokenization();\n        this.createPreferredTokenProvider();\n        this._onDidChangeLanguage.fire(e);\n        this._onDidChangeLanguageConfiguration.fire({});\n    }\n};\nTokenizationTextModelPart = TokenizationTextModelPart_1 = __decorate([\n    __param(4, ILanguageService),\n    __param(5, ILanguageConfigurationService),\n    __param(6, ITreeSitterParserService)\n], TokenizationTextModelPart);\nexport { TokenizationTextModelPart };\nclass GrammarTokens extends AbstractTokens {\n    constructor(languageIdCodec, textModel, getLanguageId, attachedViews) {\n        super(languageIdCodec, textModel, getLanguageId);\n        this._tokenizer = null;\n        this._defaultBackgroundTokenizer = null;\n        this._backgroundTokenizer = this._register(new MutableDisposable());\n        this._tokens = new ContiguousTokensStore(this._languageIdCodec);\n        this._debugBackgroundTokenizer = this._register(new MutableDisposable());\n        this._attachedViewStates = this._register(new DisposableMap());\n        this._register(TokenizationRegistry.onDidChange((e) => {\n            const languageId = this.getLanguageId();\n            if (e.changedLanguages.indexOf(languageId) === -1) {\n                return;\n            }\n            this.resetTokenization();\n        }));\n        this.resetTokenization();\n        this._register(attachedViews.onDidChangeVisibleRanges(({ view, state }) => {\n            if (state) {\n                let existing = this._attachedViewStates.get(view);\n                if (!existing) {\n                    existing = new AttachedViewHandler(() => this.refreshRanges(existing.lineRanges));\n                    this._attachedViewStates.set(view, existing);\n                }\n                existing.handleStateChange(state);\n            }\n            else {\n                this._attachedViewStates.deleteAndDispose(view);\n            }\n        }));\n    }\n    resetTokenization(fireTokenChangeEvent = true) {\n        this._tokens.flush();\n        this._debugBackgroundTokens?.flush();\n        if (this._debugBackgroundStates) {\n            this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n        }\n        if (fireTokenChangeEvent) {\n            this._onDidChangeTokens.fire({\n                semanticTokensApplied: false,\n                ranges: [\n                    {\n                        fromLineNumber: 1,\n                        toLineNumber: this._textModel.getLineCount(),\n                    },\n                ],\n            });\n        }\n        const initializeTokenization = () => {\n            if (this._textModel.isTooLargeForTokenization()) {\n                return [null, null];\n            }\n            const tokenizationSupport = TokenizationRegistry.get(this.getLanguageId());\n            if (!tokenizationSupport) {\n                return [null, null];\n            }\n            let initialState;\n            try {\n                initialState = tokenizationSupport.getInitialState();\n            }\n            catch (e) {\n                onUnexpectedError(e);\n                return [null, null];\n            }\n            return [tokenizationSupport, initialState];\n        };\n        const [tokenizationSupport, initialState] = initializeTokenization();\n        if (tokenizationSupport && initialState) {\n            this._tokenizer = new TokenizerWithStateStoreAndTextModel(this._textModel.getLineCount(), tokenizationSupport, this._textModel, this._languageIdCodec);\n        }\n        else {\n            this._tokenizer = null;\n        }\n        this._backgroundTokenizer.clear();\n        this._defaultBackgroundTokenizer = null;\n        if (this._tokenizer) {\n            const b = {\n                setTokens: (tokens) => {\n                    this.setTokens(tokens);\n                },\n                backgroundTokenizationFinished: () => {\n                    if (this._backgroundTokenizationState === 2 /* BackgroundTokenizationState.Completed */) {\n                        // We already did a full tokenization and don't go back to progressing.\n                        return;\n                    }\n                    const newState = 2 /* BackgroundTokenizationState.Completed */;\n                    this._backgroundTokenizationState = newState;\n                    this._onDidChangeBackgroundTokenizationState.fire();\n                },\n                setEndState: (lineNumber, state) => {\n                    if (!this._tokenizer) {\n                        return;\n                    }\n                    const firstInvalidEndStateLineNumber = this._tokenizer.store.getFirstInvalidEndStateLineNumber();\n                    // Don't accept states for definitely valid states, the renderer is ahead of the worker!\n                    if (firstInvalidEndStateLineNumber !== null && lineNumber >= firstInvalidEndStateLineNumber) {\n                        this._tokenizer?.store.setEndState(lineNumber, state);\n                    }\n                },\n            };\n            if (tokenizationSupport && tokenizationSupport.createBackgroundTokenizer && !tokenizationSupport.backgroundTokenizerShouldOnlyVerifyTokens) {\n                this._backgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, b);\n            }\n            if (!this._backgroundTokenizer.value && !this._textModel.isTooLargeForTokenization()) {\n                this._backgroundTokenizer.value = this._defaultBackgroundTokenizer =\n                    new DefaultBackgroundTokenizer(this._tokenizer, b);\n                this._defaultBackgroundTokenizer.handleChanges();\n            }\n            if (tokenizationSupport?.backgroundTokenizerShouldOnlyVerifyTokens && tokenizationSupport.createBackgroundTokenizer) {\n                this._debugBackgroundTokens = new ContiguousTokensStore(this._languageIdCodec);\n                this._debugBackgroundStates = new TrackingTokenizationStateStore(this._textModel.getLineCount());\n                this._debugBackgroundTokenizer.clear();\n                this._debugBackgroundTokenizer.value = tokenizationSupport.createBackgroundTokenizer(this._textModel, {\n                    setTokens: (tokens) => {\n                        this._debugBackgroundTokens?.setMultilineTokens(tokens, this._textModel);\n                    },\n                    backgroundTokenizationFinished() {\n                        // NO OP\n                    },\n                    setEndState: (lineNumber, state) => {\n                        this._debugBackgroundStates?.setEndState(lineNumber, state);\n                    },\n                });\n            }\n            else {\n                this._debugBackgroundTokens = undefined;\n                this._debugBackgroundStates = undefined;\n                this._debugBackgroundTokenizer.value = undefined;\n            }\n        }\n        this.refreshAllVisibleLineTokens();\n    }\n    handleDidChangeAttached() {\n        this._defaultBackgroundTokenizer?.handleChanges();\n    }\n    handleDidChangeContent(e) {\n        if (e.isFlush) {\n            // Don't fire the event, as the view might not have got the text change event yet\n            this.resetTokenization(false);\n        }\n        else if (!e.isEolChange) { // We don't have to do anything on an EOL change\n            for (const c of e.changes) {\n                const [eolCount, firstLineLength] = countEOL(c.text);\n                this._tokens.acceptEdit(c.range, eolCount, firstLineLength);\n                this._debugBackgroundTokens?.acceptEdit(c.range, eolCount, firstLineLength);\n            }\n            this._debugBackgroundStates?.acceptChanges(e.changes);\n            if (this._tokenizer) {\n                this._tokenizer.store.acceptChanges(e.changes);\n            }\n            this._defaultBackgroundTokenizer?.handleChanges();\n        }\n    }\n    setTokens(tokens) {\n        const { changes } = this._tokens.setMultilineTokens(tokens, this._textModel);\n        if (changes.length > 0) {\n            this._onDidChangeTokens.fire({ semanticTokensApplied: false, ranges: changes, });\n        }\n        return { changes: changes };\n    }\n    refreshAllVisibleLineTokens() {\n        const ranges = LineRange.joinMany([...this._attachedViewStates].map(([_, s]) => s.lineRanges));\n        this.refreshRanges(ranges);\n    }\n    refreshRanges(ranges) {\n        for (const range of ranges) {\n            this.refreshRange(range.startLineNumber, range.endLineNumberExclusive - 1);\n        }\n    }\n    refreshRange(startLineNumber, endLineNumber) {\n        if (!this._tokenizer) {\n            return;\n        }\n        startLineNumber = Math.max(1, Math.min(this._textModel.getLineCount(), startLineNumber));\n        endLineNumber = Math.min(this._textModel.getLineCount(), endLineNumber);\n        const builder = new ContiguousMultilineTokensBuilder();\n        const { heuristicTokens } = this._tokenizer.tokenizeHeuristically(builder, startLineNumber, endLineNumber);\n        const changedTokens = this.setTokens(builder.finalize());\n        if (heuristicTokens) {\n            // We overrode tokens with heuristically computed ones.\n            // Because old states might get reused (thus stopping invalidation),\n            // we have to explicitly request the tokens for the changed ranges again.\n            for (const c of changedTokens.changes) {\n                this._backgroundTokenizer.value?.requestTokens(c.fromLineNumber, c.toLineNumber + 1);\n            }\n        }\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    forceTokenization(lineNumber) {\n        const builder = new ContiguousMultilineTokensBuilder();\n        this._tokenizer?.updateTokensUntilLine(builder, lineNumber);\n        this.setTokens(builder.finalize());\n        this._defaultBackgroundTokenizer?.checkFinished();\n    }\n    hasAccurateTokensForLine(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.hasAccurateTokensForLine(lineNumber);\n    }\n    isCheapToTokenize(lineNumber) {\n        if (!this._tokenizer) {\n            return true;\n        }\n        return this._tokenizer.isCheapToTokenize(lineNumber);\n    }\n    getLineTokens(lineNumber) {\n        const lineText = this._textModel.getLineContent(lineNumber);\n        const result = this._tokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n        if (this._debugBackgroundTokens && this._debugBackgroundStates && this._tokenizer) {\n            if (this._debugBackgroundStates.getFirstInvalidEndStateLineNumberOrMax() > lineNumber && this._tokenizer.store.getFirstInvalidEndStateLineNumberOrMax() > lineNumber) {\n                const backgroundResult = this._debugBackgroundTokens.getTokens(this._textModel.getLanguageId(), lineNumber - 1, lineText);\n                if (!result.equals(backgroundResult) && this._debugBackgroundTokenizer.value?.reportMismatchingTokens) {\n                    this._debugBackgroundTokenizer.value.reportMismatchingTokens(lineNumber);\n                }\n            }\n        }\n        return result;\n    }\n    getTokenTypeIfInsertingCharacter(lineNumber, column, character) {\n        if (!this._tokenizer) {\n            return 0 /* StandardTokenType.Other */;\n        }\n        const position = this._textModel.validatePosition(new Position(lineNumber, column));\n        this.forceTokenization(position.lineNumber);\n        return this._tokenizer.getTokenTypeIfInsertingCharacter(position, character);\n    }\n    tokenizeLineWithEdit(position, length, newText) {\n        if (!this._tokenizer) {\n            return null;\n        }\n        const validatedPosition = this._textModel.validatePosition(position);\n        this.forceTokenization(validatedPosition.lineNumber);\n        return this._tokenizer.tokenizeLineWithEdit(validatedPosition, length, newText);\n    }\n    get hasTokens() {\n        return this._tokens.hasTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar TextModel_1;\nimport { ArrayQueue, pushMany } from '../../../base/common/arrays.js';\nimport { Color } from '../../../base/common/color.js';\nimport { BugIndicatingError, illegalArgument, onUnexpectedError } from '../../../base/common/errors.js';\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, MutableDisposable, combinedDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { countEOL } from '../core/eolCounter.js';\nimport { normalizeIndentation } from '../core/indentation.js';\nimport { Position } from '../core/position.js';\nimport { Range } from '../core/range.js';\nimport { Selection } from '../core/selection.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { ILanguageService } from '../languages/language.js';\nimport { ILanguageConfigurationService } from '../languages/languageConfigurationRegistry.js';\nimport * as model from '../model.js';\nimport { BracketPairsTextModelPart } from './bracketPairsTextModelPart/bracketPairsImpl.js';\nimport { ColorizedBracketPairsDecorationProvider } from './bracketPairsTextModelPart/colorizedBracketPairsDecorationProvider.js';\nimport { EditStack } from './editStack.js';\nimport { GuidesTextModelPart } from './guidesTextModelPart.js';\nimport { guessIndentation } from './indentationGuesser.js';\nimport { IntervalNode, IntervalTree, recomputeMaxEnd } from './intervalTree.js';\nimport { PieceTreeTextBuffer } from './pieceTreeTextBuffer/pieceTreeTextBuffer.js';\nimport { PieceTreeTextBufferBuilder } from './pieceTreeTextBuffer/pieceTreeTextBufferBuilder.js';\nimport { SearchParams, TextModelSearch } from './textModelSearch.js';\nimport { TokenizationTextModelPart } from './tokenizationTextModelPart.js';\nimport { AttachedViews } from './tokens.js';\nimport { InternalModelContentChangeEvent, LineInjectedText, ModelInjectedTextChangedEvent, ModelRawContentChangedEvent, ModelRawEOLChanged, ModelRawFlush, ModelRawLineChanged, ModelRawLinesDeleted, ModelRawLinesInserted } from '../textModelEvents.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nexport function createTextBufferFactory(text) {\n    const builder = new PieceTreeTextBufferBuilder();\n    builder.acceptChunk(text);\n    return builder.finish();\n}\nexport function createTextBufferFactoryFromSnapshot(snapshot) {\n    const builder = new PieceTreeTextBufferBuilder();\n    let chunk;\n    while (typeof (chunk = snapshot.read()) === 'string') {\n        builder.acceptChunk(chunk);\n    }\n    return builder.finish();\n}\nexport function createTextBuffer(value, defaultEOL) {\n    let factory;\n    if (typeof value === 'string') {\n        factory = createTextBufferFactory(value);\n    }\n    else if (model.isITextSnapshot(value)) {\n        factory = createTextBufferFactoryFromSnapshot(value);\n    }\n    else {\n        factory = value;\n    }\n    return factory.create(defaultEOL);\n}\nlet MODEL_ID = 0;\nconst LIMIT_FIND_COUNT = 999;\nconst LONG_LINE_BOUNDARY = 10000;\nclass TextModelSnapshot {\n    constructor(source) {\n        this._source = source;\n        this._eos = false;\n    }\n    read() {\n        if (this._eos) {\n            return null;\n        }\n        const result = [];\n        let resultCnt = 0;\n        let resultLength = 0;\n        do {\n            const tmp = this._source.read();\n            if (tmp === null) {\n                // end-of-stream\n                this._eos = true;\n                if (resultCnt === 0) {\n                    return null;\n                }\n                else {\n                    return result.join('');\n                }\n            }\n            if (tmp.length > 0) {\n                result[resultCnt++] = tmp;\n                resultLength += tmp.length;\n            }\n            if (resultLength >= 64 * 1024) {\n                return result.join('');\n            }\n        } while (true);\n    }\n}\nconst invalidFunc = () => { throw new Error(`Invalid change accessor`); };\nlet TextModel = class TextModel extends Disposable {\n    static { TextModel_1 = this; }\n    static { this._MODEL_SYNC_LIMIT = 50 * 1024 * 1024; } // 50 MB,  // used in tests\n    static { this.LARGE_FILE_SIZE_THRESHOLD = 20 * 1024 * 1024; } // 20 MB;\n    static { this.LARGE_FILE_LINE_COUNT_THRESHOLD = 300 * 1000; } // 300K lines\n    static { this.LARGE_FILE_HEAP_OPERATION_THRESHOLD = 256 * 1024 * 1024; } // 256M characters, usually ~> 512MB memory usage\n    static { this.DEFAULT_CREATION_OPTIONS = {\n        isForSimpleWidget: false,\n        tabSize: EDITOR_MODEL_DEFAULTS.tabSize,\n        indentSize: EDITOR_MODEL_DEFAULTS.indentSize,\n        insertSpaces: EDITOR_MODEL_DEFAULTS.insertSpaces,\n        detectIndentation: false,\n        defaultEOL: 1 /* model.DefaultEndOfLine.LF */,\n        trimAutoWhitespace: EDITOR_MODEL_DEFAULTS.trimAutoWhitespace,\n        largeFileOptimizations: EDITOR_MODEL_DEFAULTS.largeFileOptimizations,\n        bracketPairColorizationOptions: EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions,\n    }; }\n    static resolveOptions(textBuffer, options) {\n        if (options.detectIndentation) {\n            const guessedIndentation = guessIndentation(textBuffer, options.tabSize, options.insertSpaces);\n            return new model.TextModelResolvedOptions({\n                tabSize: guessedIndentation.tabSize,\n                indentSize: 'tabSize', // TODO@Alex: guess indentSize independent of tabSize\n                insertSpaces: guessedIndentation.insertSpaces,\n                trimAutoWhitespace: options.trimAutoWhitespace,\n                defaultEOL: options.defaultEOL,\n                bracketPairColorizationOptions: options.bracketPairColorizationOptions,\n            });\n        }\n        return new model.TextModelResolvedOptions(options);\n    }\n    get onDidChangeLanguage() { return this._tokenizationTextModelPart.onDidChangeLanguage; }\n    get onDidChangeLanguageConfiguration() { return this._tokenizationTextModelPart.onDidChangeLanguageConfiguration; }\n    get onDidChangeTokens() { return this._tokenizationTextModelPart.onDidChangeTokens; }\n    onDidChangeContent(listener) {\n        return this._eventEmitter.slowEvent((e) => listener(e.contentChangedEvent));\n    }\n    onDidChangeContentOrInjectedText(listener) {\n        return combinedDisposable(this._eventEmitter.fastEvent(e => listener(e)), this._onDidChangeInjectedText.event(e => listener(e)));\n    }\n    _isDisposing() { return this.__isDisposing; }\n    get tokenization() { return this._tokenizationTextModelPart; }\n    get bracketPairs() { return this._bracketPairs; }\n    get guides() { return this._guidesTextModelPart; }\n    constructor(source, languageIdOrSelection, creationOptions, associatedResource = null, _undoRedoService, _languageService, _languageConfigurationService, instantiationService) {\n        super();\n        this._undoRedoService = _undoRedoService;\n        this._languageService = _languageService;\n        this._languageConfigurationService = _languageConfigurationService;\n        this.instantiationService = instantiationService;\n        //#region Events\n        this._onWillDispose = this._register(new Emitter());\n        this.onWillDispose = this._onWillDispose.event;\n        this._onDidChangeDecorations = this._register(new DidChangeDecorationsEmitter(affectedInjectedTextLines => this.handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines)));\n        this.onDidChangeDecorations = this._onDidChangeDecorations.event;\n        this._onDidChangeOptions = this._register(new Emitter());\n        this.onDidChangeOptions = this._onDidChangeOptions.event;\n        this._onDidChangeAttached = this._register(new Emitter());\n        this.onDidChangeAttached = this._onDidChangeAttached.event;\n        this._onDidChangeInjectedText = this._register(new Emitter());\n        this._eventEmitter = this._register(new DidChangeContentEmitter());\n        this._languageSelectionListener = this._register(new MutableDisposable());\n        this._deltaDecorationCallCnt = 0;\n        this._attachedViews = new AttachedViews();\n        // Generate a new unique model id\n        MODEL_ID++;\n        this.id = '$model' + MODEL_ID;\n        this.isForSimpleWidget = creationOptions.isForSimpleWidget;\n        if (typeof associatedResource === 'undefined' || associatedResource === null) {\n            this._associatedResource = URI.parse('inmemory://model/' + MODEL_ID);\n        }\n        else {\n            this._associatedResource = associatedResource;\n        }\n        this._attachedEditorCount = 0;\n        const { textBuffer, disposable } = createTextBuffer(source, creationOptions.defaultEOL);\n        this._buffer = textBuffer;\n        this._bufferDisposable = disposable;\n        this._options = TextModel_1.resolveOptions(this._buffer, creationOptions);\n        const languageId = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        if (typeof languageIdOrSelection !== 'string') {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId));\n        }\n        this._bracketPairs = this._register(new BracketPairsTextModelPart(this, this._languageConfigurationService));\n        this._guidesTextModelPart = this._register(new GuidesTextModelPart(this, this._languageConfigurationService));\n        this._decorationProvider = this._register(new ColorizedBracketPairsDecorationProvider(this));\n        this._tokenizationTextModelPart = this.instantiationService.createInstance(TokenizationTextModelPart, this, this._bracketPairs, languageId, this._attachedViews);\n        const bufferLineCount = this._buffer.getLineCount();\n        const bufferTextLength = this._buffer.getValueLengthInRange(new Range(1, 1, bufferLineCount, this._buffer.getLineLength(bufferLineCount) + 1), 0 /* model.EndOfLinePreference.TextDefined */);\n        // !!! Make a decision in the ctor and permanently respect this decision !!!\n        // If a model is too large at construction time, it will never get tokenized,\n        // under no circumstances.\n        if (creationOptions.largeFileOptimizations) {\n            this._isTooLargeForTokenization = ((bufferTextLength > TextModel_1.LARGE_FILE_SIZE_THRESHOLD)\n                || (bufferLineCount > TextModel_1.LARGE_FILE_LINE_COUNT_THRESHOLD));\n            this._isTooLargeForHeapOperation = bufferTextLength > TextModel_1.LARGE_FILE_HEAP_OPERATION_THRESHOLD;\n        }\n        else {\n            this._isTooLargeForTokenization = false;\n            this._isTooLargeForHeapOperation = false;\n        }\n        this._isTooLargeForSyncing = (bufferTextLength > TextModel_1._MODEL_SYNC_LIMIT);\n        this._versionId = 1;\n        this._alternativeVersionId = 1;\n        this._initialUndoRedoSnapshot = null;\n        this._isDisposed = false;\n        this.__isDisposing = false;\n        this._instanceId = strings.singleLetterHash(MODEL_ID);\n        this._lastDecorationId = 0;\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        this._commandManager = new EditStack(this, this._undoRedoService);\n        this._isUndoing = false;\n        this._isRedoing = false;\n        this._trimAutoWhitespaceLines = null;\n        this._register(this._decorationProvider.onDidChange(() => {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._onDidChangeDecorations.fire();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }));\n        this._languageService.requestRichLanguageFeatures(languageId);\n        this._register(this._languageConfigurationService.onDidChange(e => {\n            this._bracketPairs.handleLanguageConfigurationServiceChange(e);\n            this._tokenizationTextModelPart.handleLanguageConfigurationServiceChange(e);\n        }));\n    }\n    dispose() {\n        this.__isDisposing = true;\n        this._onWillDispose.fire();\n        this._tokenizationTextModelPart.dispose();\n        this._isDisposed = true;\n        super.dispose();\n        this._bufferDisposable.dispose();\n        this.__isDisposing = false;\n        // Manually release reference to previous text buffer to avoid large leaks\n        // in case someone leaks a TextModel reference\n        const emptyDisposedTextBuffer = new PieceTreeTextBuffer([], '', '\\n', false, false, true, true);\n        emptyDisposedTextBuffer.dispose();\n        this._buffer = emptyDisposedTextBuffer;\n        this._bufferDisposable = Disposable.None;\n    }\n    _assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new BugIndicatingError('Model is disposed!');\n        }\n    }\n    _emitContentChangedEvent(rawChange, change) {\n        if (this.__isDisposing) {\n            // Do not confuse listeners by emitting any event after disposing\n            return;\n        }\n        this._tokenizationTextModelPart.handleDidChangeContent(change);\n        this._bracketPairs.handleDidChangeContent(change);\n        this._eventEmitter.fire(new InternalModelContentChangeEvent(rawChange, change));\n    }\n    setValue(value) {\n        this._assertNotDisposed();\n        if (value === null || value === undefined) {\n            throw illegalArgument();\n        }\n        const { textBuffer, disposable } = createTextBuffer(value, this._options.defaultEOL);\n        this._setValueFromTextBuffer(textBuffer, disposable);\n    }\n    _createContentChanged2(range, rangeOffset, rangeLength, text, isUndoing, isRedoing, isFlush, isEolChange) {\n        return {\n            changes: [{\n                    range: range,\n                    rangeOffset: rangeOffset,\n                    rangeLength: rangeLength,\n                    text: text,\n                }],\n            eol: this._buffer.getEOL(),\n            isEolChange: isEolChange,\n            versionId: this.getVersionId(),\n            isUndoing: isUndoing,\n            isRedoing: isRedoing,\n            isFlush: isFlush\n        };\n    }\n    _setValueFromTextBuffer(textBuffer, textBufferDisposable) {\n        this._assertNotDisposed();\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._buffer = textBuffer;\n        this._bufferDisposable.dispose();\n        this._bufferDisposable = textBufferDisposable;\n        this._increaseVersionId();\n        // Destroy all my decorations\n        this._decorations = Object.create(null);\n        this._decorationsTree = new DecorationsTrees();\n        // Destroy my edit history and settings\n        this._commandManager.clear();\n        this._trimAutoWhitespaceLines = null;\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawFlush()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, true, false));\n    }\n    setEOL(eol) {\n        this._assertNotDisposed();\n        const newEOL = (eol === 1 /* model.EndOfLineSequence.CRLF */ ? '\\r\\n' : '\\n');\n        if (this._buffer.getEOL() === newEOL) {\n            // Nothing to do\n            return;\n        }\n        const oldFullModelRange = this.getFullModelRange();\n        const oldModelValueLength = this.getValueLengthInRange(oldFullModelRange);\n        const endLineNumber = this.getLineCount();\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        this._onBeforeEOLChange();\n        this._buffer.setEOL(newEOL);\n        this._increaseVersionId();\n        this._onAfterEOLChange();\n        this._emitContentChangedEvent(new ModelRawContentChangedEvent([\n            new ModelRawEOLChanged()\n        ], this._versionId, false, false), this._createContentChanged2(new Range(1, 1, endLineNumber, endColumn), 0, oldModelValueLength, this.getValue(), false, false, false, true));\n    }\n    _onBeforeEOLChange() {\n        // Ensure all decorations get their `range` set.\n        this._decorationsTree.ensureAllNodesHaveRanges(this);\n    }\n    _onAfterEOLChange() {\n        // Transform back `range` to offsets\n        const versionId = this.getVersionId();\n        const allDecorations = this._decorationsTree.collectNodesPostOrder();\n        for (let i = 0, len = allDecorations.length; i < len; i++) {\n            const node = allDecorations[i];\n            const range = node.range; // the range is defined due to `_onBeforeEOLChange`\n            const delta = node.cachedAbsoluteStart - node.start;\n            const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n            const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n            node.cachedAbsoluteStart = startOffset;\n            node.cachedAbsoluteEnd = endOffset;\n            node.cachedVersionId = versionId;\n            node.start = startOffset - delta;\n            node.end = endOffset - delta;\n            recomputeMaxEnd(node);\n        }\n    }\n    onBeforeAttached() {\n        this._attachedEditorCount++;\n        if (this._attachedEditorCount === 1) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        return this._attachedViews.attachView();\n    }\n    onBeforeDetached(view) {\n        this._attachedEditorCount--;\n        if (this._attachedEditorCount === 0) {\n            this._tokenizationTextModelPart.handleDidChangeAttached();\n            this._onDidChangeAttached.fire(undefined);\n        }\n        this._attachedViews.detachView(view);\n    }\n    isAttachedToEditor() {\n        return this._attachedEditorCount > 0;\n    }\n    getAttachedEditorCount() {\n        return this._attachedEditorCount;\n    }\n    isTooLargeForSyncing() {\n        return this._isTooLargeForSyncing;\n    }\n    isTooLargeForTokenization() {\n        return this._isTooLargeForTokenization;\n    }\n    isTooLargeForHeapOperation() {\n        return this._isTooLargeForHeapOperation;\n    }\n    isDisposed() {\n        return this._isDisposed;\n    }\n    isDominatedByLongLines() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForTokenization()) {\n            // Cannot word wrap huge files anyways, so it doesn't really matter\n            return false;\n        }\n        let smallLineCharCount = 0;\n        let longLineCharCount = 0;\n        const lineCount = this._buffer.getLineCount();\n        for (let lineNumber = 1; lineNumber <= lineCount; lineNumber++) {\n            const lineLength = this._buffer.getLineLength(lineNumber);\n            if (lineLength >= LONG_LINE_BOUNDARY) {\n                longLineCharCount += lineLength;\n            }\n            else {\n                smallLineCharCount += lineLength;\n            }\n        }\n        return (longLineCharCount > smallLineCharCount);\n    }\n    get uri() {\n        return this._associatedResource;\n    }\n    //#region Options\n    getOptions() {\n        this._assertNotDisposed();\n        return this._options;\n    }\n    getFormattingOptions() {\n        return {\n            tabSize: this._options.indentSize,\n            insertSpaces: this._options.insertSpaces\n        };\n    }\n    updateOptions(_newOpts) {\n        this._assertNotDisposed();\n        const tabSize = (typeof _newOpts.tabSize !== 'undefined') ? _newOpts.tabSize : this._options.tabSize;\n        const indentSize = (typeof _newOpts.indentSize !== 'undefined') ? _newOpts.indentSize : this._options.originalIndentSize;\n        const insertSpaces = (typeof _newOpts.insertSpaces !== 'undefined') ? _newOpts.insertSpaces : this._options.insertSpaces;\n        const trimAutoWhitespace = (typeof _newOpts.trimAutoWhitespace !== 'undefined') ? _newOpts.trimAutoWhitespace : this._options.trimAutoWhitespace;\n        const bracketPairColorizationOptions = (typeof _newOpts.bracketColorizationOptions !== 'undefined') ? _newOpts.bracketColorizationOptions : this._options.bracketPairColorizationOptions;\n        const newOpts = new model.TextModelResolvedOptions({\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            defaultEOL: this._options.defaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            bracketPairColorizationOptions,\n        });\n        if (this._options.equals(newOpts)) {\n            return;\n        }\n        const e = this._options.createChangeEvent(newOpts);\n        this._options = newOpts;\n        this._bracketPairs.handleDidChangeOptions(e);\n        this._decorationProvider.handleDidChangeOptions(e);\n        this._onDidChangeOptions.fire(e);\n    }\n    detectIndentation(defaultInsertSpaces, defaultTabSize) {\n        this._assertNotDisposed();\n        const guessedIndentation = guessIndentation(this._buffer, defaultTabSize, defaultInsertSpaces);\n        this.updateOptions({\n            insertSpaces: guessedIndentation.insertSpaces,\n            tabSize: guessedIndentation.tabSize,\n            indentSize: guessedIndentation.tabSize, // TODO@Alex: guess indentSize independent of tabSize\n        });\n    }\n    normalizeIndentation(str) {\n        this._assertNotDisposed();\n        return normalizeIndentation(str, this._options.indentSize, this._options.insertSpaces);\n    }\n    //#endregion\n    //#region Reading\n    getVersionId() {\n        this._assertNotDisposed();\n        return this._versionId;\n    }\n    mightContainRTL() {\n        return this._buffer.mightContainRTL();\n    }\n    mightContainUnusualLineTerminators() {\n        return this._buffer.mightContainUnusualLineTerminators();\n    }\n    removeUnusualLineTerminators(selections = null) {\n        const matches = this.findMatches(strings.UNUSUAL_LINE_TERMINATORS.source, false, true, false, null, false, 1073741824 /* Constants.MAX_SAFE_SMALL_INTEGER */);\n        this._buffer.resetMightContainUnusualLineTerminators();\n        this.pushEditOperations(selections, matches.map(m => ({ range: m.range, text: null })), () => null);\n    }\n    mightContainNonBasicASCII() {\n        return this._buffer.mightContainNonBasicASCII();\n    }\n    getAlternativeVersionId() {\n        this._assertNotDisposed();\n        return this._alternativeVersionId;\n    }\n    getInitialUndoRedoSnapshot() {\n        this._assertNotDisposed();\n        return this._initialUndoRedoSnapshot;\n    }\n    getOffsetAt(rawPosition) {\n        this._assertNotDisposed();\n        const position = this._validatePosition(rawPosition.lineNumber, rawPosition.column, 0 /* StringOffsetValidationType.Relaxed */);\n        return this._buffer.getOffsetAt(position.lineNumber, position.column);\n    }\n    getPositionAt(rawOffset) {\n        this._assertNotDisposed();\n        const offset = (Math.min(this._buffer.getLength(), Math.max(0, rawOffset)));\n        return this._buffer.getPositionAt(offset);\n    }\n    _increaseVersionId() {\n        this._versionId = this._versionId + 1;\n        this._alternativeVersionId = this._versionId;\n    }\n    _overwriteVersionId(versionId) {\n        this._versionId = versionId;\n    }\n    _overwriteAlternativeVersionId(newAlternativeVersionId) {\n        this._alternativeVersionId = newAlternativeVersionId;\n    }\n    _overwriteInitialUndoRedoSnapshot(newInitialUndoRedoSnapshot) {\n        this._initialUndoRedoSnapshot = newInitialUndoRedoSnapshot;\n    }\n    getValue(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM() + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    createSnapshot(preserveBOM = false) {\n        return new TextModelSnapshot(this._buffer.createSnapshot(preserveBOM));\n    }\n    getValueLength(eol, preserveBOM = false) {\n        this._assertNotDisposed();\n        const fullModelRange = this.getFullModelRange();\n        const fullModelValue = this.getValueLengthInRange(fullModelRange, eol);\n        if (preserveBOM) {\n            return this._buffer.getBOM().length + fullModelValue;\n        }\n        return fullModelValue;\n    }\n    getValueInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueInRange(this.validateRange(rawRange), eol);\n    }\n    getValueLengthInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getValueLengthInRange(this.validateRange(rawRange), eol);\n    }\n    getCharacterCountInRange(rawRange, eol = 0 /* model.EndOfLinePreference.TextDefined */) {\n        this._assertNotDisposed();\n        return this._buffer.getCharacterCountInRange(this.validateRange(rawRange), eol);\n    }\n    getLineCount() {\n        this._assertNotDisposed();\n        return this._buffer.getLineCount();\n    }\n    getLineContent(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineContent(lineNumber);\n    }\n    getLineLength(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber);\n    }\n    getLinesContent() {\n        this._assertNotDisposed();\n        if (this.isTooLargeForHeapOperation()) {\n            throw new BugIndicatingError('Operation would exceed heap memory limits');\n        }\n        return this._buffer.getLinesContent();\n    }\n    getEOL() {\n        this._assertNotDisposed();\n        return this._buffer.getEOL();\n    }\n    getEndOfLineSequence() {\n        this._assertNotDisposed();\n        return (this._buffer.getEOL() === '\\n'\n            ? 0 /* model.EndOfLineSequence.LF */\n            : 1 /* model.EndOfLineSequence.CRLF */);\n    }\n    getLineMinColumn(lineNumber) {\n        this._assertNotDisposed();\n        return 1;\n    }\n    getLineMaxColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLength(lineNumber) + 1;\n    }\n    getLineFirstNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineFirstNonWhitespaceColumn(lineNumber);\n    }\n    getLineLastNonWhitespaceColumn(lineNumber) {\n        this._assertNotDisposed();\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        return this._buffer.getLineLastNonWhitespaceColumn(lineNumber);\n    }\n    /**\n     * Validates `range` is within buffer bounds, but allows it to sit in between surrogate pairs, etc.\n     * Will try to not allocate if possible.\n     */\n    _validateRangeRelaxedNoAllocations(range) {\n        const linesCount = this._buffer.getLineCount();\n        const initialStartLineNumber = range.startLineNumber;\n        const initialStartColumn = range.startColumn;\n        let startLineNumber = Math.floor((typeof initialStartLineNumber === 'number' && !isNaN(initialStartLineNumber)) ? initialStartLineNumber : 1);\n        let startColumn = Math.floor((typeof initialStartColumn === 'number' && !isNaN(initialStartColumn)) ? initialStartColumn : 1);\n        if (startLineNumber < 1) {\n            startLineNumber = 1;\n            startColumn = 1;\n        }\n        else if (startLineNumber > linesCount) {\n            startLineNumber = linesCount;\n            startColumn = this.getLineMaxColumn(startLineNumber);\n        }\n        else {\n            if (startColumn <= 1) {\n                startColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(startLineNumber);\n                if (startColumn >= maxColumn) {\n                    startColumn = maxColumn;\n                }\n            }\n        }\n        const initialEndLineNumber = range.endLineNumber;\n        const initialEndColumn = range.endColumn;\n        let endLineNumber = Math.floor((typeof initialEndLineNumber === 'number' && !isNaN(initialEndLineNumber)) ? initialEndLineNumber : 1);\n        let endColumn = Math.floor((typeof initialEndColumn === 'number' && !isNaN(initialEndColumn)) ? initialEndColumn : 1);\n        if (endLineNumber < 1) {\n            endLineNumber = 1;\n            endColumn = 1;\n        }\n        else if (endLineNumber > linesCount) {\n            endLineNumber = linesCount;\n            endColumn = this.getLineMaxColumn(endLineNumber);\n        }\n        else {\n            if (endColumn <= 1) {\n                endColumn = 1;\n            }\n            else {\n                const maxColumn = this.getLineMaxColumn(endLineNumber);\n                if (endColumn >= maxColumn) {\n                    endColumn = maxColumn;\n                }\n            }\n        }\n        if (initialStartLineNumber === startLineNumber\n            && initialStartColumn === startColumn\n            && initialEndLineNumber === endLineNumber\n            && initialEndColumn === endColumn\n            && range instanceof Range\n            && !(range instanceof Selection)) {\n            return range;\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    _isValidPosition(lineNumber, column, validationType) {\n        if (typeof lineNumber !== 'number' || typeof column !== 'number') {\n            return false;\n        }\n        if (isNaN(lineNumber) || isNaN(column)) {\n            return false;\n        }\n        if (lineNumber < 1 || column < 1) {\n            return false;\n        }\n        if ((lineNumber | 0) !== lineNumber || (column | 0) !== column) {\n            return false;\n        }\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber > lineCount) {\n            return false;\n        }\n        if (column === 1) {\n            return true;\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column > maxColumn) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    _validatePosition(_lineNumber, _column, validationType) {\n        const lineNumber = Math.floor((typeof _lineNumber === 'number' && !isNaN(_lineNumber)) ? _lineNumber : 1);\n        const column = Math.floor((typeof _column === 'number' && !isNaN(_column)) ? _column : 1);\n        const lineCount = this._buffer.getLineCount();\n        if (lineNumber < 1) {\n            return new Position(1, 1);\n        }\n        if (lineNumber > lineCount) {\n            return new Position(lineCount, this.getLineMaxColumn(lineCount));\n        }\n        if (column <= 1) {\n            return new Position(lineNumber, 1);\n        }\n        const maxColumn = this.getLineMaxColumn(lineNumber);\n        if (column >= maxColumn) {\n            return new Position(lineNumber, maxColumn);\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            // If the position would end up in the middle of a high-low surrogate pair,\n            // we move it to before the pair\n            // !!At this point, column > 1\n            const charCodeBefore = this._buffer.getLineCharCode(lineNumber, column - 2);\n            if (strings.isHighSurrogate(charCodeBefore)) {\n                return new Position(lineNumber, column - 1);\n            }\n        }\n        return new Position(lineNumber, column);\n    }\n    validatePosition(position) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if (position instanceof Position) {\n            if (this._isValidPosition(position.lineNumber, position.column, validationType)) {\n                return position;\n            }\n        }\n        return this._validatePosition(position.lineNumber, position.column, validationType);\n    }\n    _isValidRange(range, validationType) {\n        const startLineNumber = range.startLineNumber;\n        const startColumn = range.startColumn;\n        const endLineNumber = range.endLineNumber;\n        const endColumn = range.endColumn;\n        if (!this._isValidPosition(startLineNumber, startColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (!this._isValidPosition(endLineNumber, endColumn, 0 /* StringOffsetValidationType.Relaxed */)) {\n            return false;\n        }\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return true;\n            }\n            return false;\n        }\n        return true;\n    }\n    validateRange(_range) {\n        const validationType = 1 /* StringOffsetValidationType.SurrogatePairs */;\n        this._assertNotDisposed();\n        // Avoid object allocation and cover most likely case\n        if ((_range instanceof Range) && !(_range instanceof Selection)) {\n            if (this._isValidRange(_range, validationType)) {\n                return _range;\n            }\n        }\n        const start = this._validatePosition(_range.startLineNumber, _range.startColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const end = this._validatePosition(_range.endLineNumber, _range.endColumn, 0 /* StringOffsetValidationType.Relaxed */);\n        const startLineNumber = start.lineNumber;\n        const startColumn = start.column;\n        const endLineNumber = end.lineNumber;\n        const endColumn = end.column;\n        if (validationType === 1 /* StringOffsetValidationType.SurrogatePairs */) {\n            const charCodeBeforeStart = (startColumn > 1 ? this._buffer.getLineCharCode(startLineNumber, startColumn - 2) : 0);\n            const charCodeBeforeEnd = (endColumn > 1 && endColumn <= this._buffer.getLineLength(endLineNumber) ? this._buffer.getLineCharCode(endLineNumber, endColumn - 2) : 0);\n            const startInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeStart);\n            const endInsideSurrogatePair = strings.isHighSurrogate(charCodeBeforeEnd);\n            if (!startInsideSurrogatePair && !endInsideSurrogatePair) {\n                return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n            }\n            if (startLineNumber === endLineNumber && startColumn === endColumn) {\n                // do not expand a collapsed range, simply move it to a valid location\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn - 1);\n            }\n            if (startInsideSurrogatePair && endInsideSurrogatePair) {\n                // expand range at both ends\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn + 1);\n            }\n            if (startInsideSurrogatePair) {\n                // only expand range at the start\n                return new Range(startLineNumber, startColumn - 1, endLineNumber, endColumn);\n            }\n            // only expand range at the end\n            return new Range(startLineNumber, startColumn, endLineNumber, endColumn + 1);\n        }\n        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);\n    }\n    modifyPosition(rawPosition, offset) {\n        this._assertNotDisposed();\n        const candidate = this.getOffsetAt(rawPosition) + offset;\n        return this.getPositionAt(Math.min(this._buffer.getLength(), Math.max(0, candidate)));\n    }\n    getFullModelRange() {\n        this._assertNotDisposed();\n        const lineCount = this.getLineCount();\n        return new Range(1, 1, lineCount, this.getLineMaxColumn(lineCount));\n    }\n    findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount) {\n        return this._buffer.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n    }\n    findMatches(searchString, rawSearchScope, isRegex, matchCase, wordSeparators, captureMatches, limitResultCount = LIMIT_FIND_COUNT) {\n        this._assertNotDisposed();\n        let searchRanges = null;\n        if (rawSearchScope !== null) {\n            if (!Array.isArray(rawSearchScope)) {\n                rawSearchScope = [rawSearchScope];\n            }\n            if (rawSearchScope.every((searchScope) => Range.isIRange(searchScope))) {\n                searchRanges = rawSearchScope.map((searchScope) => this.validateRange(searchScope));\n            }\n        }\n        if (searchRanges === null) {\n            searchRanges = [this.getFullModelRange()];\n        }\n        searchRanges = searchRanges.sort((d1, d2) => d1.startLineNumber - d2.startLineNumber || d1.startColumn - d2.startColumn);\n        const uniqueSearchRanges = [];\n        uniqueSearchRanges.push(searchRanges.reduce((prev, curr) => {\n            if (Range.areIntersecting(prev, curr)) {\n                return prev.plusRange(curr);\n            }\n            uniqueSearchRanges.push(prev);\n            return curr;\n        }));\n        let matchMapper;\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            // not regex, not multi line\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return [];\n            }\n            matchMapper = (searchRange) => this.findMatchesLineByLine(searchRange, searchData, captureMatches, limitResultCount);\n        }\n        else {\n            matchMapper = (searchRange) => TextModelSearch.findMatches(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchRange, captureMatches, limitResultCount);\n        }\n        return uniqueSearchRanges.map(matchMapper).reduce((arr, matches) => arr.concat(matches), []);\n    }\n    findNextMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        if (!isRegex && searchString.indexOf('\\n') < 0) {\n            const searchParams = new SearchParams(searchString, isRegex, matchCase, wordSeparators);\n            const searchData = searchParams.parseSearchRequest();\n            if (!searchData) {\n                return null;\n            }\n            const lineCount = this.getLineCount();\n            let searchRange = new Range(searchStart.lineNumber, searchStart.column, lineCount, this.getLineMaxColumn(lineCount));\n            let ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            searchRange = new Range(1, 1, searchStart.lineNumber, this.getLineMaxColumn(searchStart.lineNumber));\n            ret = this.findMatchesLineByLine(searchRange, searchData, captureMatches, 1);\n            if (ret.length > 0) {\n                return ret[0];\n            }\n            return null;\n        }\n        return TextModelSearch.findNextMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    findPreviousMatch(searchString, rawSearchStart, isRegex, matchCase, wordSeparators, captureMatches) {\n        this._assertNotDisposed();\n        const searchStart = this.validatePosition(rawSearchStart);\n        return TextModelSearch.findPreviousMatch(this, new SearchParams(searchString, isRegex, matchCase, wordSeparators), searchStart, captureMatches);\n    }\n    //#endregion\n    //#region Editing\n    pushStackElement() {\n        this._commandManager.pushStackElement();\n    }\n    popStackElement() {\n        this._commandManager.popStackElement();\n    }\n    pushEOL(eol) {\n        const currentEOL = (this.getEOL() === '\\n' ? 0 /* model.EndOfLineSequence.LF */ : 1 /* model.EndOfLineSequence.CRLF */);\n        if (currentEOL === eol) {\n            return;\n        }\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            if (this._initialUndoRedoSnapshot === null) {\n                this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n            }\n            this._commandManager.pushEOL(eol);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _validateEditOperation(rawOperation) {\n        if (rawOperation instanceof model.ValidAnnotatedEditOperation) {\n            return rawOperation;\n        }\n        return new model.ValidAnnotatedEditOperation(rawOperation.identifier || null, this.validateRange(rawOperation.range), rawOperation.text, rawOperation.forceMoveMarkers || false, rawOperation.isAutoWhitespaceEdit || false, rawOperation._isTracked || false);\n    }\n    _validateEditOperations(rawOperations) {\n        const result = [];\n        for (let i = 0, len = rawOperations.length; i < len; i++) {\n            result[i] = this._validateEditOperation(rawOperations[i]);\n        }\n        return result;\n    }\n    pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            return this._pushEditOperations(beforeCursorState, this._validateEditOperations(editOperations), cursorStateComputer, group);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _pushEditOperations(beforeCursorState, editOperations, cursorStateComputer, group) {\n        if (this._options.trimAutoWhitespace && this._trimAutoWhitespaceLines) {\n            // Go through each saved line number and insert a trim whitespace edit\n            // if it is safe to do so (no conflicts with other edits).\n            const incomingEdits = editOperations.map((op) => {\n                return {\n                    range: this.validateRange(op.range),\n                    text: op.text\n                };\n            });\n            // Sometimes, auto-formatters change ranges automatically which can cause undesired auto whitespace trimming near the cursor\n            // We'll use the following heuristic: if the edits occur near the cursor, then it's ok to trim auto whitespace\n            let editsAreNearCursors = true;\n            if (beforeCursorState) {\n                for (let i = 0, len = beforeCursorState.length; i < len; i++) {\n                    const sel = beforeCursorState[i];\n                    let foundEditNearSel = false;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const selIsAbove = editRange.startLineNumber > sel.endLineNumber;\n                        const selIsBelow = sel.startLineNumber > editRange.endLineNumber;\n                        if (!selIsAbove && !selIsBelow) {\n                            foundEditNearSel = true;\n                            break;\n                        }\n                    }\n                    if (!foundEditNearSel) {\n                        editsAreNearCursors = false;\n                        break;\n                    }\n                }\n            }\n            if (editsAreNearCursors) {\n                for (let i = 0, len = this._trimAutoWhitespaceLines.length; i < len; i++) {\n                    const trimLineNumber = this._trimAutoWhitespaceLines[i];\n                    const maxLineColumn = this.getLineMaxColumn(trimLineNumber);\n                    let allowTrimLine = true;\n                    for (let j = 0, lenJ = incomingEdits.length; j < lenJ; j++) {\n                        const editRange = incomingEdits[j].range;\n                        const editText = incomingEdits[j].text;\n                        if (trimLineNumber < editRange.startLineNumber || trimLineNumber > editRange.endLineNumber) {\n                            // `trimLine` is completely outside this edit\n                            continue;\n                        }\n                        // At this point:\n                        //   editRange.startLineNumber <= trimLine <= editRange.endLineNumber\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === maxLineColumn\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(0) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) after `trimLine`\n                            continue;\n                        }\n                        if (trimLineNumber === editRange.startLineNumber && editRange.startColumn === 1\n                            && editRange.isEmpty() && editText && editText.length > 0 && editText.charAt(editText.length - 1) === '\\n') {\n                            // This edit inserts a new line (and maybe other text) before `trimLine`\n                            continue;\n                        }\n                        // Looks like we can't trim this line as it would interfere with an incoming edit\n                        allowTrimLine = false;\n                        break;\n                    }\n                    if (allowTrimLine) {\n                        const trimRange = new Range(trimLineNumber, 1, trimLineNumber, maxLineColumn);\n                        editOperations.push(new model.ValidAnnotatedEditOperation(null, trimRange, null, false, false, false));\n                    }\n                }\n            }\n            this._trimAutoWhitespaceLines = null;\n        }\n        if (this._initialUndoRedoSnapshot === null) {\n            this._initialUndoRedoSnapshot = this._undoRedoService.createSnapshot(this.uri);\n        }\n        return this._commandManager.pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group);\n    }\n    _applyUndo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.newPosition);\n            const rangeEnd = this.getPositionAt(change.newEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.oldText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, true, false, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyRedo(changes, eol, resultingAlternativeVersionId, resultingSelection) {\n        const edits = changes.map((change) => {\n            const rangeStart = this.getPositionAt(change.oldPosition);\n            const rangeEnd = this.getPositionAt(change.oldEnd);\n            return {\n                range: new Range(rangeStart.lineNumber, rangeStart.column, rangeEnd.lineNumber, rangeEnd.column),\n                text: change.newText\n            };\n        });\n        this._applyUndoRedoEdits(edits, eol, false, true, resultingAlternativeVersionId, resultingSelection);\n    }\n    _applyUndoRedoEdits(edits, eol, isUndoing, isRedoing, resultingAlternativeVersionId, resultingSelection) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            this._isUndoing = isUndoing;\n            this._isRedoing = isRedoing;\n            this.applyEdits(edits, false);\n            this.setEOL(eol);\n            this._overwriteAlternativeVersionId(resultingAlternativeVersionId);\n        }\n        finally {\n            this._isUndoing = false;\n            this._isRedoing = false;\n            this._eventEmitter.endDeferredEmit(resultingSelection);\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    applyEdits(rawOperations, computeUndoEdits = false) {\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            this._eventEmitter.beginDeferredEmit();\n            const operations = this._validateEditOperations(rawOperations);\n            return this._doApplyEdits(operations, computeUndoEdits);\n        }\n        finally {\n            this._eventEmitter.endDeferredEmit();\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _doApplyEdits(rawOperations, computeUndoEdits) {\n        const oldLineCount = this._buffer.getLineCount();\n        const result = this._buffer.applyEdits(rawOperations, this._options.trimAutoWhitespace, computeUndoEdits);\n        const newLineCount = this._buffer.getLineCount();\n        const contentChanges = result.changes;\n        this._trimAutoWhitespaceLines = result.trimAutoWhitespaceLineNumbers;\n        if (contentChanges.length !== 0) {\n            // We do a first pass to update decorations\n            // because we want to read decorations in the second pass\n            // where we will emit content change events\n            // and we want to read the final decorations\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                this._decorationsTree.acceptReplace(change.rangeOffset, change.rangeLength, change.text.length, change.forceMoveMarkers);\n            }\n            const rawContentChanges = [];\n            this._increaseVersionId();\n            let lineCount = oldLineCount;\n            for (let i = 0, len = contentChanges.length; i < len; i++) {\n                const change = contentChanges[i];\n                const [eolCount] = countEOL(change.text);\n                this._onDidChangeDecorations.fire();\n                const startLineNumber = change.range.startLineNumber;\n                const endLineNumber = change.range.endLineNumber;\n                const deletingLinesCnt = endLineNumber - startLineNumber;\n                const insertingLinesCnt = eolCount;\n                const editingLinesCnt = Math.min(deletingLinesCnt, insertingLinesCnt);\n                const changeLineCountDelta = (insertingLinesCnt - deletingLinesCnt);\n                const currentEditStartLineNumber = newLineCount - lineCount - changeLineCountDelta + startLineNumber;\n                const firstEditLineNumber = currentEditStartLineNumber;\n                const lastInsertedLineNumber = currentEditStartLineNumber + insertingLinesCnt;\n                const decorationsWithInjectedTextInEditedRange = this._decorationsTree.getInjectedTextInInterval(this, this.getOffsetAt(new Position(firstEditLineNumber, 1)), this.getOffsetAt(new Position(lastInsertedLineNumber, this.getLineMaxColumn(lastInsertedLineNumber))), 0);\n                const injectedTextInEditedRange = LineInjectedText.fromDecorations(decorationsWithInjectedTextInEditedRange);\n                const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                for (let j = editingLinesCnt; j >= 0; j--) {\n                    const editLineNumber = startLineNumber + j;\n                    const currentEditLineNumber = currentEditStartLineNumber + j;\n                    injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber > currentEditLineNumber);\n                    const decorationsInCurrentLine = injectedTextInEditedRangeQueue.takeFromEndWhile(r => r.lineNumber === currentEditLineNumber);\n                    rawContentChanges.push(new ModelRawLineChanged(editLineNumber, this.getLineContent(currentEditLineNumber), decorationsInCurrentLine));\n                }\n                if (editingLinesCnt < deletingLinesCnt) {\n                    // Must delete some lines\n                    const spliceStartLineNumber = startLineNumber + editingLinesCnt;\n                    rawContentChanges.push(new ModelRawLinesDeleted(spliceStartLineNumber + 1, endLineNumber));\n                }\n                if (editingLinesCnt < insertingLinesCnt) {\n                    const injectedTextInEditedRangeQueue = new ArrayQueue(injectedTextInEditedRange);\n                    // Must insert some lines\n                    const spliceLineNumber = startLineNumber + editingLinesCnt;\n                    const cnt = insertingLinesCnt - editingLinesCnt;\n                    const fromLineNumber = newLineCount - lineCount - cnt + spliceLineNumber + 1;\n                    const injectedTexts = [];\n                    const newLines = [];\n                    for (let i = 0; i < cnt; i++) {\n                        const lineNumber = fromLineNumber + i;\n                        newLines[i] = this.getLineContent(lineNumber);\n                        injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber < lineNumber);\n                        injectedTexts[i] = injectedTextInEditedRangeQueue.takeWhile(r => r.lineNumber === lineNumber);\n                    }\n                    rawContentChanges.push(new ModelRawLinesInserted(spliceLineNumber + 1, startLineNumber + insertingLinesCnt, newLines, injectedTexts));\n                }\n                lineCount += changeLineCountDelta;\n            }\n            this._emitContentChangedEvent(new ModelRawContentChangedEvent(rawContentChanges, this.getVersionId(), this._isUndoing, this._isRedoing), {\n                changes: contentChanges,\n                eol: this._buffer.getEOL(),\n                isEolChange: false,\n                versionId: this.getVersionId(),\n                isUndoing: this._isUndoing,\n                isRedoing: this._isRedoing,\n                isFlush: false\n            });\n        }\n        return (result.reverseEdits === null ? undefined : result.reverseEdits);\n    }\n    undo() {\n        return this._undoRedoService.undo(this.uri);\n    }\n    canUndo() {\n        return this._undoRedoService.canUndo(this.uri);\n    }\n    redo() {\n        return this._undoRedoService.redo(this.uri);\n    }\n    canRedo() {\n        return this._undoRedoService.canRedo(this.uri);\n    }\n    //#endregion\n    //#region Decorations\n    handleBeforeFireDecorationsChangedEvent(affectedInjectedTextLines) {\n        // This is called before the decoration changed event is fired.\n        if (affectedInjectedTextLines === null || affectedInjectedTextLines.size === 0) {\n            return;\n        }\n        const affectedLines = Array.from(affectedInjectedTextLines);\n        const lineChangeEvents = affectedLines.map(lineNumber => new ModelRawLineChanged(lineNumber, this.getLineContent(lineNumber), this._getInjectedTextInLine(lineNumber)));\n        this._onDidChangeInjectedText.fire(new ModelInjectedTextChangedEvent(lineChangeEvents));\n    }\n    changeDecorations(callback, ownerId = 0) {\n        this._assertNotDisposed();\n        try {\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._changeDecorations(ownerId, callback);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    _changeDecorations(ownerId, callback) {\n        const changeAccessor = {\n            addDecoration: (range, options) => {\n                return this._deltaDecorationsImpl(ownerId, [], [{ range: range, options: options }])[0];\n            },\n            changeDecoration: (id, newRange) => {\n                this._changeDecorationImpl(id, newRange);\n            },\n            changeDecorationOptions: (id, options) => {\n                this._changeDecorationOptionsImpl(id, _normalizeOptions(options));\n            },\n            removeDecoration: (id) => {\n                this._deltaDecorationsImpl(ownerId, [id], []);\n            },\n            deltaDecorations: (oldDecorations, newDecorations) => {\n                if (oldDecorations.length === 0 && newDecorations.length === 0) {\n                    // nothing to do\n                    return [];\n                }\n                return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n            }\n        };\n        let result = null;\n        try {\n            result = callback(changeAccessor);\n        }\n        catch (e) {\n            onUnexpectedError(e);\n        }\n        // Invalidate change accessor\n        changeAccessor.addDecoration = invalidFunc;\n        changeAccessor.changeDecoration = invalidFunc;\n        changeAccessor.changeDecorationOptions = invalidFunc;\n        changeAccessor.removeDecoration = invalidFunc;\n        changeAccessor.deltaDecorations = invalidFunc;\n        return result;\n    }\n    deltaDecorations(oldDecorations, newDecorations, ownerId = 0) {\n        this._assertNotDisposed();\n        if (!oldDecorations) {\n            oldDecorations = [];\n        }\n        if (oldDecorations.length === 0 && newDecorations.length === 0) {\n            // nothing to do\n            return [];\n        }\n        try {\n            this._deltaDecorationCallCnt++;\n            if (this._deltaDecorationCallCnt > 1) {\n                console.warn(`Invoking deltaDecorations recursively could lead to leaking decorations.`);\n                onUnexpectedError(new Error(`Invoking deltaDecorations recursively could lead to leaking decorations.`));\n            }\n            this._onDidChangeDecorations.beginDeferredEmit();\n            return this._deltaDecorationsImpl(ownerId, oldDecorations, newDecorations);\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n            this._deltaDecorationCallCnt--;\n        }\n    }\n    _getTrackedRange(id) {\n        return this.getDecorationRange(id);\n    }\n    _setTrackedRange(id, newRange, newStickiness) {\n        const node = (id ? this._decorations[id] : null);\n        if (!node) {\n            if (!newRange) {\n                // node doesn't exist, the request is to delete => nothing to do\n                return null;\n            }\n            // node doesn't exist, the request is to set => add the tracked range\n            return this._deltaDecorationsImpl(0, [], [{ range: newRange, options: TRACKED_RANGE_OPTIONS[newStickiness] }], true)[0];\n        }\n        if (!newRange) {\n            // node exists, the request is to delete => delete node\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n            return null;\n        }\n        // node exists, the request is to set => change the tracked range and its options\n        const range = this._validateRangeRelaxedNoAllocations(newRange);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        node.setOptions(TRACKED_RANGE_OPTIONS[newStickiness]);\n        this._decorationsTree.insert(node);\n        return node.id;\n    }\n    removeAllDecorationsWithOwnerId(ownerId) {\n        if (this._isDisposed) {\n            return;\n        }\n        const nodes = this._decorationsTree.collectNodesFromOwner(ownerId);\n        for (let i = 0, len = nodes.length; i < len; i++) {\n            const node = nodes[i];\n            this._decorationsTree.delete(node);\n            delete this._decorations[node.id];\n        }\n    }\n    getDecorationOptions(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return node.options;\n    }\n    getDecorationRange(decorationId) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return null;\n        }\n        return this._decorationsTree.getNodeRange(this, node);\n    }\n    getLineDecorations(lineNumber, ownerId = 0, filterOutValidation = false) {\n        if (lineNumber < 1 || lineNumber > this.getLineCount()) {\n            return [];\n        }\n        return this.getLinesDecorations(lineNumber, lineNumber, ownerId, filterOutValidation);\n    }\n    getLinesDecorations(_startLineNumber, _endLineNumber, ownerId = 0, filterOutValidation = false, onlyMarginDecorations = false) {\n        const lineCount = this.getLineCount();\n        const startLineNumber = Math.min(lineCount, Math.max(1, _startLineNumber));\n        const endLineNumber = Math.min(lineCount, Math.max(1, _endLineNumber));\n        const endColumn = this.getLineMaxColumn(endLineNumber);\n        const range = new Range(startLineNumber, 1, endLineNumber, endColumn);\n        const decorations = this._getDecorationsInRange(range, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(range, ownerId, filterOutValidation));\n        return decorations;\n    }\n    getDecorationsInRange(range, ownerId = 0, filterOutValidation = false, onlyMinimapDecorations = false, onlyMarginDecorations = false) {\n        const validatedRange = this.validateRange(range);\n        const decorations = this._getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMarginDecorations);\n        pushMany(decorations, this._decorationProvider.getDecorationsInRange(validatedRange, ownerId, filterOutValidation, onlyMinimapDecorations));\n        return decorations;\n    }\n    getOverviewRulerDecorations(ownerId = 0, filterOutValidation = false) {\n        return this._decorationsTree.getAll(this, ownerId, filterOutValidation, true, false);\n    }\n    getInjectedTextDecorations(ownerId = 0) {\n        return this._decorationsTree.getAllInjectedText(this, ownerId);\n    }\n    _getInjectedTextInLine(lineNumber) {\n        const startOffset = this._buffer.getOffsetAt(lineNumber, 1);\n        const endOffset = startOffset + this._buffer.getLineLength(lineNumber);\n        const result = this._decorationsTree.getInjectedTextInInterval(this, startOffset, endOffset, 0);\n        return LineInjectedText.fromDecorations(result).filter(t => t.lineNumber === lineNumber);\n    }\n    getAllDecorations(ownerId = 0, filterOutValidation = false) {\n        let result = this._decorationsTree.getAll(this, ownerId, filterOutValidation, false, false);\n        result = result.concat(this._decorationProvider.getAllDecorations(ownerId, filterOutValidation));\n        return result;\n    }\n    getAllMarginDecorations(ownerId = 0) {\n        return this._decorationsTree.getAll(this, ownerId, false, false, true);\n    }\n    _getDecorationsInRange(filterRange, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const startOffset = this._buffer.getOffsetAt(filterRange.startLineNumber, filterRange.startColumn);\n        const endOffset = this._buffer.getOffsetAt(filterRange.endLineNumber, filterRange.endColumn);\n        return this._decorationsTree.getAllInInterval(this, startOffset, endOffset, filterOwnerId, filterOutValidation, onlyMarginDecorations);\n    }\n    getRangeAt(start, end) {\n        return this._buffer.getRangeAt(start, end - start);\n    }\n    _changeDecorationImpl(decorationId, _range) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        if (node.options.after) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.endLineNumber);\n        }\n        if (node.options.before) {\n            const oldRange = this.getDecorationRange(decorationId);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(oldRange.startLineNumber);\n        }\n        const range = this._validateRangeRelaxedNoAllocations(_range);\n        const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n        const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n        this._decorationsTree.delete(node);\n        node.reset(this.getVersionId(), startOffset, endOffset, range);\n        this._decorationsTree.insert(node);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        if (node.options.after) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n        }\n        if (node.options.before) {\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n        }\n    }\n    _changeDecorationOptionsImpl(decorationId, options) {\n        const node = this._decorations[decorationId];\n        if (!node) {\n            return;\n        }\n        const nodeWasInOverviewRuler = (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n        const nodeIsInOverviewRuler = (options.overviewRuler && options.overviewRuler.color ? true : false);\n        this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n        this._onDidChangeDecorations.checkAffectedAndFire(options);\n        if (node.options.after || options.after) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n        }\n        if (node.options.before || options.before) {\n            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n        }\n        const movedInOverviewRuler = nodeWasInOverviewRuler !== nodeIsInOverviewRuler;\n        const changedWhetherInjectedText = isOptionsInjectedText(options) !== isNodeInjectedText(node);\n        if (movedInOverviewRuler || changedWhetherInjectedText) {\n            this._decorationsTree.delete(node);\n            node.setOptions(options);\n            this._decorationsTree.insert(node);\n        }\n        else {\n            node.setOptions(options);\n        }\n    }\n    _deltaDecorationsImpl(ownerId, oldDecorationsIds, newDecorations, suppressEvents = false) {\n        const versionId = this.getVersionId();\n        const oldDecorationsLen = oldDecorationsIds.length;\n        let oldDecorationIndex = 0;\n        const newDecorationsLen = newDecorations.length;\n        let newDecorationIndex = 0;\n        this._onDidChangeDecorations.beginDeferredEmit();\n        try {\n            const result = new Array(newDecorationsLen);\n            while (oldDecorationIndex < oldDecorationsLen || newDecorationIndex < newDecorationsLen) {\n                let node = null;\n                if (oldDecorationIndex < oldDecorationsLen) {\n                    // (1) get ourselves an old node\n                    do {\n                        node = this._decorations[oldDecorationsIds[oldDecorationIndex++]];\n                    } while (!node && oldDecorationIndex < oldDecorationsLen);\n                    // (2) remove the node from the tree (if it exists)\n                    if (node) {\n                        if (node.options.after) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.endLineNumber);\n                        }\n                        if (node.options.before) {\n                            const nodeRange = this._decorationsTree.getNodeRange(this, node);\n                            this._onDidChangeDecorations.recordLineAffectedByInjectedText(nodeRange.startLineNumber);\n                        }\n                        this._decorationsTree.delete(node);\n                        if (!suppressEvents) {\n                            this._onDidChangeDecorations.checkAffectedAndFire(node.options);\n                        }\n                    }\n                }\n                if (newDecorationIndex < newDecorationsLen) {\n                    // (3) create a new node if necessary\n                    if (!node) {\n                        const internalDecorationId = (++this._lastDecorationId);\n                        const decorationId = `${this._instanceId};${internalDecorationId}`;\n                        node = new IntervalNode(decorationId, 0, 0);\n                        this._decorations[decorationId] = node;\n                    }\n                    // (4) initialize node\n                    const newDecoration = newDecorations[newDecorationIndex];\n                    const range = this._validateRangeRelaxedNoAllocations(newDecoration.range);\n                    const options = _normalizeOptions(newDecoration.options);\n                    const startOffset = this._buffer.getOffsetAt(range.startLineNumber, range.startColumn);\n                    const endOffset = this._buffer.getOffsetAt(range.endLineNumber, range.endColumn);\n                    node.ownerId = ownerId;\n                    node.reset(versionId, startOffset, endOffset, range);\n                    node.setOptions(options);\n                    if (node.options.after) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.endLineNumber);\n                    }\n                    if (node.options.before) {\n                        this._onDidChangeDecorations.recordLineAffectedByInjectedText(range.startLineNumber);\n                    }\n                    if (!suppressEvents) {\n                        this._onDidChangeDecorations.checkAffectedAndFire(options);\n                    }\n                    this._decorationsTree.insert(node);\n                    result[newDecorationIndex] = node.id;\n                    newDecorationIndex++;\n                }\n                else {\n                    if (node) {\n                        delete this._decorations[node.id];\n                    }\n                }\n            }\n            return result;\n        }\n        finally {\n            this._onDidChangeDecorations.endDeferredEmit();\n        }\n    }\n    //#endregion\n    //#region Tokenization\n    // TODO move them to the tokenization part.\n    getLanguageId() {\n        return this.tokenization.getLanguageId();\n    }\n    setLanguage(languageIdOrSelection, source) {\n        if (typeof languageIdOrSelection === 'string') {\n            this._languageSelectionListener.clear();\n            this._setLanguage(languageIdOrSelection, source);\n        }\n        else {\n            this._languageSelectionListener.value = languageIdOrSelection.onDidChange(() => this._setLanguage(languageIdOrSelection.languageId, source));\n            this._setLanguage(languageIdOrSelection.languageId, source);\n        }\n    }\n    _setLanguage(languageId, source) {\n        this.tokenization.setLanguageId(languageId, source);\n        this._languageService.requestRichLanguageFeatures(languageId);\n    }\n    getLanguageIdAtPosition(lineNumber, column) {\n        return this.tokenization.getLanguageIdAtPosition(lineNumber, column);\n    }\n    getWordAtPosition(position) {\n        return this._tokenizationTextModelPart.getWordAtPosition(position);\n    }\n    getWordUntilPosition(position) {\n        return this._tokenizationTextModelPart.getWordUntilPosition(position);\n    }\n    //#endregion\n    normalizePosition(position, affinity) {\n        return position;\n    }\n    /**\n     * Gets the column at which indentation stops at a given line.\n     * @internal\n    */\n    getLineIndentColumn(lineNumber) {\n        // Columns start with 1.\n        return indentOfLine(this.getLineContent(lineNumber)) + 1;\n    }\n};\nTextModel = TextModel_1 = __decorate([\n    __param(4, IUndoRedoService),\n    __param(5, ILanguageService),\n    __param(6, ILanguageConfigurationService),\n    __param(7, IInstantiationService)\n], TextModel);\nexport { TextModel };\nexport function indentOfLine(line) {\n    let indent = 0;\n    for (const c of line) {\n        if (c === ' ' || c === '\\t') {\n            indent++;\n        }\n        else {\n            break;\n        }\n    }\n    return indent;\n}\n//#region Decorations\nfunction isNodeInOverviewRuler(node) {\n    return (node.options.overviewRuler && node.options.overviewRuler.color ? true : false);\n}\nfunction isOptionsInjectedText(options) {\n    return !!options.after || !!options.before;\n}\nfunction isNodeInjectedText(node) {\n    return !!node.options.after || !!node.options.before;\n}\nclass DecorationsTrees {\n    constructor() {\n        this._decorationsTree0 = new IntervalTree();\n        this._decorationsTree1 = new IntervalTree();\n        this._injectedTextDecorationsTree = new IntervalTree();\n    }\n    ensureAllNodesHaveRanges(host) {\n        this.getAll(host, 0, false, false, false);\n    }\n    _ensureNodesHaveRanges(host, nodes) {\n        for (const node of nodes) {\n            if (node.range === null) {\n                node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n            }\n        }\n        return nodes;\n    }\n    getAllInInterval(host, start, end, filterOwnerId, filterOutValidation, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._intervalSearch(start, end, filterOwnerId, filterOutValidation, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations) {\n        const r0 = this._decorationsTree0.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r1 = this._decorationsTree1.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        const r2 = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        return r0.concat(r1).concat(r2);\n    }\n    getInjectedTextInInterval(host, start, end, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.intervalSearch(start, end, filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAllInjectedText(host, filterOwnerId) {\n        const versionId = host.getVersionId();\n        const result = this._injectedTextDecorationsTree.search(filterOwnerId, false, versionId, false);\n        return this._ensureNodesHaveRanges(host, result).filter((i) => i.options.showIfCollapsed || !i.range.isEmpty());\n    }\n    getAll(host, filterOwnerId, filterOutValidation, overviewRulerOnly, onlyMarginDecorations) {\n        const versionId = host.getVersionId();\n        const result = this._search(filterOwnerId, filterOutValidation, overviewRulerOnly, versionId, onlyMarginDecorations);\n        return this._ensureNodesHaveRanges(host, result);\n    }\n    _search(filterOwnerId, filterOutValidation, overviewRulerOnly, cachedVersionId, onlyMarginDecorations) {\n        if (overviewRulerOnly) {\n            return this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n        }\n        else {\n            const r0 = this._decorationsTree0.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r1 = this._decorationsTree1.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            const r2 = this._injectedTextDecorationsTree.search(filterOwnerId, filterOutValidation, cachedVersionId, onlyMarginDecorations);\n            return r0.concat(r1).concat(r2);\n        }\n    }\n    collectNodesFromOwner(ownerId) {\n        const r0 = this._decorationsTree0.collectNodesFromOwner(ownerId);\n        const r1 = this._decorationsTree1.collectNodesFromOwner(ownerId);\n        const r2 = this._injectedTextDecorationsTree.collectNodesFromOwner(ownerId);\n        return r0.concat(r1).concat(r2);\n    }\n    collectNodesPostOrder() {\n        const r0 = this._decorationsTree0.collectNodesPostOrder();\n        const r1 = this._decorationsTree1.collectNodesPostOrder();\n        const r2 = this._injectedTextDecorationsTree.collectNodesPostOrder();\n        return r0.concat(r1).concat(r2);\n    }\n    insert(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.insert(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.insert(node);\n        }\n        else {\n            this._decorationsTree0.insert(node);\n        }\n    }\n    delete(node) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.delete(node);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.delete(node);\n        }\n        else {\n            this._decorationsTree0.delete(node);\n        }\n    }\n    getNodeRange(host, node) {\n        const versionId = host.getVersionId();\n        if (node.cachedVersionId !== versionId) {\n            this._resolveNode(node, versionId);\n        }\n        if (node.range === null) {\n            node.range = host.getRangeAt(node.cachedAbsoluteStart, node.cachedAbsoluteEnd);\n        }\n        return node.range;\n    }\n    _resolveNode(node, cachedVersionId) {\n        if (isNodeInjectedText(node)) {\n            this._injectedTextDecorationsTree.resolveNode(node, cachedVersionId);\n        }\n        else if (isNodeInOverviewRuler(node)) {\n            this._decorationsTree1.resolveNode(node, cachedVersionId);\n        }\n        else {\n            this._decorationsTree0.resolveNode(node, cachedVersionId);\n        }\n    }\n    acceptReplace(offset, length, textLength, forceMoveMarkers) {\n        this._decorationsTree0.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._decorationsTree1.acceptReplace(offset, length, textLength, forceMoveMarkers);\n        this._injectedTextDecorationsTree.acceptReplace(offset, length, textLength, forceMoveMarkers);\n    }\n}\nfunction cleanClassName(className) {\n    return className.replace(/[^a-z0-9\\-_]/gi, ' ');\n}\nclass DecorationOptions {\n    constructor(options) {\n        this.color = options.color || '';\n        this.darkColor = options.darkColor || '';\n    }\n}\nexport class ModelDecorationOverviewRulerOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this._resolvedColor = null;\n        this.position = (typeof options.position === 'number' ? options.position : model.OverviewRulerLane.Center);\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = null;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return color;\n        }\n        const c = color ? theme.getColor(color.id) : null;\n        if (!c) {\n            return '';\n        }\n        return c.toString();\n    }\n}\nexport class ModelDecorationGlyphMarginOptions {\n    constructor(options) {\n        this.position = options?.position ?? model.GlyphMarginLane.Center;\n        this.persistLane = options?.persistLane;\n    }\n}\nexport class ModelDecorationMinimapOptions extends DecorationOptions {\n    constructor(options) {\n        super(options);\n        this.position = options.position;\n        this.sectionHeaderStyle = options.sectionHeaderStyle ?? null;\n        this.sectionHeaderText = options.sectionHeaderText ?? null;\n    }\n    getColor(theme) {\n        if (!this._resolvedColor) {\n            if (theme.type !== 'light' && this.darkColor) {\n                this._resolvedColor = this._resolveColor(this.darkColor, theme);\n            }\n            else {\n                this._resolvedColor = this._resolveColor(this.color, theme);\n            }\n        }\n        return this._resolvedColor;\n    }\n    invalidateCachedColor() {\n        this._resolvedColor = undefined;\n    }\n    _resolveColor(color, theme) {\n        if (typeof color === 'string') {\n            return Color.fromHex(color);\n        }\n        return theme.getColor(color.id);\n    }\n}\nexport class ModelDecorationInjectedTextOptions {\n    static from(options) {\n        if (options instanceof ModelDecorationInjectedTextOptions) {\n            return options;\n        }\n        return new ModelDecorationInjectedTextOptions(options);\n    }\n    constructor(options) {\n        this.content = options.content || '';\n        this.inlineClassName = options.inlineClassName || null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.attachedData = options.attachedData || null;\n        this.cursorStops = options.cursorStops || null;\n    }\n}\nexport class ModelDecorationOptions {\n    static register(options) {\n        return new ModelDecorationOptions(options);\n    }\n    static createDynamic(options) {\n        return new ModelDecorationOptions(options);\n    }\n    constructor(options) {\n        this.description = options.description;\n        this.blockClassName = options.blockClassName ? cleanClassName(options.blockClassName) : null;\n        this.blockDoesNotCollapse = options.blockDoesNotCollapse ?? null;\n        this.blockIsAfterEnd = options.blockIsAfterEnd ?? null;\n        this.blockPadding = options.blockPadding ?? null;\n        this.stickiness = options.stickiness || 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */;\n        this.zIndex = options.zIndex || 0;\n        this.className = options.className ? cleanClassName(options.className) : null;\n        this.shouldFillLineOnLineBreak = options.shouldFillLineOnLineBreak ?? null;\n        this.hoverMessage = options.hoverMessage || null;\n        this.glyphMarginHoverMessage = options.glyphMarginHoverMessage || null;\n        this.lineNumberHoverMessage = options.lineNumberHoverMessage || null;\n        this.isWholeLine = options.isWholeLine || false;\n        this.showIfCollapsed = options.showIfCollapsed || false;\n        this.collapseOnReplaceEdit = options.collapseOnReplaceEdit || false;\n        this.overviewRuler = options.overviewRuler ? new ModelDecorationOverviewRulerOptions(options.overviewRuler) : null;\n        this.minimap = options.minimap ? new ModelDecorationMinimapOptions(options.minimap) : null;\n        this.glyphMargin = options.glyphMarginClassName ? new ModelDecorationGlyphMarginOptions(options.glyphMargin) : null;\n        this.glyphMarginClassName = options.glyphMarginClassName ? cleanClassName(options.glyphMarginClassName) : null;\n        this.linesDecorationsClassName = options.linesDecorationsClassName ? cleanClassName(options.linesDecorationsClassName) : null;\n        this.lineNumberClassName = options.lineNumberClassName ? cleanClassName(options.lineNumberClassName) : null;\n        this.linesDecorationsTooltip = options.linesDecorationsTooltip ? strings.htmlAttributeEncodeValue(options.linesDecorationsTooltip) : null;\n        this.firstLineDecorationClassName = options.firstLineDecorationClassName ? cleanClassName(options.firstLineDecorationClassName) : null;\n        this.marginClassName = options.marginClassName ? cleanClassName(options.marginClassName) : null;\n        this.inlineClassName = options.inlineClassName ? cleanClassName(options.inlineClassName) : null;\n        this.inlineClassNameAffectsLetterSpacing = options.inlineClassNameAffectsLetterSpacing || false;\n        this.beforeContentClassName = options.beforeContentClassName ? cleanClassName(options.beforeContentClassName) : null;\n        this.afterContentClassName = options.afterContentClassName ? cleanClassName(options.afterContentClassName) : null;\n        this.after = options.after ? ModelDecorationInjectedTextOptions.from(options.after) : null;\n        this.before = options.before ? ModelDecorationInjectedTextOptions.from(options.before) : null;\n        this.hideInCommentTokens = options.hideInCommentTokens ?? false;\n        this.hideInStringTokens = options.hideInStringTokens ?? false;\n    }\n}\nModelDecorationOptions.EMPTY = ModelDecorationOptions.register({ description: 'empty' });\n/**\n * The order carefully matches the values of the enum.\n */\nconst TRACKED_RANGE_OPTIONS = [\n    ModelDecorationOptions.register({ description: 'tracked-range-always-grows-when-typing-at-edges', stickiness: 0 /* model.TrackedRangeStickiness.AlwaysGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-never-grows-when-typing-at-edges', stickiness: 1 /* model.TrackedRangeStickiness.NeverGrowsWhenTypingAtEdges */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-before', stickiness: 2 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingBefore */ }),\n    ModelDecorationOptions.register({ description: 'tracked-range-grows-only-when-typing-after', stickiness: 3 /* model.TrackedRangeStickiness.GrowsOnlyWhenTypingAfter */ }),\n];\nfunction _normalizeOptions(options) {\n    if (options instanceof ModelDecorationOptions) {\n        return options;\n    }\n    return ModelDecorationOptions.createDynamic(options);\n}\nclass DidChangeDecorationsEmitter extends Disposable {\n    constructor(handleBeforeFire) {\n        super();\n        this.handleBeforeFire = handleBeforeFire;\n        this._actual = this._register(new Emitter());\n        this.event = this._actual.event;\n        this._affectedInjectedTextLines = null;\n        this._deferredCnt = 0;\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._affectsLineNumber = false;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit() {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._shouldFireDeferred) {\n                this.doFire();\n            }\n            this._affectedInjectedTextLines?.clear();\n            this._affectedInjectedTextLines = null;\n        }\n    }\n    recordLineAffectedByInjectedText(lineNumber) {\n        if (!this._affectedInjectedTextLines) {\n            this._affectedInjectedTextLines = new Set();\n        }\n        this._affectedInjectedTextLines.add(lineNumber);\n    }\n    checkAffectedAndFire(options) {\n        this._affectsMinimap ||= !!options.minimap?.position;\n        this._affectsOverviewRuler ||= !!options.overviewRuler?.color;\n        this._affectsGlyphMargin ||= !!options.glyphMarginClassName;\n        this._affectsLineNumber ||= !!options.lineNumberClassName;\n        this.tryFire();\n    }\n    fire() {\n        this._affectsMinimap = true;\n        this._affectsOverviewRuler = true;\n        this._affectsGlyphMargin = true;\n        this.tryFire();\n    }\n    tryFire() {\n        if (this._deferredCnt === 0) {\n            this.doFire();\n        }\n        else {\n            this._shouldFireDeferred = true;\n        }\n    }\n    doFire() {\n        this.handleBeforeFire(this._affectedInjectedTextLines);\n        const event = {\n            affectsMinimap: this._affectsMinimap,\n            affectsOverviewRuler: this._affectsOverviewRuler,\n            affectsGlyphMargin: this._affectsGlyphMargin,\n            affectsLineNumber: this._affectsLineNumber,\n        };\n        this._shouldFireDeferred = false;\n        this._affectsMinimap = false;\n        this._affectsOverviewRuler = false;\n        this._affectsGlyphMargin = false;\n        this._actual.fire(event);\n    }\n}\n//#endregion\nclass DidChangeContentEmitter extends Disposable {\n    constructor() {\n        super();\n        /**\n         * Both `fastEvent` and `slowEvent` work the same way and contain the same events, but first we invoke `fastEvent` and then `slowEvent`.\n         */\n        this._fastEmitter = this._register(new Emitter());\n        this.fastEvent = this._fastEmitter.event;\n        this._slowEmitter = this._register(new Emitter());\n        this.slowEvent = this._slowEmitter.event;\n        this._deferredCnt = 0;\n        this._deferredEvent = null;\n    }\n    beginDeferredEmit() {\n        this._deferredCnt++;\n    }\n    endDeferredEmit(resultingSelection = null) {\n        this._deferredCnt--;\n        if (this._deferredCnt === 0) {\n            if (this._deferredEvent !== null) {\n                this._deferredEvent.rawContentChangedEvent.resultingSelection = resultingSelection;\n                const e = this._deferredEvent;\n                this._deferredEvent = null;\n                this._fastEmitter.fire(e);\n                this._slowEmitter.fire(e);\n            }\n        }\n    }\n    fire(e) {\n        if (this._deferredCnt > 0) {\n            if (this._deferredEvent) {\n                this._deferredEvent = this._deferredEvent.merge(e);\n            }\n            else {\n                this._deferredEvent = e;\n            }\n            return;\n        }\n        this._fastEmitter.fire(e);\n        this._slowEmitter.fire(e);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport * as platform from '../../../base/common/platform.js';\nimport * as buffer from '../../../base/common/buffer.js';\nlet _utf16LE_TextDecoder;\nfunction getUTF16LE_TextDecoder() {\n    if (!_utf16LE_TextDecoder) {\n        _utf16LE_TextDecoder = new TextDecoder('UTF-16LE');\n    }\n    return _utf16LE_TextDecoder;\n}\nlet _utf16BE_TextDecoder;\nfunction getUTF16BE_TextDecoder() {\n    if (!_utf16BE_TextDecoder) {\n        _utf16BE_TextDecoder = new TextDecoder('UTF-16BE');\n    }\n    return _utf16BE_TextDecoder;\n}\nlet _platformTextDecoder;\nexport function getPlatformTextDecoder() {\n    if (!_platformTextDecoder) {\n        _platformTextDecoder = platform.isLittleEndian() ? getUTF16LE_TextDecoder() : getUTF16BE_TextDecoder();\n    }\n    return _platformTextDecoder;\n}\nexport function decodeUTF16LE(source, offset, len) {\n    const view = new Uint16Array(source.buffer, offset, len);\n    if (len > 0 && (view[0] === 0xFEFF || view[0] === 0xFFFE)) {\n        // UTF16 sometimes starts with a BOM https://de.wikipedia.org/wiki/Byte_Order_Mark\n        // It looks like TextDecoder.decode will eat up a leading BOM (0xFEFF or 0xFFFE)\n        // We don't want that behavior because we know the string is UTF16LE and the BOM should be maintained\n        // So we use the manual decoder\n        return compatDecodeUTF16LE(source, offset, len);\n    }\n    return getUTF16LE_TextDecoder().decode(view);\n}\nfunction compatDecodeUTF16LE(source, offset, len) {\n    const result = [];\n    let resultLen = 0;\n    for (let i = 0; i < len; i++) {\n        const charCode = buffer.readUInt16LE(source, offset);\n        offset += 2;\n        result[resultLen++] = String.fromCharCode(charCode);\n    }\n    return result.join('');\n}\nexport class StringBuilder {\n    constructor(capacity) {\n        this._capacity = capacity | 0;\n        this._buffer = new Uint16Array(this._capacity);\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    reset() {\n        this._completedStrings = null;\n        this._bufferLength = 0;\n    }\n    build() {\n        if (this._completedStrings !== null) {\n            this._flushBuffer();\n            return this._completedStrings.join('');\n        }\n        return this._buildBuffer();\n    }\n    _buildBuffer() {\n        if (this._bufferLength === 0) {\n            return '';\n        }\n        const view = new Uint16Array(this._buffer.buffer, 0, this._bufferLength);\n        return getPlatformTextDecoder().decode(view);\n    }\n    _flushBuffer() {\n        const bufferString = this._buildBuffer();\n        this._bufferLength = 0;\n        if (this._completedStrings === null) {\n            this._completedStrings = [bufferString];\n        }\n        else {\n            this._completedStrings[this._completedStrings.length] = bufferString;\n        }\n    }\n    /**\n     * Append a char code (<2^16)\n     */\n    appendCharCode(charCode) {\n        const remainingSpace = this._capacity - this._bufferLength;\n        if (remainingSpace <= 1) {\n            if (remainingSpace === 0 || strings.isHighSurrogate(charCode)) {\n                this._flushBuffer();\n            }\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    /**\n     * Append an ASCII char code (<2^8)\n     */\n    appendASCIICharCode(charCode) {\n        if (this._bufferLength === this._capacity) {\n            // buffer is full\n            this._flushBuffer();\n        }\n        this._buffer[this._bufferLength++] = charCode;\n    }\n    appendString(str) {\n        const strLen = str.length;\n        if (this._bufferLength + strLen >= this._capacity) {\n            // This string does not fit in the remaining buffer space\n            this._flushBuffer();\n            this._completedStrings[this._completedStrings.length] = str;\n            return;\n        }\n        for (let i = 0; i < strLen; i++) {\n            this._buffer[this._bufferLength++] = str.charCodeAt(i);\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { SyncDescriptor } from './descriptors.js';\nconst _registry = [];\nexport function registerSingleton(id, ctorOrDescriptor, supportsDelayedInstantiation) {\n    if (!(ctorOrDescriptor instanceof SyncDescriptor)) {\n        ctorOrDescriptor = new SyncDescriptor(ctorOrDescriptor, [], Boolean(supportsDelayedInstantiation));\n    }\n    _registry.push([id, ctorOrDescriptor]);\n}\nexport function getSingletonServiceDescriptors() {\n    return _registry;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Lazy } from './lazy.js';\nconst hasBuffer = (typeof Buffer !== 'undefined');\nconst indexOfTable = new Lazy(() => new Uint8Array(256));\nlet textDecoder;\nexport class VSBuffer {\n    /**\n     * When running in a nodejs context, if `actual` is not a nodejs Buffer, the backing store for\n     * the returned `VSBuffer` instance might use a nodejs Buffer allocated from node's Buffer pool,\n     * which is not transferrable.\n     */\n    static wrap(actual) {\n        if (hasBuffer && !(Buffer.isBuffer(actual))) {\n            // https://nodejs.org/dist/latest-v10.x/docs/api/buffer.html#buffer_class_method_buffer_from_arraybuffer_byteoffset_length\n            // Create a zero-copy Buffer wrapper around the ArrayBuffer pointed to by the Uint8Array\n            actual = Buffer.from(actual.buffer, actual.byteOffset, actual.byteLength);\n        }\n        return new VSBuffer(actual);\n    }\n    constructor(buffer) {\n        this.buffer = buffer;\n        this.byteLength = this.buffer.byteLength;\n    }\n    toString() {\n        if (hasBuffer) {\n            return this.buffer.toString();\n        }\n        else {\n            if (!textDecoder) {\n                textDecoder = new TextDecoder();\n            }\n            return textDecoder.decode(this.buffer);\n        }\n    }\n}\nexport function readUInt16LE(source, offset) {\n    return (((source[offset + 0] << 0) >>> 0) |\n        ((source[offset + 1] << 8) >>> 0));\n}\nexport function writeUInt16LE(destination, value, offset) {\n    destination[offset + 0] = (value & 0b11111111);\n    value = value >>> 8;\n    destination[offset + 1] = (value & 0b11111111);\n}\nexport function readUInt32BE(source, offset) {\n    return (source[offset] * 2 ** 24\n        + source[offset + 1] * 2 ** 16\n        + source[offset + 2] * 2 ** 8\n        + source[offset + 3]);\n}\nexport function writeUInt32BE(destination, value, offset) {\n    destination[offset + 3] = value;\n    value = value >>> 8;\n    destination[offset + 2] = value;\n    value = value >>> 8;\n    destination[offset + 1] = value;\n    value = value >>> 8;\n    destination[offset] = value;\n}\nexport function readUInt8(source, offset) {\n    return source[offset];\n}\nexport function writeUInt8(destination, value, offset) {\n    destination[offset] = value;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Range } from '../../../core/range.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthLessThanEqual, lengthOfString, lengthToObj, positionToLength, toLength } from './length.js';\nexport class TextEditInfo {\n    static fromModelContentChanges(changes) {\n        // Must be sorted in ascending order\n        const edits = changes.map(c => {\n            const range = Range.lift(c.range);\n            return new TextEditInfo(positionToLength(range.getStartPosition()), positionToLength(range.getEndPosition()), lengthOfString(c.text));\n        }).reverse();\n        return edits;\n    }\n    constructor(startOffset, endOffset, newLength) {\n        this.startOffset = startOffset;\n        this.endOffset = endOffset;\n        this.newLength = newLength;\n    }\n    toString() {\n        return `[${lengthToObj(this.startOffset)}...${lengthToObj(this.endOffset)}) -> ${lengthToObj(this.newLength)}`;\n    }\n}\nexport class BeforeEditPositionMapper {\n    /**\n     * @param edits Must be sorted by offset in ascending order.\n    */\n    constructor(edits) {\n        this.nextEditIdx = 0;\n        this.deltaOldToNewLineCount = 0;\n        this.deltaOldToNewColumnCount = 0;\n        this.deltaLineIdxInOld = -1;\n        this.edits = edits.map(edit => TextEditInfoCache.from(edit));\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n    */\n    getOffsetBeforeChange(offset) {\n        this.adjustNextEdit(offset);\n        return this.translateCurToOld(offset);\n    }\n    /**\n     * @param offset Must be equal to or greater than the last offset this method has been called with.\n     * Returns null if there is no edit anymore.\n    */\n    getDistanceToNextChange(offset) {\n        this.adjustNextEdit(offset);\n        const nextEdit = this.edits[this.nextEditIdx];\n        const nextChangeOffset = nextEdit ? this.translateOldToCur(nextEdit.offsetObj) : null;\n        if (nextChangeOffset === null) {\n            return null;\n        }\n        return lengthDiffNonNegative(offset, nextChangeOffset);\n    }\n    translateOldToCur(oldOffsetObj) {\n        if (oldOffsetObj.lineCount === this.deltaLineIdxInOld) {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount + this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(oldOffsetObj.lineCount + this.deltaOldToNewLineCount, oldOffsetObj.columnCount);\n        }\n    }\n    translateCurToOld(newOffset) {\n        const offsetObj = lengthToObj(newOffset);\n        if (offsetObj.lineCount - this.deltaOldToNewLineCount === this.deltaLineIdxInOld) {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount - this.deltaOldToNewColumnCount);\n        }\n        else {\n            return toLength(offsetObj.lineCount - this.deltaOldToNewLineCount, offsetObj.columnCount);\n        }\n    }\n    adjustNextEdit(offset) {\n        while (this.nextEditIdx < this.edits.length) {\n            const nextEdit = this.edits[this.nextEditIdx];\n            // After applying the edit, what is its end offset (considering all previous edits)?\n            const nextEditEndOffsetInCur = this.translateOldToCur(nextEdit.endOffsetAfterObj);\n            if (lengthLessThanEqual(nextEditEndOffsetInCur, offset)) {\n                // We are after the edit, skip it\n                this.nextEditIdx++;\n                const nextEditEndOffsetInCurObj = lengthToObj(nextEditEndOffsetInCur);\n                // Before applying the edit, what is its end offset (considering all previous edits)?\n                const nextEditEndOffsetBeforeInCurObj = lengthToObj(this.translateOldToCur(nextEdit.endOffsetBeforeObj));\n                const lineDelta = nextEditEndOffsetInCurObj.lineCount - nextEditEndOffsetBeforeInCurObj.lineCount;\n                this.deltaOldToNewLineCount += lineDelta;\n                const previousColumnDelta = this.deltaLineIdxInOld === nextEdit.endOffsetBeforeObj.lineCount ? this.deltaOldToNewColumnCount : 0;\n                const columnDelta = nextEditEndOffsetInCurObj.columnCount - nextEditEndOffsetBeforeInCurObj.columnCount;\n                this.deltaOldToNewColumnCount = previousColumnDelta + columnDelta;\n                this.deltaLineIdxInOld = nextEdit.endOffsetBeforeObj.lineCount;\n            }\n            else {\n                // We are in or before the edit.\n                break;\n            }\n        }\n    }\n}\nclass TextEditInfoCache {\n    static from(edit) {\n        return new TextEditInfoCache(edit.startOffset, edit.endOffset, edit.newLength);\n    }\n    constructor(startOffset, endOffset, textLength) {\n        this.endOffsetBeforeObj = lengthToObj(endOffset);\n        this.endOffsetAfterObj = lengthToObj(lengthAdd(startOffset, textLength));\n        this.offsetObj = lengthToObj(startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../../base/common/strings.js';\nimport * as stringBuilder from '../../core/stringBuilder.js';\nimport { Range } from '../../core/range.js';\n/**\n * Represents a grouping of colliding bracket pairs.\n *\n * Most of the times this contains a single bracket pair,\n * but sometimes this contains multiple bracket pairs in cases\n * where the same string appears as a closing bracket for multiple\n * bracket pairs, or the same string appears an opening bracket for\n * multiple bracket pairs.\n *\n * e.g. of a group containing a single pair:\n *   open: ['{'], close: ['}']\n *\n * e.g. of a group containing multiple pairs:\n *   open: ['if', 'for'], close: ['end', 'end']\n */\nexport class RichEditBracket {\n    constructor(languageId, index, open, close, forwardRegex, reversedRegex) {\n        this._richEditBracketBrand = undefined;\n        this.languageId = languageId;\n        this.index = index;\n        this.open = open;\n        this.close = close;\n        this.forwardRegex = forwardRegex;\n        this.reversedRegex = reversedRegex;\n        this._openSet = RichEditBracket._toSet(this.open);\n        this._closeSet = RichEditBracket._toSet(this.close);\n    }\n    /**\n     * Check if the provided `text` is an open bracket in this group.\n     */\n    isOpen(text) {\n        return this._openSet.has(text);\n    }\n    /**\n     * Check if the provided `text` is a close bracket in this group.\n     */\n    isClose(text) {\n        return this._closeSet.has(text);\n    }\n    static _toSet(arr) {\n        const result = new Set();\n        for (const element of arr) {\n            result.add(element);\n        }\n        return result;\n    }\n}\n/**\n * Groups together brackets that have equal open or close sequences.\n *\n * For example, if the following brackets are defined:\n *   ['IF','END']\n *   ['for','end']\n *   ['{','}']\n *\n * Then the grouped brackets would be:\n *   { open: ['if', 'for'], close: ['end', 'end'] }\n *   { open: ['{'], close: ['}'] }\n *\n */\nfunction groupFuzzyBrackets(brackets) {\n    const N = brackets.length;\n    brackets = brackets.map(b => [b[0].toLowerCase(), b[1].toLowerCase()]);\n    const group = [];\n    for (let i = 0; i < N; i++) {\n        group[i] = i;\n    }\n    const areOverlapping = (a, b) => {\n        const [aOpen, aClose] = a;\n        const [bOpen, bClose] = b;\n        return (aOpen === bOpen || aOpen === bClose || aClose === bOpen || aClose === bClose);\n    };\n    const mergeGroups = (g1, g2) => {\n        const newG = Math.min(g1, g2);\n        const oldG = Math.max(g1, g2);\n        for (let i = 0; i < N; i++) {\n            if (group[i] === oldG) {\n                group[i] = newG;\n            }\n        }\n    };\n    // group together brackets that have the same open or the same close sequence\n    for (let i = 0; i < N; i++) {\n        const a = brackets[i];\n        for (let j = i + 1; j < N; j++) {\n            const b = brackets[j];\n            if (areOverlapping(a, b)) {\n                mergeGroups(group[i], group[j]);\n            }\n        }\n    }\n    const result = [];\n    for (let g = 0; g < N; g++) {\n        const currentOpen = [];\n        const currentClose = [];\n        for (let i = 0; i < N; i++) {\n            if (group[i] === g) {\n                const [open, close] = brackets[i];\n                currentOpen.push(open);\n                currentClose.push(close);\n            }\n        }\n        if (currentOpen.length > 0) {\n            result.push({\n                open: currentOpen,\n                close: currentClose\n            });\n        }\n    }\n    return result;\n}\nexport class RichEditBrackets {\n    constructor(languageId, _brackets) {\n        this._richEditBracketsBrand = undefined;\n        const brackets = groupFuzzyBrackets(_brackets);\n        this.brackets = brackets.map((b, index) => {\n            return new RichEditBracket(languageId, index, b.open, b.close, getRegexForBracketPair(b.open, b.close, brackets, index), getReversedRegexForBracketPair(b.open, b.close, brackets, index));\n        });\n        this.forwardRegex = getRegexForBrackets(this.brackets);\n        this.reversedRegex = getReversedRegexForBrackets(this.brackets);\n        this.textIsBracket = {};\n        this.textIsOpenBracket = {};\n        this.maxBracketLength = 0;\n        for (const bracket of this.brackets) {\n            for (const open of bracket.open) {\n                this.textIsBracket[open] = bracket;\n                this.textIsOpenBracket[open] = true;\n                this.maxBracketLength = Math.max(this.maxBracketLength, open.length);\n            }\n            for (const close of bracket.close) {\n                this.textIsBracket[close] = bracket;\n                this.textIsOpenBracket[close] = false;\n                this.maxBracketLength = Math.max(this.maxBracketLength, close.length);\n            }\n        }\n    }\n}\nfunction collectSuperstrings(str, brackets, currentIndex, dest) {\n    for (let i = 0, len = brackets.length; i < len; i++) {\n        if (i === currentIndex) {\n            continue;\n        }\n        const bracket = brackets[i];\n        for (const open of bracket.open) {\n            if (open.indexOf(str) >= 0) {\n                dest.push(open);\n            }\n        }\n        for (const close of bracket.close) {\n            if (close.indexOf(str) >= 0) {\n                dest.push(close);\n            }\n        }\n    }\n}\nfunction lengthcmp(a, b) {\n    return a.length - b.length;\n}\nfunction unique(arr) {\n    if (arr.length <= 1) {\n        return arr;\n    }\n    const result = [];\n    const seen = new Set();\n    for (const element of arr) {\n        if (seen.has(element)) {\n            continue;\n        }\n        result.push(element);\n        seen.add(element);\n    }\n    return result;\n}\n/**\n * Create a regular expression that can be used to search forward in a piece of text\n * for a group of bracket pairs. But this regex must be built in a way in which\n * it is aware of the other bracket pairs defined for the language.\n *\n * For example, if a language contains the following bracket pairs:\n *   ['begin', 'end']\n *   ['if', 'end if']\n * The two bracket pairs do not collide because no open or close brackets are equal.\n * So the function getRegexForBracketPair is called twice, once with\n * the ['begin'], ['end'] group consisting of one bracket pair, and once with\n * the ['if'], ['end if'] group consiting of the other bracket pair.\n *\n * But there could be a situation where an occurrence of 'end if' is mistaken\n * for an occurrence of 'end'.\n *\n * Therefore, for the bracket pair ['begin', 'end'], the regex will also\n * target 'end if'. The regex will be something like:\n *   /(\\bend if\\b)|(\\bend\\b)|(\\bif\\b)/\n *\n * The regex also searches for \"superstrings\" (other brackets that might be mistaken with the current bracket).\n *\n */\nfunction getRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * This function also has the fine details of `getRegexForBracketPair`. For the same example\n * given above, the regex produced here would look like:\n *   /(\\bfi dne\\b)|(\\bdne\\b)|(\\bfi\\b)/\n */\nfunction getReversedRegexForBracketPair(open, close, brackets, currentIndex) {\n    // search in all brackets for other brackets that are a superstring of these brackets\n    let pieces = [];\n    pieces = pieces.concat(open);\n    pieces = pieces.concat(close);\n    for (let i = 0, len = pieces.length; i < len; i++) {\n        collectSuperstrings(pieces[i], brackets, currentIndex, pieces);\n    }\n    pieces = unique(pieces);\n    pieces.sort(lengthcmp);\n    pieces.reverse();\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\n/**\n * Creates a regular expression that targets all bracket pairs.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bbegin\\b)|(\\bend\\b)|(\\bfor\\b)/\n */\nfunction getRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces);\n}\n/**\n * Matching a regular expression in JS can only be done \"forwards\". So JS offers natively only\n * methods to find the first match of a regex in a string. But sometimes, it is useful to\n * find the last match of a regex in a string. For such a situation, a nice solution is to\n * simply reverse the string and then search for a reversed regex.\n *\n * e.g. for the bracket pairs:\n *  ['{','}']\n *  ['begin,'end']\n *  ['for','end']\n * the regex would look like:\n *  /(\\{)|(\\})|(\\bnigeb\\b)|(\\bdne\\b)|(\\brof\\b)/\n */\nfunction getReversedRegexForBrackets(brackets) {\n    let pieces = [];\n    for (const bracket of brackets) {\n        for (const open of bracket.open) {\n            pieces.push(open);\n        }\n        for (const close of bracket.close) {\n            pieces.push(close);\n        }\n    }\n    pieces = unique(pieces);\n    return createBracketOrRegExp(pieces.map(toReversedString));\n}\nfunction prepareBracketForRegExp(str) {\n    // This bracket pair uses letters like e.g. \"begin\" - \"end\"\n    const insertWordBoundaries = (/^[\\w ]+$/.test(str));\n    str = strings.escapeRegExpCharacters(str);\n    return (insertWordBoundaries ? `\\\\b${str}\\\\b` : str);\n}\nexport function createBracketOrRegExp(pieces, options) {\n    const regexStr = `(${pieces.map(prepareBracketForRegExp).join(')|(')})`;\n    return strings.createRegExp(regexStr, true, options);\n}\nconst toReversedString = (function () {\n    function reverse(str) {\n        // create a Uint16Array and then use a TextDecoder to create a string\n        const arr = new Uint16Array(str.length);\n        let offset = 0;\n        for (let i = str.length - 1; i >= 0; i--) {\n            arr[offset++] = str.charCodeAt(i);\n        }\n        return stringBuilder.getPlatformTextDecoder().decode(arr);\n    }\n    let lastInput = null;\n    let lastOutput = null;\n    return function toReversedString(str) {\n        if (lastInput !== str) {\n            lastInput = str;\n            lastOutput = reverse(lastInput);\n        }\n        return lastOutput;\n    };\n})();\nexport class BracketsUtils {\n    static _findPrevBracketInText(reversedBracketRegex, lineNumber, reversedText, offset) {\n        const m = reversedText.match(reversedBracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = reversedText.length - (m.index || 0);\n        const matchLength = m[0].length;\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset - matchLength + 1, lineNumber, absoluteMatchOffset + 1);\n    }\n    static findPrevBracketInRange(reversedBracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        // Because JS does not support backwards regex search, we search forwards in a reversed string with a reversed regex ;)\n        const reversedLineText = toReversedString(lineText);\n        const reversedSubstr = reversedLineText.substring(lineText.length - endOffset, lineText.length - startOffset);\n        return this._findPrevBracketInText(reversedBracketRegex, lineNumber, reversedSubstr, startOffset);\n    }\n    static findNextBracketInText(bracketRegex, lineNumber, text, offset) {\n        const m = text.match(bracketRegex);\n        if (!m) {\n            return null;\n        }\n        const matchOffset = m.index || 0;\n        const matchLength = m[0].length;\n        if (matchLength === 0) {\n            return null;\n        }\n        const absoluteMatchOffset = offset + matchOffset;\n        return new Range(lineNumber, absoluteMatchOffset + 1, lineNumber, absoluteMatchOffset + 1 + matchLength);\n    }\n    static findNextBracketInRange(bracketRegex, lineNumber, lineText, startOffset, endOffset) {\n        const substr = lineText.substring(startOffset, endOffset);\n        return this.findNextBracketInText(bracketRegex, lineNumber, substr, startOffset);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { BugIndicatingError } from '../../../../../base/common/errors.js';\nimport { CursorColumns } from '../../../core/cursorColumns.js';\nimport { lengthAdd, lengthGetLineCount, lengthToObj, lengthZero } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\n/**\n * The base implementation for all AST nodes.\n*/\nclass BaseAstNode {\n    /**\n     * The length of the entire node, which should equal the sum of lengths of all children.\n    */\n    get length() {\n        return this._length;\n    }\n    constructor(length) {\n        this._length = length;\n    }\n}\n/**\n * Represents a bracket pair including its child (e.g. `{ ... }`).\n * Might be unclosed.\n * Immutable, if all children are immutable.\n*/\nexport class PairAstNode extends BaseAstNode {\n    static create(openingBracket, child, closingBracket) {\n        let length = openingBracket.length;\n        if (child) {\n            length = lengthAdd(length, child.length);\n        }\n        if (closingBracket) {\n            length = lengthAdd(length, closingBracket.length);\n        }\n        return new PairAstNode(length, openingBracket, child, closingBracket, child ? child.missingOpeningBracketIds : SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 2 /* AstNodeKind.Pair */;\n    }\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 3;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this.openingBracket;\n            case 1: return this.child;\n            case 2: return this.closingBracket;\n        }\n        throw new Error('Invalid child index');\n    }\n    /**\n     * Avoid using this property, it allocates an array!\n    */\n    get children() {\n        const result = [];\n        result.push(this.openingBracket);\n        if (this.child) {\n            result.push(this.child);\n        }\n        if (this.closingBracket) {\n            result.push(this.closingBracket);\n        }\n        return result;\n    }\n    constructor(length, openingBracket, child, closingBracket, missingOpeningBracketIds) {\n        super(length);\n        this.openingBracket = openingBracket;\n        this.child = child;\n        this.closingBracket = closingBracket;\n        this.missingOpeningBracketIds = missingOpeningBracketIds;\n    }\n    canBeReused(openBracketIds) {\n        if (this.closingBracket === null) {\n            // Unclosed pair ast nodes only\n            // end at the end of the document\n            // or when a parent node is closed.\n            // This could be improved:\n            // Only return false if some next token is neither \"undefined\" nor a bracket that closes a parent.\n            return false;\n        }\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        return true;\n    }\n    deepClone() {\n        return new PairAstNode(this.length, this.openingBracket.deepClone(), this.child && this.child.deepClone(), this.closingBracket && this.closingBracket.deepClone(), this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return this.child ? this.child.computeMinIndentation(lengthAdd(offset, this.openingBracket.length), textModel) : Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class ListAstNode extends BaseAstNode {\n    /**\n     * This method uses more memory-efficient list nodes that can only store 2 or 3 children.\n    */\n    static create23(item1, item2, item3, immutable = false) {\n        let length = item1.length;\n        let missingBracketIds = item1.missingOpeningBracketIds;\n        if (item1.listHeight !== item2.listHeight) {\n            throw new Error('Invalid list heights');\n        }\n        length = lengthAdd(length, item2.length);\n        missingBracketIds = missingBracketIds.merge(item2.missingOpeningBracketIds);\n        if (item3) {\n            if (item1.listHeight !== item3.listHeight) {\n                throw new Error('Invalid list heights');\n            }\n            length = lengthAdd(length, item3.length);\n            missingBracketIds = missingBracketIds.merge(item3.missingOpeningBracketIds);\n        }\n        return immutable\n            ? new Immutable23ListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds)\n            : new TwoThreeListAstNode(length, item1.listHeight + 1, item1, item2, item3, missingBracketIds);\n    }\n    static getEmpty() {\n        return new ImmutableArrayListAstNode(lengthZero, 0, [], SmallImmutableSet.getEmpty());\n    }\n    get kind() {\n        return 4 /* AstNodeKind.List */;\n    }\n    get missingOpeningBracketIds() {\n        return this._missingOpeningBracketIds;\n    }\n    /**\n     * Use ListAstNode.create.\n    */\n    constructor(length, listHeight, _missingOpeningBracketIds) {\n        super(length);\n        this.listHeight = listHeight;\n        this._missingOpeningBracketIds = _missingOpeningBracketIds;\n        this.cachedMinIndentation = -1;\n    }\n    throwIfImmutable() {\n        // NOOP\n    }\n    makeLastElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const lastChild = this.getChild(childCount - 1);\n        const mutable = lastChild.kind === 4 /* AstNodeKind.List */ ? lastChild.toMutable() : lastChild;\n        if (lastChild !== mutable) {\n            this.setChild(childCount - 1, mutable);\n        }\n        return mutable;\n    }\n    makeFirstElementMutable() {\n        this.throwIfImmutable();\n        const childCount = this.childrenLength;\n        if (childCount === 0) {\n            return undefined;\n        }\n        const firstChild = this.getChild(0);\n        const mutable = firstChild.kind === 4 /* AstNodeKind.List */ ? firstChild.toMutable() : firstChild;\n        if (firstChild !== mutable) {\n            this.setChild(0, mutable);\n        }\n        return mutable;\n    }\n    canBeReused(openBracketIds) {\n        if (openBracketIds.intersects(this.missingOpeningBracketIds)) {\n            return false;\n        }\n        if (this.childrenLength === 0) {\n            // Don't reuse empty lists.\n            return false;\n        }\n        let lastChild = this;\n        while (lastChild.kind === 4 /* AstNodeKind.List */) {\n            const lastLength = lastChild.childrenLength;\n            if (lastLength === 0) {\n                // Empty lists should never be contained in other lists.\n                throw new BugIndicatingError();\n            }\n            lastChild = lastChild.getChild(lastLength - 1);\n        }\n        return lastChild.canBeReused(openBracketIds);\n    }\n    handleChildrenChanged() {\n        this.throwIfImmutable();\n        const count = this.childrenLength;\n        let length = this.getChild(0).length;\n        let unopenedBrackets = this.getChild(0).missingOpeningBracketIds;\n        for (let i = 1; i < count; i++) {\n            const child = this.getChild(i);\n            length = lengthAdd(length, child.length);\n            unopenedBrackets = unopenedBrackets.merge(child.missingOpeningBracketIds);\n        }\n        this._length = length;\n        this._missingOpeningBracketIds = unopenedBrackets;\n        this.cachedMinIndentation = -1;\n    }\n    computeMinIndentation(offset, textModel) {\n        if (this.cachedMinIndentation !== -1) {\n            return this.cachedMinIndentation;\n        }\n        let minIndentation = Number.MAX_SAFE_INTEGER;\n        let childOffset = offset;\n        for (let i = 0; i < this.childrenLength; i++) {\n            const child = this.getChild(i);\n            if (child) {\n                minIndentation = Math.min(minIndentation, child.computeMinIndentation(childOffset, textModel));\n                childOffset = lengthAdd(childOffset, child.length);\n            }\n        }\n        this.cachedMinIndentation = minIndentation;\n        return minIndentation;\n    }\n}\nclass TwoThreeListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._item3 !== null ? 3 : 2;\n    }\n    getChild(idx) {\n        switch (idx) {\n            case 0: return this._item1;\n            case 1: return this._item2;\n            case 2: return this._item3;\n        }\n        throw new Error('Invalid child index');\n    }\n    setChild(idx, node) {\n        switch (idx) {\n            case 0:\n                this._item1 = node;\n                return;\n            case 1:\n                this._item2 = node;\n                return;\n            case 2:\n                this._item3 = node;\n                return;\n        }\n        throw new Error('Invalid child index');\n    }\n    get children() {\n        return this._item3 ? [this._item1, this._item2, this._item3] : [this._item1, this._item2];\n    }\n    get item1() {\n        return this._item1;\n    }\n    get item2() {\n        return this._item2;\n    }\n    get item3() {\n        return this._item3;\n    }\n    constructor(length, listHeight, _item1, _item2, _item3, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._item1 = _item1;\n        this._item2 = _item2;\n        this._item3 = _item3;\n    }\n    deepClone() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this._item1.deepClone(), this._item2.deepClone(), this._item3 ? this._item3.deepClone() : null, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot append to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = node;\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    prependChildOfSameHeight(node) {\n        if (this._item3) {\n            throw new Error('Cannot prepend to a full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        this._item3 = this._item2;\n        this._item2 = this._item1;\n        this._item1 = node;\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        if (!this._item3) {\n            throw new Error('Cannot remove from a non-full (2,3) tree node');\n        }\n        this.throwIfImmutable();\n        const result = this._item1;\n        this._item1 = this._item2;\n        this._item2 = this._item3;\n        this._item3 = null;\n        this.handleChildrenChanged();\n        return result;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass Immutable23ListAstNode extends TwoThreeListAstNode {\n    toMutable() {\n        return new TwoThreeListAstNode(this.length, this.listHeight, this.item1, this.item2, this.item3, this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\n/**\n * For debugging.\n*/\nclass ArrayListAstNode extends ListAstNode {\n    get childrenLength() {\n        return this._children.length;\n    }\n    getChild(idx) {\n        return this._children[idx];\n    }\n    setChild(idx, child) {\n        this._children[idx] = child;\n    }\n    get children() {\n        return this._children;\n    }\n    constructor(length, listHeight, _children, missingOpeningBracketIds) {\n        super(length, listHeight, missingOpeningBracketIds);\n        this._children = _children;\n    }\n    deepClone() {\n        const children = new Array(this._children.length);\n        for (let i = 0; i < this._children.length; i++) {\n            children[i] = this._children[i].deepClone();\n        }\n        return new ArrayListAstNode(this.length, this.listHeight, children, this.missingOpeningBracketIds);\n    }\n    appendChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.push(node);\n        this.handleChildrenChanged();\n    }\n    unappendChild() {\n        this.throwIfImmutable();\n        const item = this._children.pop();\n        this.handleChildrenChanged();\n        return item;\n    }\n    prependChildOfSameHeight(node) {\n        this.throwIfImmutable();\n        this._children.unshift(node);\n        this.handleChildrenChanged();\n    }\n    unprependChild() {\n        this.throwIfImmutable();\n        const item = this._children.shift();\n        this.handleChildrenChanged();\n        return item;\n    }\n    toMutable() {\n        return this;\n    }\n}\n/**\n * Immutable, if all children are immutable.\n*/\nclass ImmutableArrayListAstNode extends ArrayListAstNode {\n    toMutable() {\n        return new ArrayListAstNode(this.length, this.listHeight, [...this.children], this.missingOpeningBracketIds);\n    }\n    throwIfImmutable() {\n        throw new Error('this instance is immutable');\n    }\n}\nconst emptyArray = [];\nclass ImmutableLeafAstNode extends BaseAstNode {\n    get listHeight() {\n        return 0;\n    }\n    get childrenLength() {\n        return 0;\n    }\n    getChild(idx) {\n        return null;\n    }\n    get children() {\n        return emptyArray;\n    }\n    deepClone() {\n        return this;\n    }\n}\nexport class TextAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 0 /* AstNodeKind.Text */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    canBeReused(_openedBracketIds) {\n        return true;\n    }\n    computeMinIndentation(offset, textModel) {\n        const start = lengthToObj(offset);\n        // Text ast nodes don't have partial indentation (ensured by the tokenizer).\n        // Thus, if this text node does not start at column 0, the first line cannot have any indentation at all.\n        const startLineNumber = (start.columnCount === 0 ? start.lineCount : start.lineCount + 1) + 1;\n        const endLineNumber = lengthGetLineCount(lengthAdd(offset, this.length)) + 1;\n        let result = Number.MAX_SAFE_INTEGER;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const firstNonWsColumn = textModel.getLineFirstNonWhitespaceColumn(lineNumber);\n            const lineContent = textModel.getLineContent(lineNumber);\n            if (firstNonWsColumn === 0) {\n                continue;\n            }\n            const visibleColumn = CursorColumns.visibleColumnFromColumn(lineContent, firstNonWsColumn, textModel.getOptions().tabSize);\n            result = Math.min(result, visibleColumn);\n        }\n        return result;\n    }\n}\nexport class BracketAstNode extends ImmutableLeafAstNode {\n    static create(length, bracketInfo, bracketIds) {\n        const node = new BracketAstNode(length, bracketInfo, bracketIds);\n        return node;\n    }\n    get kind() {\n        return 1 /* AstNodeKind.Bracket */;\n    }\n    get missingOpeningBracketIds() {\n        return SmallImmutableSet.getEmpty();\n    }\n    constructor(length, bracketInfo, \n    /**\n     * In case of a opening bracket, this is the id of the opening bracket.\n     * In case of a closing bracket, this contains the ids of all opening brackets it can close.\n    */\n    bracketIds) {\n        super(length);\n        this.bracketInfo = bracketInfo;\n        this.bracketIds = bracketIds;\n    }\n    get text() {\n        return this.bracketInfo.bracketText;\n    }\n    get languageId() {\n        return this.bracketInfo.languageId;\n    }\n    canBeReused(_openedBracketIds) {\n        // These nodes could be reused,\n        // but not in a general way.\n        // Their parent may be reused.\n        return false;\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\nexport class InvalidBracketAstNode extends ImmutableLeafAstNode {\n    get kind() {\n        return 3 /* AstNodeKind.UnexpectedClosingBracket */;\n    }\n    constructor(closingBrackets, length) {\n        super(length);\n        this.missingOpeningBracketIds = closingBrackets;\n    }\n    canBeReused(openedBracketIds) {\n        return !openedBracketIds.intersects(this.missingOpeningBracketIds);\n    }\n    computeMinIndentation(offset, textModel) {\n        return Number.MAX_SAFE_INTEGER;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Describes what to do with the indentation when pressing Enter.\n */\nexport var IndentAction;\n(function (IndentAction) {\n    /**\n     * Insert new line and copy the previous line's indentation.\n     */\n    IndentAction[IndentAction[\"None\"] = 0] = \"None\";\n    /**\n     * Insert new line and indent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Indent\"] = 1] = \"Indent\";\n    /**\n     * Insert two new lines:\n     *  - the first one indented which will hold the cursor\n     *  - the second one at the same indentation level\n     */\n    IndentAction[IndentAction[\"IndentOutdent\"] = 2] = \"IndentOutdent\";\n    /**\n     * Insert new line and outdent once (relative to the previous line's indentation).\n     */\n    IndentAction[IndentAction[\"Outdent\"] = 3] = \"Outdent\";\n})(IndentAction || (IndentAction = {}));\n/**\n * @internal\n */\nexport class StandardAutoClosingPairConditional {\n    constructor(source) {\n        this._neutralCharacter = null;\n        this._neutralCharacterSearched = false;\n        this.open = source.open;\n        this.close = source.close;\n        // initially allowed in all tokens\n        this._inString = true;\n        this._inComment = true;\n        this._inRegEx = true;\n        if (Array.isArray(source.notIn)) {\n            for (let i = 0, len = source.notIn.length; i < len; i++) {\n                const notIn = source.notIn[i];\n                switch (notIn) {\n                    case 'string':\n                        this._inString = false;\n                        break;\n                    case 'comment':\n                        this._inComment = false;\n                        break;\n                    case 'regex':\n                        this._inRegEx = false;\n                        break;\n                }\n            }\n        }\n    }\n    isOK(standardToken) {\n        switch (standardToken) {\n            case 0 /* StandardTokenType.Other */:\n                return true;\n            case 1 /* StandardTokenType.Comment */:\n                return this._inComment;\n            case 2 /* StandardTokenType.String */:\n                return this._inString;\n            case 3 /* StandardTokenType.RegEx */:\n                return this._inRegEx;\n        }\n    }\n    shouldAutoClose(context, column) {\n        // Always complete on empty line\n        if (context.getTokenCount() === 0) {\n            return true;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 2);\n        const standardTokenType = context.getStandardTokenType(tokenIndex);\n        return this.isOK(standardTokenType);\n    }\n    _findNeutralCharacterInRange(fromCharCode, toCharCode) {\n        for (let charCode = fromCharCode; charCode <= toCharCode; charCode++) {\n            const character = String.fromCharCode(charCode);\n            if (!this.open.includes(character) && !this.close.includes(character)) {\n                return character;\n            }\n        }\n        return null;\n    }\n    /**\n     * Find a character in the range [0-9a-zA-Z] that does not appear in the open or close\n     */\n    findNeutralCharacter() {\n        if (!this._neutralCharacterSearched) {\n            this._neutralCharacterSearched = true;\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(48 /* CharCode.Digit0 */, 57 /* CharCode.Digit9 */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(97 /* CharCode.a */, 122 /* CharCode.z */);\n            }\n            if (!this._neutralCharacter) {\n                this._neutralCharacter = this._findNeutralCharacterInRange(65 /* CharCode.A */, 90 /* CharCode.Z */);\n            }\n        }\n        return this._neutralCharacter;\n    }\n}\n/**\n * @internal\n */\nexport class AutoClosingPairs {\n    constructor(autoClosingPairs) {\n        this.autoClosingPairsOpenByStart = new Map();\n        this.autoClosingPairsOpenByEnd = new Map();\n        this.autoClosingPairsCloseByStart = new Map();\n        this.autoClosingPairsCloseByEnd = new Map();\n        this.autoClosingPairsCloseSingleChar = new Map();\n        for (const pair of autoClosingPairs) {\n            appendEntry(this.autoClosingPairsOpenByStart, pair.open.charAt(0), pair);\n            appendEntry(this.autoClosingPairsOpenByEnd, pair.open.charAt(pair.open.length - 1), pair);\n            appendEntry(this.autoClosingPairsCloseByStart, pair.close.charAt(0), pair);\n            appendEntry(this.autoClosingPairsCloseByEnd, pair.close.charAt(pair.close.length - 1), pair);\n            if (pair.close.length === 1 && pair.open.length === 1) {\n                appendEntry(this.autoClosingPairsCloseSingleChar, pair.close, pair);\n            }\n        }\n    }\n}\nfunction appendEntry(target, key, value) {\n    if (target.has(key)) {\n        target.get(key).push(value);\n    }\n    else {\n        target.set(key, [value]);\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport const EDITOR_MODEL_DEFAULTS = {\n    tabSize: 4,\n    indentSize: 4,\n    insertSpaces: true,\n    detectIndentation: true,\n    trimAutoWhitespace: true,\n    largeFileOptimizations: true,\n    bracketPairColorizationOptions: {\n        enabled: true,\n        independentColorPoolPerBracketType: false,\n    },\n};\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Token, TokenizationResult, EncodedTokenizationResult } from '../languages.js';\nexport const NullState = new class {\n    clone() {\n        return this;\n    }\n    equals(other) {\n        return (this === other);\n    }\n};\nexport function nullTokenize(languageId, state) {\n    return new TokenizationResult([new Token(0, '', languageId)], state);\n}\nexport function nullTokenizeEncoded(languageId, state) {\n    const tokens = new Uint32Array(2);\n    tokens[0] = 0;\n    tokens[1] = ((languageId << 0 /* MetadataConsts.LANGUAGEID_OFFSET */)\n        | (0 /* StandardTokenType.Other */ << 8 /* MetadataConsts.TOKEN_TYPE_OFFSET */)\n        | (0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0;\n    return new EncodedTokenizationResult(tokens, state === null ? NullState : state);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { findLast } from '../../../base/common/arraysFind.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from '../core/cursorColumns.js';\nimport { Range } from '../core/range.js';\nimport { TextModelPart } from './textModelPart.js';\nimport { computeIndentLevel } from './utils.js';\nimport { HorizontalGuidesState, IndentGuide, IndentGuideHorizontalLine } from '../textModelGuides.js';\nimport { BugIndicatingError } from '../../../base/common/errors.js';\nexport class GuidesTextModelPart extends TextModelPart {\n    constructor(textModel, languageConfigurationService) {\n        super();\n        this.textModel = textModel;\n        this.languageConfigurationService = languageConfigurationService;\n    }\n    getLanguageConfiguration(languageId) {\n        return this.languageConfigurationService.getLanguageConfiguration(languageId);\n    }\n    _computeIndentLevel(lineIndex) {\n        return computeIndentLevel(this.textModel.getLineContent(lineIndex + 1), this.textModel.getOptions().tabSize);\n    }\n    getActiveIndentGuide(lineNumber, minLineNumber, maxLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (lineNumber < 1 || lineNumber > lineCount) {\n            throw new BugIndicatingError('Illegal value for lineNumber');\n        }\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        let up_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_aboveContentLineIndent = -1;\n        let up_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let up_belowContentLineIndent = -1;\n        const up_resolveIndents = (lineNumber) => {\n            if (up_aboveContentLineIndex !== -1 &&\n                (up_aboveContentLineIndex === -2 ||\n                    up_aboveContentLineIndex > lineNumber - 1)) {\n                up_aboveContentLineIndex = -1;\n                up_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_aboveContentLineIndex = lineIndex;\n                        up_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (up_belowContentLineIndex === -2) {\n                up_belowContentLineIndex = -1;\n                up_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        up_belowContentLineIndex = lineIndex;\n                        up_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let down_aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_aboveContentLineIndent = -1;\n        let down_belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let down_belowContentLineIndent = -1;\n        const down_resolveIndents = (lineNumber) => {\n            if (down_aboveContentLineIndex === -2) {\n                down_aboveContentLineIndex = -1;\n                down_aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_aboveContentLineIndex = lineIndex;\n                        down_aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (down_belowContentLineIndex !== -1 &&\n                (down_belowContentLineIndex === -2 ||\n                    down_belowContentLineIndex < lineNumber - 1)) {\n                down_belowContentLineIndex = -1;\n                down_belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        down_belowContentLineIndex = lineIndex;\n                        down_belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n        };\n        let startLineNumber = 0;\n        let goUp = true;\n        let endLineNumber = 0;\n        let goDown = true;\n        let indent = 0;\n        let initialIndent = 0;\n        for (let distance = 0; goUp || goDown; distance++) {\n            const upLineNumber = lineNumber - distance;\n            const downLineNumber = lineNumber + distance;\n            if (distance > 1 && (upLineNumber < 1 || upLineNumber < minLineNumber)) {\n                goUp = false;\n            }\n            if (distance > 1 &&\n                (downLineNumber > lineCount || downLineNumber > maxLineNumber)) {\n                goDown = false;\n            }\n            if (distance > 50000) {\n                // stop processing\n                goUp = false;\n                goDown = false;\n            }\n            let upLineIndentLevel = -1;\n            if (goUp && upLineNumber >= 1) {\n                // compute indent level going up\n                const currentIndent = this._computeIndentLevel(upLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    up_belowContentLineIndex = upLineNumber - 1;\n                    up_belowContentLineIndent = currentIndent;\n                    upLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    up_resolveIndents(upLineNumber);\n                    upLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, up_aboveContentLineIndent, up_belowContentLineIndent);\n                }\n            }\n            let downLineIndentLevel = -1;\n            if (goDown && downLineNumber <= lineCount) {\n                // compute indent level going down\n                const currentIndent = this._computeIndentLevel(downLineNumber - 1);\n                if (currentIndent >= 0) {\n                    // This line has content (besides whitespace)\n                    // Use the line's indent\n                    down_aboveContentLineIndex = downLineNumber - 1;\n                    down_aboveContentLineIndent = currentIndent;\n                    downLineIndentLevel = Math.ceil(currentIndent / this.textModel.getOptions().indentSize);\n                }\n                else {\n                    down_resolveIndents(downLineNumber);\n                    downLineIndentLevel = this._getIndentLevelForWhitespaceLine(offSide, down_aboveContentLineIndent, down_belowContentLineIndent);\n                }\n            }\n            if (distance === 0) {\n                initialIndent = upLineIndentLevel;\n                continue;\n            }\n            if (distance === 1) {\n                if (downLineNumber <= lineCount &&\n                    downLineIndentLevel >= 0 &&\n                    initialIndent + 1 === downLineIndentLevel) {\n                    // This is the beginning of a scope, we have special handling here, since we want the\n                    // child scope indent to be active, not the parent scope\n                    goUp = false;\n                    startLineNumber = downLineNumber;\n                    endLineNumber = downLineNumber;\n                    indent = downLineIndentLevel;\n                    continue;\n                }\n                if (upLineNumber >= 1 &&\n                    upLineIndentLevel >= 0 &&\n                    upLineIndentLevel - 1 === initialIndent) {\n                    // This is the end of a scope, just like above\n                    goDown = false;\n                    startLineNumber = upLineNumber;\n                    endLineNumber = upLineNumber;\n                    indent = upLineIndentLevel;\n                    continue;\n                }\n                startLineNumber = lineNumber;\n                endLineNumber = lineNumber;\n                indent = initialIndent;\n                if (indent === 0) {\n                    // No need to continue\n                    return { startLineNumber, endLineNumber, indent };\n                }\n            }\n            if (goUp) {\n                if (upLineIndentLevel >= indent) {\n                    startLineNumber = upLineNumber;\n                }\n                else {\n                    goUp = false;\n                }\n            }\n            if (goDown) {\n                if (downLineIndentLevel >= indent) {\n                    endLineNumber = downLineNumber;\n                }\n                else {\n                    goDown = false;\n                }\n            }\n        }\n        return { startLineNumber, endLineNumber, indent };\n    }\n    getLinesBracketGuides(startLineNumber, endLineNumber, activePosition, options) {\n        const result = [];\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            result.push([]);\n        }\n        // If requested, this could be made configurable.\n        const includeSingleLinePairs = true;\n        const bracketPairs = this.textModel.bracketPairs.getBracketPairsInRangeWithMinIndentation(new Range(startLineNumber, 1, endLineNumber, this.textModel.getLineMaxColumn(endLineNumber))).toArray();\n        let activeBracketPairRange = undefined;\n        if (activePosition && bracketPairs.length > 0) {\n            const bracketsContainingActivePosition = (startLineNumber <= activePosition.lineNumber &&\n                activePosition.lineNumber <= endLineNumber\n                // We don't need to query the brackets again if the cursor is in the viewport\n                ? bracketPairs\n                : this.textModel.bracketPairs.getBracketPairsInRange(Range.fromPositions(activePosition)).toArray()).filter((bp) => Range.strictContainsPosition(bp.range, activePosition));\n            activeBracketPairRange = findLast(bracketsContainingActivePosition, (i) => includeSingleLinePairs || i.range.startLineNumber !== i.range.endLineNumber)?.range;\n        }\n        const independentColorPoolPerBracketType = this.textModel.getOptions().bracketPairColorizationOptions.independentColorPoolPerBracketType;\n        const colorProvider = new BracketPairGuidesClassNames();\n        for (const pair of bracketPairs) {\n            /*\n\n\n                    {\n                    |\n                    }\n\n                    {\n                    |\n                    ----}\n\n                ____{\n                |test\n                ----}\n\n                renderHorizontalEndLineAtTheBottom:\n                    {\n                    |\n                    |x}\n                    --\n                renderHorizontalEndLineAtTheBottom:\n                ____{\n                |test\n                | x }\n                ----\n            */\n            if (!pair.closingBracketRange) {\n                continue;\n            }\n            const isActive = activeBracketPairRange && pair.range.equalsRange(activeBracketPairRange);\n            if (!isActive && !options.includeInactive) {\n                continue;\n            }\n            const className = colorProvider.getInlineClassName(pair.nestingLevel, pair.nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) +\n                (options.highlightActive && isActive\n                    ? ' ' + colorProvider.activeClassName\n                    : '');\n            const start = pair.openingBracketRange.getStartPosition();\n            const end = pair.closingBracketRange.getStartPosition();\n            const horizontalGuides = options.horizontalGuides === HorizontalGuidesState.Enabled || (options.horizontalGuides === HorizontalGuidesState.EnabledForActive && isActive);\n            if (pair.range.startLineNumber === pair.range.endLineNumber) {\n                if (includeSingleLinePairs && horizontalGuides) {\n                    result[pair.range.startLineNumber - startLineNumber].push(new IndentGuide(-1, pair.openingBracketRange.getEndPosition().column, className, new IndentGuideHorizontalLine(false, end.column), -1, -1));\n                }\n                continue;\n            }\n            const endVisibleColumn = this.getVisibleColumnFromPosition(end);\n            const startVisibleColumn = this.getVisibleColumnFromPosition(pair.openingBracketRange.getStartPosition());\n            const guideVisibleColumn = Math.min(startVisibleColumn, endVisibleColumn, pair.minVisibleColumnIndentation + 1);\n            let renderHorizontalEndLineAtTheBottom = false;\n            const firstNonWsIndex = strings.firstNonWhitespaceIndex(this.textModel.getLineContent(pair.closingBracketRange.startLineNumber));\n            const hasTextBeforeClosingBracket = firstNonWsIndex < pair.closingBracketRange.startColumn - 1;\n            if (hasTextBeforeClosingBracket) {\n                renderHorizontalEndLineAtTheBottom = true;\n            }\n            const visibleGuideStartLineNumber = Math.max(start.lineNumber, startLineNumber);\n            const visibleGuideEndLineNumber = Math.min(end.lineNumber, endLineNumber);\n            const offset = renderHorizontalEndLineAtTheBottom ? 1 : 0;\n            for (let l = visibleGuideStartLineNumber; l < visibleGuideEndLineNumber + offset; l++) {\n                result[l - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, null, l === start.lineNumber ? start.column : -1, l === end.lineNumber ? end.column : -1));\n            }\n            if (horizontalGuides) {\n                if (start.lineNumber >= startLineNumber && startVisibleColumn > guideVisibleColumn) {\n                    result[start.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(false, start.column), -1, -1));\n                }\n                if (end.lineNumber <= endLineNumber && endVisibleColumn > guideVisibleColumn) {\n                    result[end.lineNumber - startLineNumber].push(new IndentGuide(guideVisibleColumn, -1, className, new IndentGuideHorizontalLine(!renderHorizontalEndLineAtTheBottom, end.column), -1, -1));\n                }\n            }\n        }\n        for (const guides of result) {\n            guides.sort((a, b) => a.visibleColumn - b.visibleColumn);\n        }\n        return result;\n    }\n    getVisibleColumnFromPosition(position) {\n        return (CursorColumns.visibleColumnFromColumn(this.textModel.getLineContent(position.lineNumber), position.column, this.textModel.getOptions().tabSize) + 1);\n    }\n    getLinesIndentGuides(startLineNumber, endLineNumber) {\n        this.assertNotDisposed();\n        const lineCount = this.textModel.getLineCount();\n        if (startLineNumber < 1 || startLineNumber > lineCount) {\n            throw new Error('Illegal value for startLineNumber');\n        }\n        if (endLineNumber < 1 || endLineNumber > lineCount) {\n            throw new Error('Illegal value for endLineNumber');\n        }\n        const options = this.textModel.getOptions();\n        const foldingRules = this.getLanguageConfiguration(this.textModel.getLanguageId()).foldingRules;\n        const offSide = Boolean(foldingRules && foldingRules.offSide);\n        const result = new Array(endLineNumber - startLineNumber + 1);\n        let aboveContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let aboveContentLineIndent = -1;\n        let belowContentLineIndex = -2; /* -2 is a marker for not having computed it */\n        let belowContentLineIndent = -1;\n        for (let lineNumber = startLineNumber; lineNumber <= endLineNumber; lineNumber++) {\n            const resultIndex = lineNumber - startLineNumber;\n            const currentIndent = this._computeIndentLevel(lineNumber - 1);\n            if (currentIndent >= 0) {\n                // This line has content (besides whitespace)\n                // Use the line's indent\n                aboveContentLineIndex = lineNumber - 1;\n                aboveContentLineIndent = currentIndent;\n                result[resultIndex] = Math.ceil(currentIndent / options.indentSize);\n                continue;\n            }\n            if (aboveContentLineIndex === -2) {\n                aboveContentLineIndex = -1;\n                aboveContentLineIndent = -1;\n                // must find previous line with content\n                for (let lineIndex = lineNumber - 2; lineIndex >= 0; lineIndex--) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        aboveContentLineIndex = lineIndex;\n                        aboveContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            if (belowContentLineIndex !== -1 &&\n                (belowContentLineIndex === -2 || belowContentLineIndex < lineNumber - 1)) {\n                belowContentLineIndex = -1;\n                belowContentLineIndent = -1;\n                // must find next line with content\n                for (let lineIndex = lineNumber; lineIndex < lineCount; lineIndex++) {\n                    const indent = this._computeIndentLevel(lineIndex);\n                    if (indent >= 0) {\n                        belowContentLineIndex = lineIndex;\n                        belowContentLineIndent = indent;\n                        break;\n                    }\n                }\n            }\n            result[resultIndex] = this._getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent);\n        }\n        return result;\n    }\n    _getIndentLevelForWhitespaceLine(offSide, aboveContentLineIndent, belowContentLineIndent) {\n        const options = this.textModel.getOptions();\n        if (aboveContentLineIndent === -1 || belowContentLineIndent === -1) {\n            // At the top or bottom of the file\n            return 0;\n        }\n        else if (aboveContentLineIndent < belowContentLineIndent) {\n            // we are inside the region above\n            return 1 + Math.floor(aboveContentLineIndent / options.indentSize);\n        }\n        else if (aboveContentLineIndent === belowContentLineIndent) {\n            // we are in between two regions\n            return Math.ceil(belowContentLineIndent / options.indentSize);\n        }\n        else {\n            if (offSide) {\n                // same level as region below\n                return Math.ceil(belowContentLineIndent / options.indentSize);\n            }\n            else {\n                // we are inside the region that ends below\n                return 1 + Math.floor(belowContentLineIndent / options.indentSize);\n            }\n        }\n    }\n}\nexport class BracketPairGuidesClassNames {\n    constructor() {\n        this.activeClassName = 'indent-active';\n    }\n    getInlineClassName(nestingLevel, nestingLevelOfEqualBracketType, independentColorPoolPerBracketType) {\n        return this.getInlineClassNameOfLevel(independentColorPoolPerBracketType ? nestingLevelOfEqualBracketType : nestingLevel);\n    }\n    getInlineClassNameOfLevel(level) {\n        // To support a dynamic amount of colors up to 6 colors,\n        // we use a number that is a lcm of all numbers from 1 to 6.\n        return `bracket-indent-guide lvl-${level % 30}`;\n    }\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITreeSitterParserService = createDecorator('treeSitterParserService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { escapeRegExpCharacters } from '../../../../../base/common/strings.js';\nimport { BracketAstNode } from './ast.js';\nimport { toLength } from './length.js';\nimport { identityKeyProvider, SmallImmutableSet } from './smallImmutableSet.js';\nimport { Token } from './tokenizer.js';\nexport class BracketTokens {\n    static createFromLanguage(configuration, denseKeyProvider) {\n        function getId(bracketInfo) {\n            return denseKeyProvider.getKey(`${bracketInfo.languageId}:::${bracketInfo.bracketText}`);\n        }\n        const map = new Map();\n        for (const openingBracket of configuration.bracketsNew.openingBrackets) {\n            const length = toLength(0, openingBracket.bracketText.length);\n            const openingTextId = getId(openingBracket);\n            const bracketIds = SmallImmutableSet.getEmpty().add(openingTextId, identityKeyProvider);\n            map.set(openingBracket.bracketText, new Token(length, 1 /* TokenKind.OpeningBracket */, openingTextId, bracketIds, BracketAstNode.create(length, openingBracket, bracketIds)));\n        }\n        for (const closingBracket of configuration.bracketsNew.closingBrackets) {\n            const length = toLength(0, closingBracket.bracketText.length);\n            let bracketIds = SmallImmutableSet.getEmpty();\n            const closingBrackets = closingBracket.getOpeningBrackets();\n            for (const bracket of closingBrackets) {\n                bracketIds = bracketIds.add(getId(bracket), identityKeyProvider);\n            }\n            map.set(closingBracket.bracketText, new Token(length, 2 /* TokenKind.ClosingBracket */, getId(closingBrackets[0]), bracketIds, BracketAstNode.create(length, closingBracket, bracketIds)));\n        }\n        return new BracketTokens(map);\n    }\n    constructor(map) {\n        this.map = map;\n        this.hasRegExp = false;\n        this._regExpGlobal = null;\n    }\n    getRegExpStr() {\n        if (this.isEmpty) {\n            return null;\n        }\n        else {\n            const keys = [...this.map.keys()];\n            keys.sort();\n            keys.reverse();\n            return keys.map(k => prepareBracketForRegExp(k)).join('|');\n        }\n    }\n    /**\n     * Returns null if there is no such regexp (because there are no brackets).\n    */\n    get regExpGlobal() {\n        if (!this.hasRegExp) {\n            const regExpStr = this.getRegExpStr();\n            this._regExpGlobal = regExpStr ? new RegExp(regExpStr, 'gi') : null;\n            this.hasRegExp = true;\n        }\n        return this._regExpGlobal;\n    }\n    getToken(value) {\n        return this.map.get(value.toLowerCase());\n    }\n    findClosingTokenText(openingBracketIds) {\n        for (const [closingText, info] of this.map) {\n            if (info.kind === 2 /* TokenKind.ClosingBracket */ && info.bracketIds.intersects(openingBracketIds)) {\n                return closingText;\n            }\n        }\n        return undefined;\n    }\n    get isEmpty() {\n        return this.map.size === 0;\n    }\n}\nfunction prepareBracketForRegExp(str) {\n    let escaped = escapeRegExpCharacters(str);\n    // These bracket pair delimiters start or end with letters\n    // see https://github.com/microsoft/vscode/issues/132162 https://github.com/microsoft/vscode/issues/150440\n    if (/^[\\w ]+/.test(str)) {\n        escaped = `\\\\b${escaped}`;\n    }\n    if (/[\\w ]+$/.test(str)) {\n        escaped = `${escaped}\\\\b`;\n    }\n    return escaped;\n}\nexport class LanguageAgnosticBracketTokens {\n    constructor(denseKeyProvider, getLanguageConfiguration) {\n        this.denseKeyProvider = denseKeyProvider;\n        this.getLanguageConfiguration = getLanguageConfiguration;\n        this.languageIdToBracketTokens = new Map();\n    }\n    didLanguageChange(languageId) {\n        // Report a change whenever the language configuration updates.\n        return this.languageIdToBracketTokens.has(languageId);\n    }\n    getSingleLanguageBracketTokens(languageId) {\n        let singleLanguageBracketTokens = this.languageIdToBracketTokens.get(languageId);\n        if (!singleLanguageBracketTokens) {\n            singleLanguageBracketTokens = BracketTokens.createFromLanguage(this.getLanguageConfiguration(languageId), this.denseKeyProvider);\n            this.languageIdToBracketTokens.set(languageId, singleLanguageBracketTokens);\n        }\n        return singleLanguageBracketTokens;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { StandardAutoClosingPairConditional } from '../languageConfiguration.js';\nexport class CharacterPairSupport {\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES = ';:.,=}])> \\n\\t'; }\n    static { this.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS = '\\'\"`;:.,=}])> \\n\\t'; }\n    constructor(config) {\n        if (config.autoClosingPairs) {\n            this._autoClosingPairs = config.autoClosingPairs.map(el => new StandardAutoClosingPairConditional(el));\n        }\n        else if (config.brackets) {\n            this._autoClosingPairs = config.brackets.map(b => new StandardAutoClosingPairConditional({ open: b[0], close: b[1] }));\n        }\n        else {\n            this._autoClosingPairs = [];\n        }\n        if (config.__electricCharacterSupport && config.__electricCharacterSupport.docComment) {\n            const docComment = config.__electricCharacterSupport.docComment;\n            // IDocComment is legacy, only partially supported\n            this._autoClosingPairs.push(new StandardAutoClosingPairConditional({ open: docComment.open, close: docComment.close || '' }));\n        }\n        this._autoCloseBeforeForQuotes = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES;\n        this._autoCloseBeforeForBrackets = typeof config.autoCloseBefore === 'string' ? config.autoCloseBefore : CharacterPairSupport.DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS;\n        this._surroundingPairs = config.surroundingPairs || this._autoClosingPairs;\n    }\n    getAutoClosingPairs() {\n        return this._autoClosingPairs;\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return (forQuotes ? this._autoCloseBeforeForQuotes : this._autoCloseBeforeForBrackets);\n    }\n    getSurroundingPairs() {\n        return this._surroundingPairs;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { distinct } from '../../../../base/common/arrays.js';\nimport { ignoreBracketsInToken } from '../supports.js';\nimport { BracketsUtils } from './richEditBrackets.js';\nexport class BracketElectricCharacterSupport {\n    constructor(richEditBrackets) {\n        this._richEditBrackets = richEditBrackets;\n    }\n    getElectricCharacters() {\n        const result = [];\n        if (this._richEditBrackets) {\n            for (const bracket of this._richEditBrackets.brackets) {\n                for (const close of bracket.close) {\n                    const lastChar = close.charAt(close.length - 1);\n                    result.push(lastChar);\n                }\n            }\n        }\n        return distinct(result);\n    }\n    onElectricCharacter(character, context, column) {\n        if (!this._richEditBrackets || this._richEditBrackets.brackets.length === 0) {\n            return null;\n        }\n        const tokenIndex = context.findTokenIndexAtOffset(column - 1);\n        if (ignoreBracketsInToken(context.getStandardTokenType(tokenIndex))) {\n            return null;\n        }\n        const reversedBracketRegex = this._richEditBrackets.reversedRegex;\n        const text = context.getLineContent().substring(0, column - 1) + character;\n        const r = BracketsUtils.findPrevBracketInRange(reversedBracketRegex, 1, text, 0, text.length);\n        if (!r) {\n            return null;\n        }\n        const bracketText = text.substring(r.startColumn - 1, r.endColumn - 1).toLowerCase();\n        const isOpen = this._richEditBrackets.textIsOpenBracket[bracketText];\n        if (isOpen) {\n            return null;\n        }\n        const textBeforeBracket = context.getActualLineContentBefore(r.startColumn - 1);\n        if (!/^\\s*$/.test(textBeforeBracket)) {\n            // There is other text on the line before the bracket\n            return null;\n        }\n        return {\n            matchOpenBracket: bracketText\n        };\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nfunction resetGlobalRegex(reg) {\n    if (reg.global) {\n        reg.lastIndex = 0;\n    }\n    return true;\n}\nexport class IndentRulesSupport {\n    constructor(indentationRules) {\n        this._indentationRules = indentationRules;\n    }\n    shouldIncrease(text) {\n        if (this._indentationRules) {\n            if (this._indentationRules.increaseIndentPattern && resetGlobalRegex(this._indentationRules.increaseIndentPattern) && this._indentationRules.increaseIndentPattern.test(text)) {\n                return true;\n            }\n            // if (this._indentationRules.indentNextLinePattern && this._indentationRules.indentNextLinePattern.test(text)) {\n            // \treturn true;\n            // }\n        }\n        return false;\n    }\n    shouldDecrease(text) {\n        if (this._indentationRules && this._indentationRules.decreaseIndentPattern && resetGlobalRegex(this._indentationRules.decreaseIndentPattern) && this._indentationRules.decreaseIndentPattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIndentNextLine(text) {\n        if (this._indentationRules && this._indentationRules.indentNextLinePattern && resetGlobalRegex(this._indentationRules.indentNextLinePattern) && this._indentationRules.indentNextLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    shouldIgnore(text) {\n        // the text matches `unIndentedLinePattern`\n        if (this._indentationRules && this._indentationRules.unIndentedLinePattern && resetGlobalRegex(this._indentationRules.unIndentedLinePattern) && this._indentationRules.unIndentedLinePattern.test(text)) {\n            return true;\n        }\n        return false;\n    }\n    getIndentMetadata(text) {\n        let ret = 0;\n        if (this.shouldIncrease(text)) {\n            ret += 1 /* IndentConsts.INCREASE_MASK */;\n        }\n        if (this.shouldDecrease(text)) {\n            ret += 2 /* IndentConsts.DECREASE_MASK */;\n        }\n        if (this.shouldIndentNextLine(text)) {\n            ret += 4 /* IndentConsts.INDENT_NEXTLINE_MASK */;\n        }\n        if (this.shouldIgnore(text)) {\n            ret += 8 /* IndentConsts.UNINDENT_MASK */;\n        }\n        return ret;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { onUnexpectedError } from '../../../../base/common/errors.js';\nimport * as strings from '../../../../base/common/strings.js';\nimport { IndentAction } from '../languageConfiguration.js';\nexport class OnEnterSupport {\n    constructor(opts) {\n        opts = opts || {};\n        opts.brackets = opts.brackets || [\n            ['(', ')'],\n            ['{', '}'],\n            ['[', ']']\n        ];\n        this._brackets = [];\n        opts.brackets.forEach((bracket) => {\n            const openRegExp = OnEnterSupport._createOpenBracketRegExp(bracket[0]);\n            const closeRegExp = OnEnterSupport._createCloseBracketRegExp(bracket[1]);\n            if (openRegExp && closeRegExp) {\n                this._brackets.push({\n                    open: bracket[0],\n                    openRegExp: openRegExp,\n                    close: bracket[1],\n                    closeRegExp: closeRegExp,\n                });\n            }\n        });\n        this._regExpRules = opts.onEnterRules || [];\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        // (1): `regExpRules`\n        if (autoIndent >= 3 /* EditorAutoIndentStrategy.Advanced */) {\n            for (let i = 0, len = this._regExpRules.length; i < len; i++) {\n                const rule = this._regExpRules[i];\n                const regResult = [{\n                        reg: rule.beforeText,\n                        text: beforeEnterText\n                    }, {\n                        reg: rule.afterText,\n                        text: afterEnterText\n                    }, {\n                        reg: rule.previousLineText,\n                        text: previousLineText\n                    }].every((obj) => {\n                    if (!obj.reg) {\n                        return true;\n                    }\n                    obj.reg.lastIndex = 0; // To disable the effect of the \"g\" flag.\n                    return obj.reg.test(obj.text);\n                });\n                if (regResult) {\n                    return rule.action;\n                }\n            }\n        }\n        // (2): Special indent-outdent\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0 && afterEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText) && bracket.closeRegExp.test(afterEnterText)) {\n                        return { indentAction: IndentAction.IndentOutdent };\n                    }\n                }\n            }\n        }\n        // (4): Open bracket based logic\n        if (autoIndent >= 2 /* EditorAutoIndentStrategy.Brackets */) {\n            if (beforeEnterText.length > 0) {\n                for (let i = 0, len = this._brackets.length; i < len; i++) {\n                    const bracket = this._brackets[i];\n                    if (bracket.openRegExp.test(beforeEnterText)) {\n                        return { indentAction: IndentAction.Indent };\n                    }\n                }\n            }\n        }\n        return null;\n    }\n    static _createOpenBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(0))) {\n            str = '\\\\b' + str;\n        }\n        str += '\\\\s*$';\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _createCloseBracketRegExp(bracket) {\n        let str = strings.escapeRegExpCharacters(bracket);\n        if (!/\\B/.test(str.charAt(str.length - 1))) {\n            str = str + '\\\\b';\n        }\n        str = '^\\\\s*' + str;\n        return OnEnterSupport._safeRegExp(str);\n    }\n    static _safeRegExp(def) {\n        try {\n            return new RegExp(def);\n        }\n        catch (err) {\n            onUnexpectedError(err);\n            return null;\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { CachedFunction } from '../../../../base/common/cache.js';\nimport { createBracketOrRegExp } from './richEditBrackets.js';\n/**\n * Captures all bracket related configurations for a single language.\n * Immutable.\n*/\nexport class LanguageBracketsConfiguration {\n    constructor(languageId, config) {\n        this.languageId = languageId;\n        const bracketPairs = config.brackets ? filterValidBrackets(config.brackets) : [];\n        const openingBracketInfos = new CachedFunction((bracket) => {\n            const closing = new Set();\n            return {\n                info: new OpeningBracketKind(this, bracket, closing),\n                closing,\n            };\n        });\n        const closingBracketInfos = new CachedFunction((bracket) => {\n            const opening = new Set();\n            const openingColorized = new Set();\n            return {\n                info: new ClosingBracketKind(this, bracket, opening, openingColorized),\n                opening,\n                openingColorized,\n            };\n        });\n        for (const [open, close] of bracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.opening.add(opening.info);\n        }\n        // Treat colorized brackets as brackets, and mark them as colorized.\n        const colorizedBracketPairs = config.colorizedBracketPairs\n            ? filterValidBrackets(config.colorizedBracketPairs)\n            // If not configured: Take all brackets except `<` ... `>`\n            // Many languages set < ... > as bracket pair, even though they also use it as comparison operator.\n            // This leads to problems when colorizing this bracket, so we exclude it if not explicitly configured otherwise.\n            // https://github.com/microsoft/vscode/issues/132476\n            : bracketPairs.filter((p) => !(p[0] === '<' && p[1] === '>'));\n        for (const [open, close] of colorizedBracketPairs) {\n            const opening = openingBracketInfos.get(open);\n            const closing = closingBracketInfos.get(close);\n            opening.closing.add(closing.info);\n            closing.openingColorized.add(opening.info);\n            closing.opening.add(opening.info);\n        }\n        this._openingBrackets = new Map([...openingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n        this._closingBrackets = new Map([...closingBracketInfos.cachedValues].map(([k, v]) => [k, v.info]));\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get openingBrackets() {\n        return [...this._openingBrackets.values()];\n    }\n    /**\n     * No two brackets have the same bracket text.\n    */\n    get closingBrackets() {\n        return [...this._closingBrackets.values()];\n    }\n    getOpeningBracketInfo(bracketText) {\n        return this._openingBrackets.get(bracketText);\n    }\n    getClosingBracketInfo(bracketText) {\n        return this._closingBrackets.get(bracketText);\n    }\n    getBracketInfo(bracketText) {\n        return this.getOpeningBracketInfo(bracketText) || this.getClosingBracketInfo(bracketText);\n    }\n    getBracketRegExp(options) {\n        const brackets = Array.from([...this._openingBrackets.keys(), ...this._closingBrackets.keys()]);\n        return createBracketOrRegExp(brackets, options);\n    }\n}\nfunction filterValidBrackets(bracketPairs) {\n    return bracketPairs.filter(([open, close]) => open !== '' && close !== '');\n}\nexport class BracketKindBase {\n    constructor(config, bracketText) {\n        this.config = config;\n        this.bracketText = bracketText;\n    }\n    get languageId() {\n        return this.config.languageId;\n    }\n}\nexport class OpeningBracketKind extends BracketKindBase {\n    constructor(config, bracketText, openedBrackets) {\n        super(config, bracketText);\n        this.openedBrackets = openedBrackets;\n        this.isOpeningBracket = true;\n    }\n}\nexport class ClosingBracketKind extends BracketKindBase {\n    constructor(config, bracketText, \n    /**\n     * Non empty array of all opening brackets this bracket closes.\n    */\n    openingBrackets, openingColorizedBrackets) {\n        super(config, bracketText);\n        this.openingBrackets = openingBrackets;\n        this.openingColorizedBrackets = openingColorizedBrackets;\n        this.isOpeningBracket = false;\n    }\n    /**\n     * Checks if this bracket closes the given other bracket.\n     * If the bracket infos come from different configurations, this method will return false.\n    */\n    closes(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingBrackets.has(other);\n    }\n    closesColorized(other) {\n        if (other['config'] !== this.config) {\n            return false;\n        }\n        return this.openingColorizedBrackets.has(other);\n    }\n    getOpeningBrackets() {\n        return [...this.openingBrackets];\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, toDisposable } from '../../../base/common/lifecycle.js';\nimport * as strings from '../../../base/common/strings.js';\nimport { DEFAULT_WORD_REGEXP, ensureValidWordDefinition } from '../core/wordHelper.js';\nimport { AutoClosingPairs } from './languageConfiguration.js';\nimport { CharacterPairSupport } from './supports/characterPair.js';\nimport { BracketElectricCharacterSupport } from './supports/electricCharacter.js';\nimport { IndentRulesSupport } from './supports/indentRules.js';\nimport { OnEnterSupport } from './supports/onEnter.js';\nimport { RichEditBrackets } from './supports/richEditBrackets.js';\nimport { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { ILanguageService } from './language.js';\nimport { registerSingleton } from '../../../platform/instantiation/common/extensions.js';\nimport { PLAINTEXT_LANGUAGE_ID } from './modesRegistry.js';\nimport { LanguageBracketsConfiguration } from './supports/languageBracketsConfiguration.js';\nexport class LanguageConfigurationServiceChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n    affects(languageId) {\n        return !this.languageId ? true : this.languageId === languageId;\n    }\n}\nexport const ILanguageConfigurationService = createDecorator('languageConfigurationService');\nlet LanguageConfigurationService = class LanguageConfigurationService extends Disposable {\n    constructor(configurationService, languageService) {\n        super();\n        this.configurationService = configurationService;\n        this.languageService = languageService;\n        this._registry = this._register(new LanguageConfigurationRegistry());\n        this.onDidChangeEmitter = this._register(new Emitter());\n        this.onDidChange = this.onDidChangeEmitter.event;\n        this.configurations = new Map();\n        const languageConfigKeys = new Set(Object.values(customizedLanguageConfigKeys));\n        this._register(this.configurationService.onDidChangeConfiguration((e) => {\n            const globalConfigChanged = e.change.keys.some((k) => languageConfigKeys.has(k));\n            const localConfigChanged = e.change.overrides\n                .filter(([overrideLangName, keys]) => keys.some((k) => languageConfigKeys.has(k)))\n                .map(([overrideLangName]) => overrideLangName);\n            if (globalConfigChanged) {\n                this.configurations.clear();\n                this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(undefined));\n            }\n            else {\n                for (const languageId of localConfigChanged) {\n                    if (this.languageService.isRegisteredLanguageId(languageId)) {\n                        this.configurations.delete(languageId);\n                        this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(languageId));\n                    }\n                }\n            }\n        }));\n        this._register(this._registry.onDidChange((e) => {\n            this.configurations.delete(e.languageId);\n            this.onDidChangeEmitter.fire(new LanguageConfigurationServiceChangeEvent(e.languageId));\n        }));\n    }\n    register(languageId, configuration, priority) {\n        return this._registry.register(languageId, configuration, priority);\n    }\n    getLanguageConfiguration(languageId) {\n        let result = this.configurations.get(languageId);\n        if (!result) {\n            result = computeConfig(languageId, this._registry, this.configurationService, this.languageService);\n            this.configurations.set(languageId, result);\n        }\n        return result;\n    }\n};\nLanguageConfigurationService = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ILanguageService)\n], LanguageConfigurationService);\nexport { LanguageConfigurationService };\nfunction computeConfig(languageId, registry, configurationService, languageService) {\n    let languageConfig = registry.getLanguageConfiguration(languageId);\n    if (!languageConfig) {\n        if (!languageService.isRegisteredLanguageId(languageId)) {\n            // this happens for the null language, which can be returned by monarch.\n            // Instead of throwing an error, we just return a default config.\n            return new ResolvedLanguageConfiguration(languageId, {});\n        }\n        languageConfig = new ResolvedLanguageConfiguration(languageId, {});\n    }\n    const customizedConfig = getCustomizedLanguageConfig(languageConfig.languageId, configurationService);\n    const data = combineLanguageConfigurations([languageConfig.underlyingConfig, customizedConfig]);\n    const config = new ResolvedLanguageConfiguration(languageConfig.languageId, data);\n    return config;\n}\nconst customizedLanguageConfigKeys = {\n    brackets: 'editor.language.brackets',\n    colorizedBracketPairs: 'editor.language.colorizedBracketPairs'\n};\nfunction getCustomizedLanguageConfig(languageId, configurationService) {\n    const brackets = configurationService.getValue(customizedLanguageConfigKeys.brackets, {\n        overrideIdentifier: languageId,\n    });\n    const colorizedBracketPairs = configurationService.getValue(customizedLanguageConfigKeys.colorizedBracketPairs, {\n        overrideIdentifier: languageId,\n    });\n    return {\n        brackets: validateBracketPairs(brackets),\n        colorizedBracketPairs: validateBracketPairs(colorizedBracketPairs),\n    };\n}\nfunction validateBracketPairs(data) {\n    if (!Array.isArray(data)) {\n        return undefined;\n    }\n    return data.map(pair => {\n        if (!Array.isArray(pair) || pair.length !== 2) {\n            return undefined;\n        }\n        return [pair[0], pair[1]];\n    }).filter((p) => !!p);\n}\nexport function getIndentationAtPosition(model, lineNumber, column) {\n    const lineText = model.getLineContent(lineNumber);\n    let indentation = strings.getLeadingWhitespace(lineText);\n    if (indentation.length > column - 1) {\n        indentation = indentation.substring(0, column - 1);\n    }\n    return indentation;\n}\nclass ComposedLanguageConfiguration {\n    constructor(languageId) {\n        this.languageId = languageId;\n        this._resolved = null;\n        this._entries = [];\n        this._order = 0;\n        this._resolved = null;\n    }\n    register(configuration, priority) {\n        const entry = new LanguageConfigurationContribution(configuration, priority, ++this._order);\n        this._entries.push(entry);\n        this._resolved = null;\n        return toDisposable(() => {\n            for (let i = 0; i < this._entries.length; i++) {\n                if (this._entries[i] === entry) {\n                    this._entries.splice(i, 1);\n                    this._resolved = null;\n                    break;\n                }\n            }\n        });\n    }\n    getResolvedConfiguration() {\n        if (!this._resolved) {\n            const config = this._resolve();\n            if (config) {\n                this._resolved = new ResolvedLanguageConfiguration(this.languageId, config);\n            }\n        }\n        return this._resolved;\n    }\n    _resolve() {\n        if (this._entries.length === 0) {\n            return null;\n        }\n        this._entries.sort(LanguageConfigurationContribution.cmp);\n        return combineLanguageConfigurations(this._entries.map(e => e.configuration));\n    }\n}\nfunction combineLanguageConfigurations(configs) {\n    let result = {\n        comments: undefined,\n        brackets: undefined,\n        wordPattern: undefined,\n        indentationRules: undefined,\n        onEnterRules: undefined,\n        autoClosingPairs: undefined,\n        surroundingPairs: undefined,\n        autoCloseBefore: undefined,\n        folding: undefined,\n        colorizedBracketPairs: undefined,\n        __electricCharacterSupport: undefined,\n    };\n    for (const entry of configs) {\n        result = {\n            comments: entry.comments || result.comments,\n            brackets: entry.brackets || result.brackets,\n            wordPattern: entry.wordPattern || result.wordPattern,\n            indentationRules: entry.indentationRules || result.indentationRules,\n            onEnterRules: entry.onEnterRules || result.onEnterRules,\n            autoClosingPairs: entry.autoClosingPairs || result.autoClosingPairs,\n            surroundingPairs: entry.surroundingPairs || result.surroundingPairs,\n            autoCloseBefore: entry.autoCloseBefore || result.autoCloseBefore,\n            folding: entry.folding || result.folding,\n            colorizedBracketPairs: entry.colorizedBracketPairs || result.colorizedBracketPairs,\n            __electricCharacterSupport: entry.__electricCharacterSupport || result.__electricCharacterSupport,\n        };\n    }\n    return result;\n}\nclass LanguageConfigurationContribution {\n    constructor(configuration, priority, order) {\n        this.configuration = configuration;\n        this.priority = priority;\n        this.order = order;\n    }\n    static cmp(a, b) {\n        if (a.priority === b.priority) {\n            // higher order last\n            return a.order - b.order;\n        }\n        // higher priority last\n        return a.priority - b.priority;\n    }\n}\nexport class LanguageConfigurationChangeEvent {\n    constructor(languageId) {\n        this.languageId = languageId;\n    }\n}\nexport class LanguageConfigurationRegistry extends Disposable {\n    constructor() {\n        super();\n        this._entries = new Map();\n        this._onDidChange = this._register(new Emitter());\n        this.onDidChange = this._onDidChange.event;\n        this._register(this.register(PLAINTEXT_LANGUAGE_ID, {\n            brackets: [\n                ['(', ')'],\n                ['[', ']'],\n                ['{', '}'],\n            ],\n            surroundingPairs: [\n                { open: '{', close: '}' },\n                { open: '[', close: ']' },\n                { open: '(', close: ')' },\n                { open: '<', close: '>' },\n                { open: '\\\"', close: '\\\"' },\n                { open: '\\'', close: '\\'' },\n                { open: '`', close: '`' },\n            ],\n            colorizedBracketPairs: [],\n            folding: {\n                offSide: true\n            }\n        }, 0));\n    }\n    /**\n     * @param priority Use a higher number for higher priority\n     */\n    register(languageId, configuration, priority = 0) {\n        let entries = this._entries.get(languageId);\n        if (!entries) {\n            entries = new ComposedLanguageConfiguration(languageId);\n            this._entries.set(languageId, entries);\n        }\n        const disposable = entries.register(configuration, priority);\n        this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        return toDisposable(() => {\n            disposable.dispose();\n            this._onDidChange.fire(new LanguageConfigurationChangeEvent(languageId));\n        });\n    }\n    getLanguageConfiguration(languageId) {\n        const entries = this._entries.get(languageId);\n        return entries?.getResolvedConfiguration() || null;\n    }\n}\n/**\n * Immutable.\n*/\nexport class ResolvedLanguageConfiguration {\n    constructor(languageId, underlyingConfig) {\n        this.languageId = languageId;\n        this.underlyingConfig = underlyingConfig;\n        this._brackets = null;\n        this._electricCharacter = null;\n        this._onEnterSupport =\n            this.underlyingConfig.brackets ||\n                this.underlyingConfig.indentationRules ||\n                this.underlyingConfig.onEnterRules\n                ? new OnEnterSupport(this.underlyingConfig)\n                : null;\n        this.comments = ResolvedLanguageConfiguration._handleComments(this.underlyingConfig);\n        this.characterPair = new CharacterPairSupport(this.underlyingConfig);\n        this.wordDefinition = this.underlyingConfig.wordPattern || DEFAULT_WORD_REGEXP;\n        this.indentationRules = this.underlyingConfig.indentationRules;\n        if (this.underlyingConfig.indentationRules) {\n            this.indentRulesSupport = new IndentRulesSupport(this.underlyingConfig.indentationRules);\n        }\n        else {\n            this.indentRulesSupport = null;\n        }\n        this.foldingRules = this.underlyingConfig.folding || {};\n        this.bracketsNew = new LanguageBracketsConfiguration(languageId, this.underlyingConfig);\n    }\n    getWordDefinition() {\n        return ensureValidWordDefinition(this.wordDefinition);\n    }\n    get brackets() {\n        if (!this._brackets && this.underlyingConfig.brackets) {\n            this._brackets = new RichEditBrackets(this.languageId, this.underlyingConfig.brackets);\n        }\n        return this._brackets;\n    }\n    get electricCharacter() {\n        if (!this._electricCharacter) {\n            this._electricCharacter = new BracketElectricCharacterSupport(this.brackets);\n        }\n        return this._electricCharacter;\n    }\n    onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText) {\n        if (!this._onEnterSupport) {\n            return null;\n        }\n        return this._onEnterSupport.onEnter(autoIndent, previousLineText, beforeEnterText, afterEnterText);\n    }\n    getAutoClosingPairs() {\n        return new AutoClosingPairs(this.characterPair.getAutoClosingPairs());\n    }\n    getAutoCloseBeforeSet(forQuotes) {\n        return this.characterPair.getAutoCloseBeforeSet(forQuotes);\n    }\n    getSurroundingPairs() {\n        return this.characterPair.getSurroundingPairs();\n    }\n    static _handleComments(conf) {\n        const commentRule = conf.comments;\n        if (!commentRule) {\n            return null;\n        }\n        // comment configuration\n        const comments = {};\n        if (commentRule.lineComment) {\n            comments.lineCommentToken = commentRule.lineComment;\n        }\n        if (commentRule.blockComment) {\n            const [blockStart, blockEnd] = commentRule.blockComment;\n            comments.blockCommentStartToken = blockStart;\n            comments.blockCommentEndToken = blockEnd;\n        }\n        return comments;\n    }\n}\nregisterSingleton(ILanguageConfigurationService, LanguageConfigurationService, 1 /* InstantiationType.Delayed */);\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { NotSupportedError } from '../../../../../base/common/errors.js';\nimport { TokenMetadata } from '../../../encodedTokenAttributes.js';\nimport { TextAstNode } from './ast.js';\nimport { lengthAdd, lengthDiff, lengthGetColumnCountIfZeroLineCount, lengthToObj, lengthZero, toLength } from './length.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nexport class Token {\n    constructor(length, kind, \n    /**\n     * If this token is an opening bracket, this is the id of the opening bracket.\n     * If this token is a closing bracket, this is the id of the first opening bracket that is closed by this bracket.\n     * Otherwise, it is -1.\n     */\n    bracketId, \n    /**\n     * If this token is an opening bracket, this just contains `bracketId`.\n     * If this token is a closing bracket, this lists all opening bracket ids, that it closes.\n     * Otherwise, it is empty.\n     */\n    bracketIds, astNode) {\n        this.length = length;\n        this.kind = kind;\n        this.bracketId = bracketId;\n        this.bracketIds = bracketIds;\n        this.astNode = astNode;\n    }\n}\nexport class TextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.reader = new NonPeekableTextBufferTokenizer(this.textModel, this.bracketTokens);\n        this._offset = lengthZero;\n        this.didPeek = false;\n        this.peeked = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    get offset() {\n        return this._offset;\n    }\n    get length() {\n        return toLength(this.textBufferLineCount - 1, this.textBufferLastLineLength);\n    }\n    skip(length) {\n        this.didPeek = false;\n        this._offset = lengthAdd(this._offset, length);\n        const obj = lengthToObj(this._offset);\n        this.reader.setPosition(obj.lineCount, obj.columnCount);\n    }\n    read() {\n        let token;\n        if (this.peeked) {\n            this.didPeek = false;\n            token = this.peeked;\n        }\n        else {\n            token = this.reader.read();\n        }\n        if (token) {\n            this._offset = lengthAdd(this._offset, token.length);\n        }\n        return token;\n    }\n    peek() {\n        if (!this.didPeek) {\n            this.peeked = this.reader.read();\n            this.didPeek = true;\n        }\n        return this.peeked;\n    }\n}\n/**\n * Does not support peek.\n*/\nclass NonPeekableTextBufferTokenizer {\n    constructor(textModel, bracketTokens) {\n        this.textModel = textModel;\n        this.bracketTokens = bracketTokens;\n        this.lineIdx = 0;\n        this.line = null;\n        this.lineCharOffset = 0;\n        this.lineTokens = null;\n        this.lineTokenOffset = 0;\n        /** Must be a zero line token. The end of the document cannot be peeked. */\n        this.peekedToken = null;\n        this.textBufferLineCount = textModel.getLineCount();\n        this.textBufferLastLineLength = textModel.getLineLength(this.textBufferLineCount);\n    }\n    setPosition(lineIdx, column) {\n        // We must not jump into a token!\n        if (lineIdx === this.lineIdx) {\n            this.lineCharOffset = column;\n            if (this.line !== null) {\n                this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n            }\n        }\n        else {\n            this.lineIdx = lineIdx;\n            this.lineCharOffset = column;\n            this.line = null;\n        }\n        this.peekedToken = null;\n    }\n    read() {\n        if (this.peekedToken) {\n            const token = this.peekedToken;\n            this.peekedToken = null;\n            this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(token.length);\n            return token;\n        }\n        if (this.lineIdx > this.textBufferLineCount - 1 || (this.lineIdx === this.textBufferLineCount - 1 && this.lineCharOffset >= this.textBufferLastLineLength)) {\n            // We are after the end\n            return null;\n        }\n        if (this.line === null) {\n            this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n            this.line = this.lineTokens.getLineContent();\n            this.lineTokenOffset = this.lineCharOffset === 0 ? 0 : this.lineTokens.findTokenIndexAtOffset(this.lineCharOffset);\n        }\n        const startLineIdx = this.lineIdx;\n        const startLineCharOffset = this.lineCharOffset;\n        // limits the length of text tokens.\n        // If text tokens get too long, incremental updates will be slow\n        let lengthHeuristic = 0;\n        while (true) {\n            const lineTokens = this.lineTokens;\n            const tokenCount = lineTokens.getCount();\n            let peekedBracketToken = null;\n            if (this.lineTokenOffset < tokenCount) {\n                const tokenMetadata = lineTokens.getMetadata(this.lineTokenOffset);\n                while (this.lineTokenOffset + 1 < tokenCount && tokenMetadata === lineTokens.getMetadata(this.lineTokenOffset + 1)) {\n                    // Skip tokens that are identical.\n                    // Sometimes, (bracket) identifiers are split up into multiple tokens.\n                    this.lineTokenOffset++;\n                }\n                const isOther = TokenMetadata.getTokenType(tokenMetadata) === 0 /* StandardTokenType.Other */;\n                const containsBracketType = TokenMetadata.containsBalancedBrackets(tokenMetadata);\n                const endOffset = lineTokens.getEndOffset(this.lineTokenOffset);\n                // Is there a bracket token next? Only consume text.\n                if (containsBracketType && isOther && this.lineCharOffset < endOffset) {\n                    const languageId = lineTokens.getLanguageId(this.lineTokenOffset);\n                    const text = this.line.substring(this.lineCharOffset, endOffset);\n                    const brackets = this.bracketTokens.getSingleLanguageBracketTokens(languageId);\n                    const regexp = brackets.regExpGlobal;\n                    if (regexp) {\n                        regexp.lastIndex = 0;\n                        const match = regexp.exec(text);\n                        if (match) {\n                            peekedBracketToken = brackets.getToken(match[0]);\n                            if (peekedBracketToken) {\n                                // Consume leading text of the token\n                                this.lineCharOffset += match.index;\n                            }\n                        }\n                    }\n                }\n                lengthHeuristic += endOffset - this.lineCharOffset;\n                if (peekedBracketToken) {\n                    // Don't skip the entire token, as a single token could contain multiple brackets.\n                    if (startLineIdx !== this.lineIdx || startLineCharOffset !== this.lineCharOffset) {\n                        // There is text before the bracket\n                        this.peekedToken = peekedBracketToken;\n                        break;\n                    }\n                    else {\n                        // Consume the peeked token\n                        this.lineCharOffset += lengthGetColumnCountIfZeroLineCount(peekedBracketToken.length);\n                        return peekedBracketToken;\n                    }\n                }\n                else {\n                    // Skip the entire token, as the token contains no brackets at all.\n                    this.lineTokenOffset++;\n                    this.lineCharOffset = endOffset;\n                }\n            }\n            else {\n                if (this.lineIdx === this.textBufferLineCount - 1) {\n                    break;\n                }\n                this.lineIdx++;\n                this.lineTokens = this.textModel.tokenization.getLineTokens(this.lineIdx + 1);\n                this.lineTokenOffset = 0;\n                this.line = this.lineTokens.getLineContent();\n                this.lineCharOffset = 0;\n                lengthHeuristic += 33; // max 1000/33 = 30 lines\n                // This limits the amount of work to recompute min-indentation\n                if (lengthHeuristic > 1000) {\n                    // only break (automatically) at the end of line.\n                    break;\n                }\n            }\n            if (lengthHeuristic > 1500) {\n                // Eventually break regardless of the line length so that\n                // very long lines do not cause bad performance.\n                // This effective limits max indentation to 500, as\n                // indentation is not computed across multiple text nodes.\n                break;\n            }\n        }\n        // If a token contains some proper indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION}),\n        // unless the line is too long.\n        // Thus, the min indentation of the document is the minimum min indentation of every text node.\n        const length = lengthDiff(startLineIdx, startLineCharOffset, this.lineIdx, this.lineCharOffset);\n        return new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n    }\n}\nexport class FastTokenizer {\n    constructor(text, brackets) {\n        this.text = text;\n        this._offset = lengthZero;\n        this.idx = 0;\n        const regExpStr = brackets.getRegExpStr();\n        const regexp = regExpStr ? new RegExp(regExpStr + '|\\n', 'gi') : null;\n        const tokens = [];\n        let match;\n        let curLineCount = 0;\n        let lastLineBreakOffset = 0;\n        let lastTokenEndOffset = 0;\n        let lastTokenEndLine = 0;\n        const smallTextTokens0Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens0Line.push(new Token(toLength(0, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(0, i))));\n        }\n        const smallTextTokens1Line = [];\n        for (let i = 0; i < 60; i++) {\n            smallTextTokens1Line.push(new Token(toLength(1, i), 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(toLength(1, i))));\n        }\n        if (regexp) {\n            regexp.lastIndex = 0;\n            // If a token contains indentation, it also contains \\n{INDENTATION+}(?!{INDENTATION})\n            while ((match = regexp.exec(text)) !== null) {\n                const curOffset = match.index;\n                const value = match[0];\n                if (value === '\\n') {\n                    curLineCount++;\n                    lastLineBreakOffset = curOffset + 1;\n                }\n                else {\n                    if (lastTokenEndOffset !== curOffset) {\n                        let token;\n                        if (lastTokenEndLine === curLineCount) {\n                            const colCount = curOffset - lastTokenEndOffset;\n                            if (colCount < smallTextTokens0Line.length) {\n                                token = smallTextTokens0Line[colCount];\n                            }\n                            else {\n                                const length = toLength(0, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        else {\n                            const lineCount = curLineCount - lastTokenEndLine;\n                            const colCount = curOffset - lastLineBreakOffset;\n                            if (lineCount === 1 && colCount < smallTextTokens1Line.length) {\n                                token = smallTextTokens1Line[colCount];\n                            }\n                            else {\n                                const length = toLength(lineCount, colCount);\n                                token = new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length));\n                            }\n                        }\n                        tokens.push(token);\n                    }\n                    // value is matched by regexp, so the token must exist\n                    tokens.push(brackets.getToken(value));\n                    lastTokenEndOffset = curOffset + value.length;\n                    lastTokenEndLine = curLineCount;\n                }\n            }\n        }\n        const offset = text.length;\n        if (lastTokenEndOffset !== offset) {\n            const length = (lastTokenEndLine === curLineCount)\n                ? toLength(0, offset - lastTokenEndOffset)\n                : toLength(curLineCount - lastTokenEndLine, offset - lastLineBreakOffset);\n            tokens.push(new Token(length, 0 /* TokenKind.Text */, -1, SmallImmutableSet.getEmpty(), new TextAstNode(length)));\n        }\n        this.length = toLength(curLineCount, offset - lastLineBreakOffset);\n        this.tokens = tokens;\n    }\n    get offset() {\n        return this._offset;\n    }\n    read() {\n        return this.tokens[this.idx++] || null;\n    }\n    peek() {\n        return this.tokens[this.idx] || null;\n    }\n    skip(length) {\n        throw new NotSupportedError();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { TokenMetadata } from '../encodedTokenAttributes.js';\nexport class LineTokens {\n    static { this.defaultTokenMetadata = ((0 /* FontStyle.None */ << 11 /* MetadataConsts.FONT_STYLE_OFFSET */)\n        | (1 /* ColorId.DefaultForeground */ << 15 /* MetadataConsts.FOREGROUND_OFFSET */)\n        | (2 /* ColorId.DefaultBackground */ << 24 /* MetadataConsts.BACKGROUND_OFFSET */)) >>> 0; }\n    static createEmpty(lineContent, decoder) {\n        const defaultMetadata = LineTokens.defaultTokenMetadata;\n        const tokens = new Uint32Array(2);\n        tokens[0] = lineContent.length;\n        tokens[1] = defaultMetadata;\n        return new LineTokens(tokens, lineContent, decoder);\n    }\n    static createFromTextAndMetadata(data, decoder) {\n        let offset = 0;\n        let fullText = '';\n        const tokens = new Array();\n        for (const { text, metadata } of data) {\n            tokens.push(offset + text.length, metadata);\n            offset += text.length;\n            fullText += text;\n        }\n        return new LineTokens(new Uint32Array(tokens), fullText, decoder);\n    }\n    constructor(tokens, text, decoder) {\n        this._lineTokensBrand = undefined;\n        this._tokens = tokens;\n        this._tokensCount = (this._tokens.length >>> 1);\n        this._text = text;\n        this.languageIdCodec = decoder;\n    }\n    equals(other) {\n        if (other instanceof LineTokens) {\n            return this.slicedEquals(other, 0, this._tokensCount);\n        }\n        return false;\n    }\n    slicedEquals(other, sliceFromTokenIndex, sliceTokenCount) {\n        if (this._text !== other._text) {\n            return false;\n        }\n        if (this._tokensCount !== other._tokensCount) {\n            return false;\n        }\n        const from = (sliceFromTokenIndex << 1);\n        const to = from + (sliceTokenCount << 1);\n        for (let i = from; i < to; i++) {\n            if (this._tokens[i] !== other._tokens[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n    getLineContent() {\n        return this._text;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStartOffset(tokenIndex) {\n        if (tokenIndex > 0) {\n            return this._tokens[(tokenIndex - 1) << 1];\n        }\n        return 0;\n    }\n    getMetadata(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return metadata;\n    }\n    getLanguageId(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        const languageId = TokenMetadata.getLanguageId(metadata);\n        return this.languageIdCodec.decodeLanguageId(languageId);\n    }\n    getStandardTokenType(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getTokenType(metadata);\n    }\n    getForeground(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getForeground(metadata);\n    }\n    getClassName(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getClassNameFromMetadata(metadata);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getInlineStyleFromMetadata(metadata, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        const metadata = this._tokens[(tokenIndex << 1) + 1];\n        return TokenMetadata.getPresentationFromMetadata(metadata);\n    }\n    getEndOffset(tokenIndex) {\n        return this._tokens[tokenIndex << 1];\n    }\n    /**\n     * Find the token containing offset `offset`.\n     * @param offset The search offset\n     * @return The index of the token containing the offset.\n     */\n    findTokenIndexAtOffset(offset) {\n        return LineTokens.findIndexInTokensArray(this._tokens, offset);\n    }\n    inflate() {\n        return this;\n    }\n    sliceAndInflate(startOffset, endOffset, deltaOffset) {\n        return new SliceLineTokens(this, startOffset, endOffset, deltaOffset);\n    }\n    static convertToEndOffset(tokens, lineTextLength) {\n        const tokenCount = (tokens.length >>> 1);\n        const lastTokenIndex = tokenCount - 1;\n        for (let tokenIndex = 0; tokenIndex < lastTokenIndex; tokenIndex++) {\n            tokens[tokenIndex << 1] = tokens[(tokenIndex + 1) << 1];\n        }\n        tokens[lastTokenIndex << 1] = lineTextLength;\n    }\n    static findIndexInTokensArray(tokens, desiredIndex) {\n        if (tokens.length <= 2) {\n            return 0;\n        }\n        let low = 0;\n        let high = (tokens.length >>> 1) - 1;\n        while (low < high) {\n            const mid = low + Math.floor((high - low) / 2);\n            const endOffset = tokens[(mid << 1)];\n            if (endOffset === desiredIndex) {\n                return mid + 1;\n            }\n            else if (endOffset < desiredIndex) {\n                low = mid + 1;\n            }\n            else if (endOffset > desiredIndex) {\n                high = mid;\n            }\n        }\n        return low;\n    }\n    /**\n     * @pure\n     * @param insertTokens Must be sorted by offset.\n    */\n    withInserted(insertTokens) {\n        if (insertTokens.length === 0) {\n            return this;\n        }\n        let nextOriginalTokenIdx = 0;\n        let nextInsertTokenIdx = 0;\n        let text = '';\n        const newTokens = new Array();\n        let originalEndOffset = 0;\n        while (true) {\n            const nextOriginalTokenEndOffset = nextOriginalTokenIdx < this._tokensCount ? this._tokens[nextOriginalTokenIdx << 1] : -1;\n            const nextInsertToken = nextInsertTokenIdx < insertTokens.length ? insertTokens[nextInsertTokenIdx] : null;\n            if (nextOriginalTokenEndOffset !== -1 && (nextInsertToken === null || nextOriginalTokenEndOffset <= nextInsertToken.offset)) {\n                // original token ends before next insert token\n                text += this._text.substring(originalEndOffset, nextOriginalTokenEndOffset);\n                const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                newTokens.push(text.length, metadata);\n                nextOriginalTokenIdx++;\n                originalEndOffset = nextOriginalTokenEndOffset;\n            }\n            else if (nextInsertToken) {\n                if (nextInsertToken.offset > originalEndOffset) {\n                    // insert token is in the middle of the next token.\n                    text += this._text.substring(originalEndOffset, nextInsertToken.offset);\n                    const metadata = this._tokens[(nextOriginalTokenIdx << 1) + 1];\n                    newTokens.push(text.length, metadata);\n                    originalEndOffset = nextInsertToken.offset;\n                }\n                text += nextInsertToken.text;\n                newTokens.push(text.length, nextInsertToken.tokenMetadata);\n                nextInsertTokenIdx++;\n            }\n            else {\n                break;\n            }\n        }\n        return new LineTokens(new Uint32Array(newTokens), text, this.languageIdCodec);\n    }\n    getTokenText(tokenIndex) {\n        const startOffset = this.getStartOffset(tokenIndex);\n        const endOffset = this.getEndOffset(tokenIndex);\n        const text = this._text.substring(startOffset, endOffset);\n        return text;\n    }\n    forEach(callback) {\n        const tokenCount = this.getCount();\n        for (let tokenIndex = 0; tokenIndex < tokenCount; tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nclass SliceLineTokens {\n    constructor(source, startOffset, endOffset, deltaOffset) {\n        this._source = source;\n        this._startOffset = startOffset;\n        this._endOffset = endOffset;\n        this._deltaOffset = deltaOffset;\n        this._firstTokenIndex = source.findTokenIndexAtOffset(startOffset);\n        this.languageIdCodec = source.languageIdCodec;\n        this._tokensCount = 0;\n        for (let i = this._firstTokenIndex, len = source.getCount(); i < len; i++) {\n            const tokenStartOffset = source.getStartOffset(i);\n            if (tokenStartOffset >= endOffset) {\n                break;\n            }\n            this._tokensCount++;\n        }\n    }\n    getMetadata(tokenIndex) {\n        return this._source.getMetadata(this._firstTokenIndex + tokenIndex);\n    }\n    getLanguageId(tokenIndex) {\n        return this._source.getLanguageId(this._firstTokenIndex + tokenIndex);\n    }\n    getLineContent() {\n        return this._source.getLineContent().substring(this._startOffset, this._endOffset);\n    }\n    equals(other) {\n        if (other instanceof SliceLineTokens) {\n            return (this._startOffset === other._startOffset\n                && this._endOffset === other._endOffset\n                && this._deltaOffset === other._deltaOffset\n                && this._source.slicedEquals(other._source, this._firstTokenIndex, this._tokensCount));\n        }\n        return false;\n    }\n    getCount() {\n        return this._tokensCount;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._source.getStandardTokenType(this._firstTokenIndex + tokenIndex);\n    }\n    getForeground(tokenIndex) {\n        return this._source.getForeground(this._firstTokenIndex + tokenIndex);\n    }\n    getEndOffset(tokenIndex) {\n        const tokenEndOffset = this._source.getEndOffset(this._firstTokenIndex + tokenIndex);\n        return Math.min(this._endOffset, tokenEndOffset) - this._startOffset + this._deltaOffset;\n    }\n    getClassName(tokenIndex) {\n        return this._source.getClassName(this._firstTokenIndex + tokenIndex);\n    }\n    getInlineStyle(tokenIndex, colorMap) {\n        return this._source.getInlineStyle(this._firstTokenIndex + tokenIndex, colorMap);\n    }\n    getPresentation(tokenIndex) {\n        return this._source.getPresentation(this._firstTokenIndex + tokenIndex);\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._source.findTokenIndexAtOffset(offset + this._startOffset - this._deltaOffset) - this._firstTokenIndex;\n    }\n    getTokenText(tokenIndex) {\n        const adjustedTokenIndex = this._firstTokenIndex + tokenIndex;\n        const tokenStartOffset = this._source.getStartOffset(adjustedTokenIndex);\n        const tokenEndOffset = this._source.getEndOffset(adjustedTokenIndex);\n        let text = this._source.getTokenText(adjustedTokenIndex);\n        if (tokenStartOffset < this._startOffset) {\n            text = text.substring(this._startOffset - tokenStartOffset);\n        }\n        if (tokenEndOffset > this._endOffset) {\n            text = text.substring(0, text.length - (tokenEndOffset - this._endOffset));\n        }\n        return text;\n    }\n    forEach(callback) {\n        for (let tokenIndex = 0; tokenIndex < this.getCount(); tokenIndex++) {\n            callback(tokenIndex);\n        }\n    }\n}\nexport function getStandardTokenTypeAtPosition(model, position) {\n    const lineNumber = position.lineNumber;\n    if (!model.tokenization.isCheapToTokenize(lineNumber)) {\n        return undefined;\n    }\n    model.tokenization.forceTokenization(lineNumber);\n    const lineTokens = model.tokenization.getLineTokens(lineNumber);\n    const tokenIndex = lineTokens.findTokenIndexAtOffset(position.column - 1);\n    const tokenType = lineTokens.getStandardTokenType(tokenIndex);\n    return tokenType;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ListAstNode } from './ast.js';\n/**\n * Concatenates a list of (2,3) AstNode's into a single (2,3) AstNode.\n * This mutates the items of the input array!\n * If all items have the same height, this method has runtime O(items.length).\n * Otherwise, it has runtime O(items.length * max(log(items.length), items.max(i => i.height))).\n*/\nexport function concat23Trees(items) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let i = 0;\n    /**\n     * Reads nodes of same height and concatenates them to a single node.\n    */\n    function readNode() {\n        if (i >= items.length) {\n            return null;\n        }\n        const start = i;\n        const height = items[start].listHeight;\n        i++;\n        while (i < items.length && items[i].listHeight === height) {\n            i++;\n        }\n        if (i - start >= 2) {\n            return concat23TreesOfSameHeight(start === 0 && i === items.length ? items : items.slice(start, i), false);\n        }\n        else {\n            return items[start];\n        }\n    }\n    // The items might not have the same height.\n    // We merge all items by using a binary concat operator.\n    let first = readNode(); // There must be a first item\n    let second = readNode();\n    if (!second) {\n        return first;\n    }\n    for (let item = readNode(); item; item = readNode()) {\n        // Prefer concatenating smaller trees, as the runtime of concat depends on the tree height.\n        if (heightDiff(first, second) <= heightDiff(second, item)) {\n            first = concat(first, second);\n            second = item;\n        }\n        else {\n            second = concat(second, item);\n        }\n    }\n    const result = concat(first, second);\n    return result;\n}\nexport function concat23TreesOfSameHeight(items, createImmutableLists = false) {\n    if (items.length === 0) {\n        return null;\n    }\n    if (items.length === 1) {\n        return items[0];\n    }\n    let length = items.length;\n    // All trees have same height, just create parent nodes.\n    while (length > 3) {\n        const newLength = length >> 1;\n        for (let i = 0; i < newLength; i++) {\n            const j = i << 1;\n            items[i] = ListAstNode.create23(items[j], items[j + 1], j + 3 === length ? items[j + 2] : null, createImmutableLists);\n        }\n        length = newLength;\n    }\n    return ListAstNode.create23(items[0], items[1], length >= 3 ? items[2] : null, createImmutableLists);\n}\nfunction heightDiff(node1, node2) {\n    return Math.abs(node1.listHeight - node2.listHeight);\n}\nfunction concat(node1, node2) {\n    if (node1.listHeight === node2.listHeight) {\n        return ListAstNode.create23(node1, node2, null, false);\n    }\n    else if (node1.listHeight > node2.listHeight) {\n        // node1 is the tree we want to insert into\n        return append(node1, node2);\n    }\n    else {\n        return prepend(node2, node1);\n    }\n}\n/**\n * Appends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction append(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    let nodeToAppendOfCorrectHeight;\n    while (true) {\n        // assert nodeToInsert.listHeight <= curNode.listHeight\n        if (nodeToAppend.listHeight === curNode.listHeight) {\n            nodeToAppendOfCorrectHeight = nodeToAppend;\n            break;\n        }\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenLength <= 3\n        curNode = curNode.makeLastElementMutable();\n    }\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToAppendOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToAppendOfCorrectHeight = ListAstNode.create23(parent.unappendChild(), nodeToAppendOfCorrectHeight, null, false);\n            }\n            else {\n                parent.appendChildOfSameHeight(nodeToAppendOfCorrectHeight);\n                nodeToAppendOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToAppendOfCorrectHeight) {\n        return ListAstNode.create23(list, nodeToAppendOfCorrectHeight, null, false);\n    }\n    else {\n        return list;\n    }\n}\n/**\n * Prepends the given node to the end of this (2,3) tree.\n * Returns the new root.\n*/\nfunction prepend(list, nodeToAppend) {\n    list = list.toMutable();\n    let curNode = list;\n    const parents = [];\n    // assert nodeToInsert.listHeight <= curNode.listHeight\n    while (nodeToAppend.listHeight !== curNode.listHeight) {\n        // assert 0 <= nodeToInsert.listHeight < curNode.listHeight\n        if (curNode.kind !== 4 /* AstNodeKind.List */) {\n            throw new Error('unexpected');\n        }\n        parents.push(curNode);\n        // assert 2 <= curNode.childrenFast.length <= 3\n        curNode = curNode.makeFirstElementMutable();\n    }\n    let nodeToPrependOfCorrectHeight = nodeToAppend;\n    // assert nodeToAppendOfCorrectHeight!.listHeight === curNode.listHeight\n    for (let i = parents.length - 1; i >= 0; i--) {\n        const parent = parents[i];\n        if (nodeToPrependOfCorrectHeight) {\n            // Can we take the element?\n            if (parent.childrenLength >= 3) {\n                // assert parent.childrenLength === 3 && parent.listHeight === nodeToAppendOfCorrectHeight.listHeight + 1\n                // we need to split to maintain (2,3)-tree property.\n                // Send the third element + the new element to the parent.\n                nodeToPrependOfCorrectHeight = ListAstNode.create23(nodeToPrependOfCorrectHeight, parent.unprependChild(), null, false);\n            }\n            else {\n                parent.prependChildOfSameHeight(nodeToPrependOfCorrectHeight);\n                nodeToPrependOfCorrectHeight = undefined;\n            }\n        }\n        else {\n            parent.handleChildrenChanged();\n        }\n    }\n    if (nodeToPrependOfCorrectHeight) {\n        return ListAstNode.create23(nodeToPrependOfCorrectHeight, list, null, false);\n    }\n    else {\n        return list;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { lengthAdd, lengthZero, lengthLessThan } from './length.js';\n/**\n * Allows to efficiently find a longest child at a given offset in a fixed node.\n * The requested offsets must increase monotonously.\n*/\nexport class NodeReader {\n    constructor(node) {\n        this.lastOffset = lengthZero;\n        this.nextNodes = [node];\n        this.offsets = [lengthZero];\n        this.idxs = [];\n    }\n    /**\n     * Returns the longest node at `offset` that satisfies the predicate.\n     * @param offset must be greater than or equal to the last offset this method has been called with!\n    */\n    readLongestNodeAt(offset, predicate) {\n        if (lengthLessThan(offset, this.lastOffset)) {\n            throw new Error('Invalid offset');\n        }\n        this.lastOffset = offset;\n        // Find the longest node of all those that are closest to the current offset.\n        while (true) {\n            const curNode = lastOrUndefined(this.nextNodes);\n            if (!curNode) {\n                return undefined;\n            }\n            const curNodeOffset = lastOrUndefined(this.offsets);\n            if (lengthLessThan(offset, curNodeOffset)) {\n                // The next best node is not here yet.\n                // The reader must advance before a cached node is hit.\n                return undefined;\n            }\n            if (lengthLessThan(curNodeOffset, offset)) {\n                // The reader is ahead of the current node.\n                if (lengthAdd(curNodeOffset, curNode.length) <= offset) {\n                    // The reader is after the end of the current node.\n                    this.nextNodeAfterCurrent();\n                }\n                else {\n                    // The reader is somewhere in the current node.\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    if (nextChildIdx !== -1) {\n                        // Go to the first child and repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                    else {\n                        // We don't have children\n                        this.nextNodeAfterCurrent();\n                    }\n                }\n            }\n            else {\n                // readerOffsetBeforeChange === curNodeOffset\n                if (predicate(curNode)) {\n                    this.nextNodeAfterCurrent();\n                    return curNode;\n                }\n                else {\n                    const nextChildIdx = getNextChildIdx(curNode);\n                    // look for shorter node\n                    if (nextChildIdx === -1) {\n                        // There is no shorter node.\n                        this.nextNodeAfterCurrent();\n                        return undefined;\n                    }\n                    else {\n                        // Descend into first child & repeat.\n                        this.nextNodes.push(curNode.getChild(nextChildIdx));\n                        this.offsets.push(curNodeOffset);\n                        this.idxs.push(nextChildIdx);\n                    }\n                }\n            }\n        }\n    }\n    // Navigates to the longest node that continues after the current node.\n    nextNodeAfterCurrent() {\n        while (true) {\n            const currentOffset = lastOrUndefined(this.offsets);\n            const currentNode = lastOrUndefined(this.nextNodes);\n            this.nextNodes.pop();\n            this.offsets.pop();\n            if (this.idxs.length === 0) {\n                // We just popped the root node, there is no next node.\n                break;\n            }\n            // Parent is not undefined, because idxs is not empty\n            const parent = lastOrUndefined(this.nextNodes);\n            const nextChildIdx = getNextChildIdx(parent, this.idxs[this.idxs.length - 1]);\n            if (nextChildIdx !== -1) {\n                this.nextNodes.push(parent.getChild(nextChildIdx));\n                this.offsets.push(lengthAdd(currentOffset, currentNode.length));\n                this.idxs[this.idxs.length - 1] = nextChildIdx;\n                break;\n            }\n            else {\n                this.idxs.pop();\n            }\n            // We fully consumed the parent.\n            // Current node is now parent, so call nextNodeAfterCurrent again\n        }\n    }\n}\nfunction getNextChildIdx(node, curIdx = -1) {\n    while (true) {\n        curIdx++;\n        if (curIdx >= node.childrenLength) {\n            return -1;\n        }\n        if (node.getChild(curIdx)) {\n            return curIdx;\n        }\n    }\n}\nfunction lastOrUndefined(arr) {\n    return arr.length > 0 ? arr[arr.length - 1] : undefined;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { InvalidBracketAstNode, ListAstNode, PairAstNode, TextAstNode } from './ast.js';\nimport { BeforeEditPositionMapper } from './beforeEditPositionMapper.js';\nimport { SmallImmutableSet } from './smallImmutableSet.js';\nimport { lengthIsZero, lengthLessThan } from './length.js';\nimport { concat23Trees, concat23TreesOfSameHeight } from './concat23Trees.js';\nimport { NodeReader } from './nodeReader.js';\n/**\n * Non incrementally built ASTs are immutable.\n*/\nexport function parseDocument(tokenizer, edits, oldNode, createImmutableLists) {\n    const parser = new Parser(tokenizer, edits, oldNode, createImmutableLists);\n    return parser.parseDocument();\n}\n/**\n * Non incrementally built ASTs are immutable.\n*/\nclass Parser {\n    constructor(tokenizer, edits, oldNode, createImmutableLists) {\n        this.tokenizer = tokenizer;\n        this.createImmutableLists = createImmutableLists;\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        if (oldNode && createImmutableLists) {\n            throw new Error('Not supported');\n        }\n        this.oldNodeReader = oldNode ? new NodeReader(oldNode) : undefined;\n        this.positionMapper = new BeforeEditPositionMapper(edits);\n    }\n    parseDocument() {\n        this._itemsConstructed = 0;\n        this._itemsFromCache = 0;\n        let result = this.parseList(SmallImmutableSet.getEmpty(), 0);\n        if (!result) {\n            result = ListAstNode.getEmpty();\n        }\n        return result;\n    }\n    parseList(openedBracketIds, level) {\n        const items = [];\n        while (true) {\n            let child = this.tryReadChildFromCache(openedBracketIds);\n            if (!child) {\n                const token = this.tokenizer.peek();\n                if (!token ||\n                    (token.kind === 2 /* TokenKind.ClosingBracket */ &&\n                        token.bracketIds.intersects(openedBracketIds))) {\n                    break;\n                }\n                child = this.parseChild(openedBracketIds, level + 1);\n            }\n            if (child.kind === 4 /* AstNodeKind.List */ && child.childrenLength === 0) {\n                continue;\n            }\n            items.push(child);\n        }\n        // When there is no oldNodeReader, all items are created from scratch and must have the same height.\n        const result = this.oldNodeReader ? concat23Trees(items) : concat23TreesOfSameHeight(items, this.createImmutableLists);\n        return result;\n    }\n    tryReadChildFromCache(openedBracketIds) {\n        if (this.oldNodeReader) {\n            const maxCacheableLength = this.positionMapper.getDistanceToNextChange(this.tokenizer.offset);\n            if (maxCacheableLength === null || !lengthIsZero(maxCacheableLength)) {\n                const cachedNode = this.oldNodeReader.readLongestNodeAt(this.positionMapper.getOffsetBeforeChange(this.tokenizer.offset), curNode => {\n                    // The edit could extend the ending token, thus we cannot re-use nodes that touch the edit.\n                    // If there is no edit anymore, we can re-use the node in any case.\n                    if (maxCacheableLength !== null && !lengthLessThan(curNode.length, maxCacheableLength)) {\n                        // Either the node contains edited text or touches edited text.\n                        // In the latter case, brackets might have been extended (`end` -> `ending`), so even touching nodes cannot be reused.\n                        return false;\n                    }\n                    const canBeReused = curNode.canBeReused(openedBracketIds);\n                    return canBeReused;\n                });\n                if (cachedNode) {\n                    this._itemsFromCache++;\n                    this.tokenizer.skip(cachedNode.length);\n                    return cachedNode;\n                }\n            }\n        }\n        return undefined;\n    }\n    parseChild(openedBracketIds, level) {\n        this._itemsConstructed++;\n        const token = this.tokenizer.read();\n        switch (token.kind) {\n            case 2 /* TokenKind.ClosingBracket */:\n                return new InvalidBracketAstNode(token.bracketIds, token.length);\n            case 0 /* TokenKind.Text */:\n                return token.astNode;\n            case 1 /* TokenKind.OpeningBracket */: {\n                if (level > 300) {\n                    // To prevent stack overflows\n                    return new TextAstNode(token.length);\n                }\n                const set = openedBracketIds.merge(token.bracketIds);\n                const child = this.parseList(set, level + 1);\n                const nextToken = this.tokenizer.peek();\n                if (nextToken &&\n                    nextToken.kind === 2 /* TokenKind.ClosingBracket */ &&\n                    (nextToken.bracketId === token.bracketId || nextToken.bracketIds.intersects(token.bracketIds))) {\n                    this.tokenizer.read();\n                    return PairAstNode.create(token.astNode, child, nextToken.astNode);\n                }\n                else {\n                    return PairAstNode.create(token.astNode, child, null);\n                }\n            }\n            default:\n                throw new Error('unexpected');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { ArrayQueue } from '../../../../../base/common/arrays.js';\nimport { TextEditInfo } from './beforeEditPositionMapper.js';\nimport { lengthAdd, lengthDiffNonNegative, lengthEquals, lengthIsZero, lengthToObj, lengthZero, sumLengths } from './length.js';\nexport function combineTextEditInfos(textEditInfoFirst, textEditInfoSecond) {\n    if (textEditInfoFirst.length === 0) {\n        return textEditInfoSecond;\n    }\n    if (textEditInfoSecond.length === 0) {\n        return textEditInfoFirst;\n    }\n    // s0: State before any edits\n    const s0ToS1Map = new ArrayQueue(toLengthMapping(textEditInfoFirst));\n    // s1: State after first edit, but before second edit\n    const s1ToS2Map = toLengthMapping(textEditInfoSecond);\n    s1ToS2Map.push({ modified: false, lengthBefore: undefined, lengthAfter: undefined }); // Copy everything from old to new\n    // s2: State after both edits\n    let curItem = s0ToS1Map.dequeue();\n    /**\n     * @param s1Length Use undefined for length \"infinity\"\n     */\n    function nextS0ToS1MapWithS1LengthOf(s1Length) {\n        if (s1Length === undefined) {\n            const arr = s0ToS1Map.takeWhile(v => true) || [];\n            if (curItem) {\n                arr.unshift(curItem);\n            }\n            return arr;\n        }\n        const result = [];\n        while (curItem && !lengthIsZero(s1Length)) {\n            const [item, remainingItem] = curItem.splitAt(s1Length);\n            result.push(item);\n            s1Length = lengthDiffNonNegative(item.lengthAfter, s1Length);\n            curItem = remainingItem ?? s0ToS1Map.dequeue();\n        }\n        if (!lengthIsZero(s1Length)) {\n            result.push(new LengthMapping(false, s1Length, s1Length));\n        }\n        return result;\n    }\n    const result = [];\n    function pushEdit(startOffset, endOffset, newLength) {\n        if (result.length > 0 && lengthEquals(result[result.length - 1].endOffset, startOffset)) {\n            const lastResult = result[result.length - 1];\n            result[result.length - 1] = new TextEditInfo(lastResult.startOffset, endOffset, lengthAdd(lastResult.newLength, newLength));\n        }\n        else {\n            result.push({ startOffset, endOffset, newLength });\n        }\n    }\n    let s0offset = lengthZero;\n    for (const s1ToS2 of s1ToS2Map) {\n        const s0ToS1Map = nextS0ToS1MapWithS1LengthOf(s1ToS2.lengthBefore);\n        if (s1ToS2.modified) {\n            const s0Length = sumLengths(s0ToS1Map, s => s.lengthBefore);\n            const s0EndOffset = lengthAdd(s0offset, s0Length);\n            pushEdit(s0offset, s0EndOffset, s1ToS2.lengthAfter);\n            s0offset = s0EndOffset;\n        }\n        else {\n            for (const s1 of s0ToS1Map) {\n                const s0startOffset = s0offset;\n                s0offset = lengthAdd(s0offset, s1.lengthBefore);\n                if (s1.modified) {\n                    pushEdit(s0startOffset, s0offset, s1.lengthAfter);\n                }\n            }\n        }\n    }\n    return result;\n}\nclass LengthMapping {\n    constructor(\n    /**\n     * If false, length before and length after equal.\n     */\n    modified, lengthBefore, lengthAfter) {\n        this.modified = modified;\n        this.lengthBefore = lengthBefore;\n        this.lengthAfter = lengthAfter;\n    }\n    splitAt(lengthAfter) {\n        const remainingLengthAfter = lengthDiffNonNegative(lengthAfter, this.lengthAfter);\n        if (lengthEquals(remainingLengthAfter, lengthZero)) {\n            return [this, undefined];\n        }\n        else if (this.modified) {\n            return [\n                new LengthMapping(this.modified, this.lengthBefore, lengthAfter),\n                new LengthMapping(this.modified, lengthZero, remainingLengthAfter)\n            ];\n        }\n        else {\n            return [\n                new LengthMapping(this.modified, lengthAfter, lengthAfter),\n                new LengthMapping(this.modified, remainingLengthAfter, remainingLengthAfter)\n            ];\n        }\n    }\n    toString() {\n        return `${this.modified ? 'M' : 'U'}:${lengthToObj(this.lengthBefore)} -> ${lengthToObj(this.lengthAfter)}`;\n    }\n}\nfunction toLengthMapping(textEditInfos) {\n    const result = [];\n    let lastOffset = lengthZero;\n    for (const textEditInfo of textEditInfos) {\n        const spaceLength = lengthDiffNonNegative(lastOffset, textEditInfo.startOffset);\n        if (!lengthIsZero(spaceLength)) {\n            result.push(new LengthMapping(false, spaceLength, spaceLength));\n        }\n        const lengthBefore = lengthDiffNonNegative(textEditInfo.startOffset, textEditInfo.endOffset);\n        result.push(new LengthMapping(true, lengthBefore, textEditInfo.newLength));\n        lastOffset = textEditInfo.endOffset;\n    }\n    return result;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport class SyncDescriptor {\n    constructor(ctor, staticArguments = [], supportsDelayedInstantiation = false) {\n        this.ctor = ctor;\n        this.staticArguments = staticArguments;\n        this.supportsDelayedInstantiation = supportsDelayedInstantiation;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport var HorizontalGuidesState;\n(function (HorizontalGuidesState) {\n    HorizontalGuidesState[HorizontalGuidesState[\"Disabled\"] = 0] = \"Disabled\";\n    HorizontalGuidesState[HorizontalGuidesState[\"EnabledForActive\"] = 1] = \"EnabledForActive\";\n    HorizontalGuidesState[HorizontalGuidesState[\"Enabled\"] = 2] = \"Enabled\";\n})(HorizontalGuidesState || (HorizontalGuidesState = {}));\nexport class IndentGuide {\n    constructor(visibleColumn, column, className, \n    /**\n     * If set, this indent guide is a horizontal guide (no vertical part).\n     * It starts at visibleColumn and continues until endColumn.\n    */\n    horizontalLine, \n    /**\n     * If set (!= -1), only show this guide for wrapped lines that don't contain this model column, but are after it.\n    */\n    forWrappedLinesAfterColumn, forWrappedLinesBeforeOrAtColumn) {\n        this.visibleColumn = visibleColumn;\n        this.column = column;\n        this.className = className;\n        this.horizontalLine = horizontalLine;\n        this.forWrappedLinesAfterColumn = forWrappedLinesAfterColumn;\n        this.forWrappedLinesBeforeOrAtColumn = forWrappedLinesBeforeOrAtColumn;\n        if ((visibleColumn !== -1) === (column !== -1)) {\n            throw new Error();\n        }\n    }\n}\nexport class IndentGuideHorizontalLine {\n    constructor(top, endColumn) {\n        this.top = top;\n        this.endColumn = endColumn;\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { Disposable } from '../../../base/common/lifecycle.js';\nexport class TextModelPart extends Disposable {\n    constructor() {\n        super(...arguments);\n        this._isDisposed = false;\n    }\n    dispose() {\n        super.dispose();\n        this._isDisposed = true;\n    }\n    assertNotDisposed() {\n        if (this._isDisposed) {\n            throw new Error('TextModelPart is disposed!');\n        }\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n/**\n * Returns:\n *  - -1 => the line consists of whitespace\n *  - otherwise => the indent level is returned value\n */\nexport function computeIndentLevel(line, tabSize) {\n    let indent = 0;\n    let i = 0;\n    const len = line.length;\n    while (i < len) {\n        const chCode = line.charCodeAt(i);\n        if (chCode === 32 /* CharCode.Space */) {\n            indent++;\n        }\n        else if (chCode === 9 /* CharCode.Tab */) {\n            indent = indent - indent % tabSize + tabSize;\n        }\n        else {\n            break;\n        }\n        i++;\n    }\n    if (i === len) {\n        return -1; // line only consists of whitespace\n    }\n    return indent;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport { splitLines } from '../../../../../base/common/strings.js';\nimport { Range } from '../../../core/range.js';\nimport { TextLength } from '../../../core/textLength.js';\n/**\n * The end must be greater than or equal to the start.\n*/\nexport function lengthDiff(startLineCount, startColumnCount, endLineCount, endColumnCount) {\n    return (startLineCount !== endLineCount)\n        ? toLength(endLineCount - startLineCount, endColumnCount)\n        : toLength(0, endColumnCount - startColumnCount);\n}\nexport const lengthZero = 0;\nexport function lengthIsZero(length) {\n    return length === 0;\n}\n/*\n * We have 52 bits available in a JS number.\n * We use the upper 26 bits to store the line and the lower 26 bits to store the column.\n */\n///*\nconst factor = 2 ** 26;\n/*/\nconst factor = 1000000;\n// */\nexport function toLength(lineCount, columnCount) {\n    // llllllllllllllllllllllllllcccccccccccccccccccccccccc (52 bits)\n    //       line count (26 bits)    column count (26 bits)\n    // If there is no overflow (all values/sums below 2^26 = 67108864),\n    // we have `toLength(lns1, cols1) + toLength(lns2, cols2) = toLength(lns1 + lns2, cols1 + cols2)`.\n    return (lineCount * factor + columnCount);\n}\nexport function lengthToObj(length) {\n    const l = length;\n    const lineCount = Math.floor(l / factor);\n    const columnCount = l - lineCount * factor;\n    return new TextLength(lineCount, columnCount);\n}\nexport function lengthGetLineCount(length) {\n    return Math.floor(length / factor);\n}\n/**\n * Returns the amount of columns of the given length, assuming that it does not span any line.\n*/\nexport function lengthGetColumnCountIfZeroLineCount(length) {\n    return length;\n}\nexport function lengthAdd(l1, l2) {\n    let r = l1 + l2;\n    if (l2 >= factor) {\n        r = r - (l1 % factor);\n    }\n    return r;\n}\nexport function sumLengths(items, lengthFn) {\n    return items.reduce((a, b) => lengthAdd(a, lengthFn(b)), lengthZero);\n}\nexport function lengthEquals(length1, length2) {\n    return length1 === length2;\n}\n/**\n * Returns a non negative length `result` such that `lengthAdd(length1, result) = length2`, or zero if such length does not exist.\n */\nexport function lengthDiffNonNegative(length1, length2) {\n    const l1 = length1;\n    const l2 = length2;\n    const diff = l2 - l1;\n    if (diff <= 0) {\n        // line-count of length1 is higher than line-count of length2\n        // or they are equal and column-count of length1 is higher than column-count of length2\n        return lengthZero;\n    }\n    const lineCount1 = Math.floor(l1 / factor);\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    if (lineCount1 === lineCount2) {\n        const colCount1 = l1 - lineCount1 * factor;\n        return toLength(0, colCount2 - colCount1);\n    }\n    else {\n        return toLength(lineCount2 - lineCount1, colCount2);\n    }\n}\nexport function lengthLessThan(length1, length2) {\n    // First, compare line counts, then column counts.\n    return length1 < length2;\n}\nexport function lengthLessThanEqual(length1, length2) {\n    return length1 <= length2;\n}\nexport function lengthGreaterThanEqual(length1, length2) {\n    return length1 >= length2;\n}\nexport function positionToLength(position) {\n    return toLength(position.lineNumber - 1, position.column - 1);\n}\nexport function lengthsToRange(lengthStart, lengthEnd) {\n    const l = lengthStart;\n    const lineCount = Math.floor(l / factor);\n    const colCount = l - lineCount * factor;\n    const l2 = lengthEnd;\n    const lineCount2 = Math.floor(l2 / factor);\n    const colCount2 = l2 - lineCount2 * factor;\n    return new Range(lineCount + 1, colCount + 1, lineCount2 + 1, colCount2 + 1);\n}\nexport function lengthOfString(str) {\n    const lines = splitLines(str);\n    return toLength(lines.length - 1, lines[lines.length - 1].length);\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __param = (this && this.__param) || function (paramIndex, decorator) {\n    return function (target, key) { decorator(target, key, paramIndex); }\n};\nvar ModelService_1;\nimport { Emitter } from '../../../base/common/event.js';\nimport { Disposable, DisposableStore } from '../../../base/common/lifecycle.js';\nimport * as platform from '../../../base/common/platform.js';\nimport { TextModel } from '../model/textModel.js';\nimport { EDITOR_MODEL_DEFAULTS } from '../core/textModelDefaults.js';\nimport { PLAINTEXT_LANGUAGE_ID } from '../languages/modesRegistry.js';\nimport { ITextResourcePropertiesService } from './textResourceConfiguration.js';\nimport { IConfigurationService } from '../../../platform/configuration/common/configuration.js';\nimport { IUndoRedoService } from '../../../platform/undoRedo/common/undoRedo.js';\nimport { StringSHA1 } from '../../../base/common/hash.js';\nimport { isEditStackElement } from '../model/editStack.js';\nimport { Schemas } from '../../../base/common/network.js';\nimport { equals } from '../../../base/common/objects.js';\nimport { IInstantiationService } from '../../../platform/instantiation/common/instantiation.js';\nfunction MODEL_ID(resource) {\n    return resource.toString();\n}\nclass ModelData {\n    constructor(model, onWillDispose, onDidChangeLanguage) {\n        this.model = model;\n        this._modelEventListeners = new DisposableStore();\n        this.model = model;\n        this._modelEventListeners.add(model.onWillDispose(() => onWillDispose(model)));\n        this._modelEventListeners.add(model.onDidChangeLanguage((e) => onDidChangeLanguage(model, e)));\n    }\n    dispose() {\n        this._modelEventListeners.dispose();\n    }\n}\nconst DEFAULT_EOL = (platform.isLinux || platform.isMacintosh) ? 1 /* DefaultEndOfLine.LF */ : 2 /* DefaultEndOfLine.CRLF */;\nclass DisposedModelInfo {\n    constructor(uri, initialUndoRedoSnapshot, time, sharesUndoRedoStack, heapSize, sha1, versionId, alternativeVersionId) {\n        this.uri = uri;\n        this.initialUndoRedoSnapshot = initialUndoRedoSnapshot;\n        this.time = time;\n        this.sharesUndoRedoStack = sharesUndoRedoStack;\n        this.heapSize = heapSize;\n        this.sha1 = sha1;\n        this.versionId = versionId;\n        this.alternativeVersionId = alternativeVersionId;\n    }\n}\nlet ModelService = class ModelService extends Disposable {\n    static { ModelService_1 = this; }\n    static { this.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK = 20 * 1024 * 1024; }\n    constructor(_configurationService, _resourcePropertiesService, _undoRedoService, _instantiationService) {\n        super();\n        this._configurationService = _configurationService;\n        this._resourcePropertiesService = _resourcePropertiesService;\n        this._undoRedoService = _undoRedoService;\n        this._instantiationService = _instantiationService;\n        this._onModelAdded = this._register(new Emitter());\n        this.onModelAdded = this._onModelAdded.event;\n        this._onModelRemoved = this._register(new Emitter());\n        this.onModelRemoved = this._onModelRemoved.event;\n        this._onModelModeChanged = this._register(new Emitter());\n        this.onModelLanguageChanged = this._onModelModeChanged.event;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        this._models = {};\n        this._disposedModels = new Map();\n        this._disposedModelsHeapSize = 0;\n        this._register(this._configurationService.onDidChangeConfiguration(e => this._updateModelOptions(e)));\n        this._updateModelOptions(undefined);\n    }\n    static _readModelOptions(config, isForSimpleWidget) {\n        let tabSize = EDITOR_MODEL_DEFAULTS.tabSize;\n        if (config.editor && typeof config.editor.tabSize !== 'undefined') {\n            const parsedTabSize = parseInt(config.editor.tabSize, 10);\n            if (!isNaN(parsedTabSize)) {\n                tabSize = parsedTabSize;\n            }\n            if (tabSize < 1) {\n                tabSize = 1;\n            }\n        }\n        let indentSize = 'tabSize';\n        if (config.editor && typeof config.editor.indentSize !== 'undefined' && config.editor.indentSize !== 'tabSize') {\n            const parsedIndentSize = parseInt(config.editor.indentSize, 10);\n            if (!isNaN(parsedIndentSize)) {\n                indentSize = Math.max(parsedIndentSize, 1);\n            }\n        }\n        let insertSpaces = EDITOR_MODEL_DEFAULTS.insertSpaces;\n        if (config.editor && typeof config.editor.insertSpaces !== 'undefined') {\n            insertSpaces = (config.editor.insertSpaces === 'false' ? false : Boolean(config.editor.insertSpaces));\n        }\n        let newDefaultEOL = DEFAULT_EOL;\n        const eol = config.eol;\n        if (eol === '\\r\\n') {\n            newDefaultEOL = 2 /* DefaultEndOfLine.CRLF */;\n        }\n        else if (eol === '\\n') {\n            newDefaultEOL = 1 /* DefaultEndOfLine.LF */;\n        }\n        let trimAutoWhitespace = EDITOR_MODEL_DEFAULTS.trimAutoWhitespace;\n        if (config.editor && typeof config.editor.trimAutoWhitespace !== 'undefined') {\n            trimAutoWhitespace = (config.editor.trimAutoWhitespace === 'false' ? false : Boolean(config.editor.trimAutoWhitespace));\n        }\n        let detectIndentation = EDITOR_MODEL_DEFAULTS.detectIndentation;\n        if (config.editor && typeof config.editor.detectIndentation !== 'undefined') {\n            detectIndentation = (config.editor.detectIndentation === 'false' ? false : Boolean(config.editor.detectIndentation));\n        }\n        let largeFileOptimizations = EDITOR_MODEL_DEFAULTS.largeFileOptimizations;\n        if (config.editor && typeof config.editor.largeFileOptimizations !== 'undefined') {\n            largeFileOptimizations = (config.editor.largeFileOptimizations === 'false' ? false : Boolean(config.editor.largeFileOptimizations));\n        }\n        let bracketPairColorizationOptions = EDITOR_MODEL_DEFAULTS.bracketPairColorizationOptions;\n        if (config.editor?.bracketPairColorization && typeof config.editor.bracketPairColorization === 'object') {\n            bracketPairColorizationOptions = {\n                enabled: !!config.editor.bracketPairColorization.enabled,\n                independentColorPoolPerBracketType: !!config.editor.bracketPairColorization.independentColorPoolPerBracketType\n            };\n        }\n        return {\n            isForSimpleWidget: isForSimpleWidget,\n            tabSize: tabSize,\n            indentSize: indentSize,\n            insertSpaces: insertSpaces,\n            detectIndentation: detectIndentation,\n            defaultEOL: newDefaultEOL,\n            trimAutoWhitespace: trimAutoWhitespace,\n            largeFileOptimizations: largeFileOptimizations,\n            bracketPairColorizationOptions\n        };\n    }\n    _getEOL(resource, language) {\n        if (resource) {\n            return this._resourcePropertiesService.getEOL(resource, language);\n        }\n        const eol = this._configurationService.getValue('files.eol', { overrideIdentifier: language });\n        if (eol && typeof eol === 'string' && eol !== 'auto') {\n            return eol;\n        }\n        return platform.OS === 3 /* platform.OperatingSystem.Linux */ || platform.OS === 2 /* platform.OperatingSystem.Macintosh */ ? '\\n' : '\\r\\n';\n    }\n    _shouldRestoreUndoStack() {\n        const result = this._configurationService.getValue('files.restoreUndoStack');\n        if (typeof result === 'boolean') {\n            return result;\n        }\n        return true;\n    }\n    getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget) {\n        const language = (typeof languageIdOrSelection === 'string' ? languageIdOrSelection : languageIdOrSelection.languageId);\n        let creationOptions = this._modelCreationOptionsByLanguageAndResource[language + resource];\n        if (!creationOptions) {\n            const editor = this._configurationService.getValue('editor', { overrideIdentifier: language, resource });\n            const eol = this._getEOL(resource, language);\n            creationOptions = ModelService_1._readModelOptions({ editor, eol }, isForSimpleWidget);\n            this._modelCreationOptionsByLanguageAndResource[language + resource] = creationOptions;\n        }\n        return creationOptions;\n    }\n    _updateModelOptions(e) {\n        const oldOptionsByLanguageAndResource = this._modelCreationOptionsByLanguageAndResource;\n        this._modelCreationOptionsByLanguageAndResource = Object.create(null);\n        // Update options on all models\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            const modelData = this._models[modelId];\n            const language = modelData.model.getLanguageId();\n            const uri = modelData.model.uri;\n            if (e && !e.affectsConfiguration('editor', { overrideIdentifier: language, resource: uri }) && !e.affectsConfiguration('files.eol', { overrideIdentifier: language, resource: uri })) {\n                continue; // perf: skip if this model is not affected by configuration change\n            }\n            const oldOptions = oldOptionsByLanguageAndResource[language + uri];\n            const newOptions = this.getCreationOptions(language, uri, modelData.model.isForSimpleWidget);\n            ModelService_1._setModelOptionsForModel(modelData.model, newOptions, oldOptions);\n        }\n    }\n    static _setModelOptionsForModel(model, newOptions, currentOptions) {\n        if (currentOptions && currentOptions.defaultEOL !== newOptions.defaultEOL && model.getLineCount() === 1) {\n            model.setEOL(newOptions.defaultEOL === 1 /* DefaultEndOfLine.LF */ ? 0 /* EndOfLineSequence.LF */ : 1 /* EndOfLineSequence.CRLF */);\n        }\n        if (currentOptions\n            && (currentOptions.detectIndentation === newOptions.detectIndentation)\n            && (currentOptions.insertSpaces === newOptions.insertSpaces)\n            && (currentOptions.tabSize === newOptions.tabSize)\n            && (currentOptions.indentSize === newOptions.indentSize)\n            && (currentOptions.trimAutoWhitespace === newOptions.trimAutoWhitespace)\n            && equals(currentOptions.bracketPairColorizationOptions, newOptions.bracketPairColorizationOptions)) {\n            // Same indent opts, no need to touch the model\n            return;\n        }\n        if (newOptions.detectIndentation) {\n            model.detectIndentation(newOptions.insertSpaces, newOptions.tabSize);\n            model.updateOptions({\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n        else {\n            model.updateOptions({\n                insertSpaces: newOptions.insertSpaces,\n                tabSize: newOptions.tabSize,\n                indentSize: newOptions.indentSize,\n                trimAutoWhitespace: newOptions.trimAutoWhitespace,\n                bracketColorizationOptions: newOptions.bracketPairColorizationOptions\n            });\n        }\n    }\n    // --- begin IModelService\n    _insertDisposedModel(disposedModelData) {\n        this._disposedModels.set(MODEL_ID(disposedModelData.uri), disposedModelData);\n        this._disposedModelsHeapSize += disposedModelData.heapSize;\n    }\n    _removeDisposedModel(resource) {\n        const disposedModelData = this._disposedModels.get(MODEL_ID(resource));\n        if (disposedModelData) {\n            this._disposedModelsHeapSize -= disposedModelData.heapSize;\n        }\n        this._disposedModels.delete(MODEL_ID(resource));\n        return disposedModelData;\n    }\n    _ensureDisposedModelsHeapSize(maxModelsHeapSize) {\n        if (this._disposedModelsHeapSize > maxModelsHeapSize) {\n            // we must remove some old undo stack elements to free up some memory\n            const disposedModels = [];\n            this._disposedModels.forEach(entry => {\n                if (!entry.sharesUndoRedoStack) {\n                    disposedModels.push(entry);\n                }\n            });\n            disposedModels.sort((a, b) => a.time - b.time);\n            while (disposedModels.length > 0 && this._disposedModelsHeapSize > maxModelsHeapSize) {\n                const disposedModel = disposedModels.shift();\n                this._removeDisposedModel(disposedModel.uri);\n                if (disposedModel.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModel.initialUndoRedoSnapshot);\n                }\n            }\n        }\n    }\n    _createModelData(value, languageIdOrSelection, resource, isForSimpleWidget) {\n        // create & save the model\n        const options = this.getCreationOptions(languageIdOrSelection, resource, isForSimpleWidget);\n        const model = this._instantiationService.createInstance(TextModel, value, languageIdOrSelection, options, resource);\n        if (resource && this._disposedModels.has(MODEL_ID(resource))) {\n            const disposedModelData = this._removeDisposedModel(resource);\n            const elements = this._undoRedoService.getElements(resource);\n            const sha1Computer = this._getSHA1Computer();\n            const sha1IsEqual = (sha1Computer.canComputeSHA1(model)\n                ? sha1Computer.computeSHA1(model) === disposedModelData.sha1\n                : false);\n            if (sha1IsEqual || disposedModelData.sharesUndoRedoStack) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(resource)) {\n                        element.setModel(model);\n                    }\n                }\n                this._undoRedoService.setElementsValidFlag(resource, true, (element) => (isEditStackElement(element) && element.matchesResource(resource)));\n                if (sha1IsEqual) {\n                    model._overwriteVersionId(disposedModelData.versionId);\n                    model._overwriteAlternativeVersionId(disposedModelData.alternativeVersionId);\n                    model._overwriteInitialUndoRedoSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n            else {\n                if (disposedModelData.initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(disposedModelData.initialUndoRedoSnapshot);\n                }\n            }\n        }\n        const modelId = MODEL_ID(model.uri);\n        if (this._models[modelId]) {\n            // There already exists a model with this id => this is a programmer error\n            throw new Error('ModelService: Cannot add model because it already exists!');\n        }\n        const modelData = new ModelData(model, (model) => this._onWillDispose(model), (model, e) => this._onDidChangeLanguage(model, e));\n        this._models[modelId] = modelData;\n        return modelData;\n    }\n    createModel(value, languageSelection, resource, isForSimpleWidget = false) {\n        let modelData;\n        if (languageSelection) {\n            modelData = this._createModelData(value, languageSelection, resource, isForSimpleWidget);\n        }\n        else {\n            modelData = this._createModelData(value, PLAINTEXT_LANGUAGE_ID, resource, isForSimpleWidget);\n        }\n        this._onModelAdded.fire(modelData.model);\n        return modelData.model;\n    }\n    getModels() {\n        const ret = [];\n        const keys = Object.keys(this._models);\n        for (let i = 0, len = keys.length; i < len; i++) {\n            const modelId = keys[i];\n            ret.push(this._models[modelId].model);\n        }\n        return ret;\n    }\n    getModel(resource) {\n        const modelId = MODEL_ID(resource);\n        const modelData = this._models[modelId];\n        if (!modelData) {\n            return null;\n        }\n        return modelData.model;\n    }\n    // --- end IModelService\n    _schemaShouldMaintainUndoRedoElements(resource) {\n        return (resource.scheme === Schemas.file\n            || resource.scheme === Schemas.vscodeRemote\n            || resource.scheme === Schemas.vscodeUserData\n            || resource.scheme === Schemas.vscodeNotebookCell\n            || resource.scheme === 'fake-fs' // for tests\n        );\n    }\n    _onWillDispose(model) {\n        const modelId = MODEL_ID(model.uri);\n        const modelData = this._models[modelId];\n        const sharesUndoRedoStack = (this._undoRedoService.getUriComparisonKey(model.uri) !== model.uri.toString());\n        let maintainUndoRedoStack = false;\n        let heapSize = 0;\n        if (sharesUndoRedoStack || (this._shouldRestoreUndoStack() && this._schemaShouldMaintainUndoRedoElements(model.uri))) {\n            const elements = this._undoRedoService.getElements(model.uri);\n            if (elements.past.length > 0 || elements.future.length > 0) {\n                for (const element of elements.past) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n                for (const element of elements.future) {\n                    if (isEditStackElement(element) && element.matchesResource(model.uri)) {\n                        maintainUndoRedoStack = true;\n                        heapSize += element.heapSize(model.uri);\n                        element.setModel(model.uri); // remove reference from text buffer instance\n                    }\n                }\n            }\n        }\n        const maxMemory = ModelService_1.MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK;\n        const sha1Computer = this._getSHA1Computer();\n        if (!maintainUndoRedoStack) {\n            if (!sharesUndoRedoStack) {\n                const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n                if (initialUndoRedoSnapshot !== null) {\n                    this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n                }\n            }\n        }\n        else if (!sharesUndoRedoStack && (heapSize > maxMemory || !sha1Computer.canComputeSHA1(model))) {\n            // the undo stack for this file would never fit in the configured memory or the file is very large, so don't bother with it.\n            const initialUndoRedoSnapshot = modelData.model.getInitialUndoRedoSnapshot();\n            if (initialUndoRedoSnapshot !== null) {\n                this._undoRedoService.restoreSnapshot(initialUndoRedoSnapshot);\n            }\n        }\n        else {\n            this._ensureDisposedModelsHeapSize(maxMemory - heapSize);\n            // We only invalidate the elements, but they remain in the undo-redo service.\n            this._undoRedoService.setElementsValidFlag(model.uri, false, (element) => (isEditStackElement(element) && element.matchesResource(model.uri)));\n            this._insertDisposedModel(new DisposedModelInfo(model.uri, modelData.model.getInitialUndoRedoSnapshot(), Date.now(), sharesUndoRedoStack, heapSize, sha1Computer.computeSHA1(model), model.getVersionId(), model.getAlternativeVersionId()));\n        }\n        delete this._models[modelId];\n        modelData.dispose();\n        // clean up cache\n        delete this._modelCreationOptionsByLanguageAndResource[model.getLanguageId() + model.uri];\n        this._onModelRemoved.fire(model);\n    }\n    _onDidChangeLanguage(model, e) {\n        const oldLanguageId = e.oldLanguage;\n        const newLanguageId = model.getLanguageId();\n        const oldOptions = this.getCreationOptions(oldLanguageId, model.uri, model.isForSimpleWidget);\n        const newOptions = this.getCreationOptions(newLanguageId, model.uri, model.isForSimpleWidget);\n        ModelService_1._setModelOptionsForModel(model, newOptions, oldOptions);\n        this._onModelModeChanged.fire({ model, oldLanguageId: oldLanguageId });\n    }\n    _getSHA1Computer() {\n        return new DefaultModelSHA1Computer();\n    }\n};\nModelService = ModelService_1 = __decorate([\n    __param(0, IConfigurationService),\n    __param(1, ITextResourcePropertiesService),\n    __param(2, IUndoRedoService),\n    __param(3, IInstantiationService)\n], ModelService);\nexport { ModelService };\nexport class DefaultModelSHA1Computer {\n    static { this.MAX_MODEL_SIZE = 10 * 1024 * 1024; } // takes 200ms to compute a sha1 on a 10MB model on a new machine\n    canComputeSHA1(model) {\n        return (model.getValueLength() <= DefaultModelSHA1Computer.MAX_MODEL_SIZE);\n    }\n    computeSHA1(model) {\n        // compute the sha1\n        const shaComputer = new StringSHA1();\n        const snapshot = model.createSnapshot();\n        let text;\n        while ((text = snapshot.read())) {\n            shaComputer.update(text);\n        }\n        return shaComputer.digest();\n    }\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as strings from '../../../base/common/strings.js';\nimport { CursorColumns } from './cursorColumns.js';\nfunction _normalizeIndentationFromWhitespace(str, indentSize, insertSpaces) {\n    let spacesCnt = 0;\n    for (let i = 0; i < str.length; i++) {\n        if (str.charAt(i) === '\\t') {\n            spacesCnt = CursorColumns.nextIndentTabStop(spacesCnt, indentSize);\n        }\n        else {\n            spacesCnt++;\n        }\n    }\n    let result = '';\n    if (!insertSpaces) {\n        const tabsCnt = Math.floor(spacesCnt / indentSize);\n        spacesCnt = spacesCnt % indentSize;\n        for (let i = 0; i < tabsCnt; i++) {\n            result += '\\t';\n        }\n    }\n    for (let i = 0; i < spacesCnt; i++) {\n        result += ' ';\n    }\n    return result;\n}\nexport function normalizeIndentation(str, indentSize, insertSpaces) {\n    let firstNonWhitespaceIndex = strings.firstNonWhitespaceIndex(str);\n    if (firstNonWhitespaceIndex === -1) {\n        firstNonWhitespaceIndex = str.length;\n    }\n    return _normalizeIndentationFromWhitespace(str.substring(0, firstNonWhitespaceIndex), indentSize, insertSpaces) + str.substring(firstNonWhitespaceIndex);\n}\n","import { createDecorator } from '../../../platform/instantiation/common/instantiation.js';\nexport const ITextResourceConfigurationService = createDecorator('textResourceConfigurationService');\nexport const ITextResourcePropertiesService = createDecorator('textResourcePropertiesService');\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nexport function createScopedLineTokens(context, offset) {\n    const tokenCount = context.getCount();\n    const tokenIndex = context.findTokenIndexAtOffset(offset);\n    const desiredLanguageId = context.getLanguageId(tokenIndex);\n    let lastTokenIndex = tokenIndex;\n    while (lastTokenIndex + 1 < tokenCount && context.getLanguageId(lastTokenIndex + 1) === desiredLanguageId) {\n        lastTokenIndex++;\n    }\n    let firstTokenIndex = tokenIndex;\n    while (firstTokenIndex > 0 && context.getLanguageId(firstTokenIndex - 1) === desiredLanguageId) {\n        firstTokenIndex--;\n    }\n    return new ScopedLineTokens(context, desiredLanguageId, firstTokenIndex, lastTokenIndex + 1, context.getStartOffset(firstTokenIndex), context.getEndOffset(lastTokenIndex));\n}\nexport class ScopedLineTokens {\n    constructor(actual, languageId, firstTokenIndex, lastTokenIndex, firstCharOffset, lastCharOffset) {\n        this._scopedLineTokensBrand = undefined;\n        this._actual = actual;\n        this.languageId = languageId;\n        this._firstTokenIndex = firstTokenIndex;\n        this._lastTokenIndex = lastTokenIndex;\n        this.firstCharOffset = firstCharOffset;\n        this._lastCharOffset = lastCharOffset;\n        this.languageIdCodec = actual.languageIdCodec;\n    }\n    getLineContent() {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(this.firstCharOffset, this._lastCharOffset);\n    }\n    getLineLength() {\n        return this._lastCharOffset - this.firstCharOffset;\n    }\n    getActualLineContentBefore(offset) {\n        const actualLineContent = this._actual.getLineContent();\n        return actualLineContent.substring(0, this.firstCharOffset + offset);\n    }\n    getTokenCount() {\n        return this._lastTokenIndex - this._firstTokenIndex;\n    }\n    findTokenIndexAtOffset(offset) {\n        return this._actual.findTokenIndexAtOffset(offset + this.firstCharOffset) - this._firstTokenIndex;\n    }\n    getStandardTokenType(tokenIndex) {\n        return this._actual.getStandardTokenType(tokenIndex + this._firstTokenIndex);\n    }\n    toIViewLineTokens() {\n        return this._actual.sliceAndInflate(this.firstCharOffset, this._lastCharOffset, 0);\n    }\n}\nexport function ignoreBracketsInToken(standardTokenType) {\n    return (standardTokenType & 3 /* IgnoreBracketsInTokens.value */) !== 0;\n}\n","/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\nimport * as nls from '../../../nls.js';\nimport { onUnexpectedError } from '../../../base/common/errors.js';\nimport { Selection } from '../core/selection.js';\nimport { URI } from '../../../base/common/uri.js';\nimport { TextChange, compressConsecutiveTextChanges } from '../core/textChange.js';\nimport * as buffer from '../../../base/common/buffer.js';\nimport { basename } from '../../../base/common/resources.js';\nfunction uriGetComparisonKey(resource) {\n    return resource.toString();\n}\nexport class SingleModelEditStackData {\n    static create(model, beforeCursorState) {\n        const alternativeVersionId = model.getAlternativeVersionId();\n        const eol = getModelEOL(model);\n        return new SingleModelEditStackData(alternativeVersionId, alternativeVersionId, eol, eol, beforeCursorState, beforeCursorState, []);\n    }\n    constructor(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes) {\n        this.beforeVersionId = beforeVersionId;\n        this.afterVersionId = afterVersionId;\n        this.beforeEOL = beforeEOL;\n        this.afterEOL = afterEOL;\n        this.beforeCursorState = beforeCursorState;\n        this.afterCursorState = afterCursorState;\n        this.changes = changes;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (textChanges.length > 0) {\n            this.changes = compressConsecutiveTextChanges(this.changes, textChanges);\n        }\n        this.afterEOL = afterEOL;\n        this.afterVersionId = afterVersionId;\n        this.afterCursorState = afterCursorState;\n    }\n    static _writeSelectionsSize(selections) {\n        return 4 + 4 * 4 * (selections ? selections.length : 0);\n    }\n    static _writeSelections(b, selections, offset) {\n        buffer.writeUInt32BE(b, (selections ? selections.length : 0), offset);\n        offset += 4;\n        if (selections) {\n            for (const selection of selections) {\n                buffer.writeUInt32BE(b, selection.selectionStartLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.selectionStartColumn, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionLineNumber, offset);\n                offset += 4;\n                buffer.writeUInt32BE(b, selection.positionColumn, offset);\n                offset += 4;\n            }\n        }\n        return offset;\n    }\n    static _readSelections(b, offset, dest) {\n        const count = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        for (let i = 0; i < count; i++) {\n            const selectionStartLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const selectionStartColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionLineNumber = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            const positionColumn = buffer.readUInt32BE(b, offset);\n            offset += 4;\n            dest.push(new Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn));\n        }\n        return offset;\n    }\n    serialize() {\n        let necessarySize = (+4 // beforeVersionId\n            + 4 // afterVersionId\n            + 1 // beforeEOL\n            + 1 // afterEOL\n            + SingleModelEditStackData._writeSelectionsSize(this.beforeCursorState)\n            + SingleModelEditStackData._writeSelectionsSize(this.afterCursorState)\n            + 4 // change count\n        );\n        for (const change of this.changes) {\n            necessarySize += change.writeSize();\n        }\n        const b = new Uint8Array(necessarySize);\n        let offset = 0;\n        buffer.writeUInt32BE(b, this.beforeVersionId, offset);\n        offset += 4;\n        buffer.writeUInt32BE(b, this.afterVersionId, offset);\n        offset += 4;\n        buffer.writeUInt8(b, this.beforeEOL, offset);\n        offset += 1;\n        buffer.writeUInt8(b, this.afterEOL, offset);\n        offset += 1;\n        offset = SingleModelEditStackData._writeSelections(b, this.beforeCursorState, offset);\n        offset = SingleModelEditStackData._writeSelections(b, this.afterCursorState, offset);\n        buffer.writeUInt32BE(b, this.changes.length, offset);\n        offset += 4;\n        for (const change of this.changes) {\n            offset = change.write(b, offset);\n        }\n        return b.buffer;\n    }\n    static deserialize(source) {\n        const b = new Uint8Array(source);\n        let offset = 0;\n        const beforeVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const afterVersionId = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const beforeEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const afterEOL = buffer.readUInt8(b, offset);\n        offset += 1;\n        const beforeCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, beforeCursorState);\n        const afterCursorState = [];\n        offset = SingleModelEditStackData._readSelections(b, offset, afterCursorState);\n        const changeCount = buffer.readUInt32BE(b, offset);\n        offset += 4;\n        const changes = [];\n        for (let i = 0; i < changeCount; i++) {\n            offset = TextChange.read(b, offset, changes);\n        }\n        return new SingleModelEditStackData(beforeVersionId, afterVersionId, beforeEOL, afterEOL, beforeCursorState, afterCursorState, changes);\n    }\n}\nexport class SingleModelEditStackElement {\n    get type() {\n        return 0 /* UndoRedoElementType.Resource */;\n    }\n    get resource() {\n        if (URI.isUri(this.model)) {\n            return this.model;\n        }\n        return this.model.uri;\n    }\n    constructor(label, code, model, beforeCursorState) {\n        this.label = label;\n        this.code = code;\n        this.model = model;\n        this._data = SingleModelEditStackData.create(model, beforeCursorState);\n    }\n    toString() {\n        const data = (this._data instanceof SingleModelEditStackData ? this._data : SingleModelEditStackData.deserialize(this._data));\n        return data.changes.map(change => change.toString()).join(', ');\n    }\n    matchesResource(resource) {\n        const uri = (URI.isUri(this.model) ? this.model : this.model.uri);\n        return (uri.toString() === resource.toString());\n    }\n    setModel(model) {\n        this.model = model;\n    }\n    canAppend(model) {\n        return (this.model === model && this._data instanceof SingleModelEditStackData);\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n        }\n    }\n    close() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n    }\n    open() {\n        if (!(this._data instanceof SingleModelEditStackData)) {\n            this._data = SingleModelEditStackData.deserialize(this._data);\n        }\n    }\n    undo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyUndo(data.changes, data.beforeEOL, data.beforeVersionId, data.beforeCursorState);\n    }\n    redo() {\n        if (URI.isUri(this.model)) {\n            // don't have a model\n            throw new Error(`Invalid SingleModelEditStackElement`);\n        }\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        const data = SingleModelEditStackData.deserialize(this._data);\n        this.model._applyRedo(data.changes, data.afterEOL, data.afterVersionId, data.afterCursorState);\n    }\n    heapSize() {\n        if (this._data instanceof SingleModelEditStackData) {\n            this._data = this._data.serialize();\n        }\n        return this._data.byteLength + 168 /*heap overhead*/;\n    }\n}\nexport class MultiModelEditStackElement {\n    get resources() {\n        return this._editStackElementsArr.map(editStackElement => editStackElement.resource);\n    }\n    constructor(label, code, editStackElements) {\n        this.label = label;\n        this.code = code;\n        this.type = 1 /* UndoRedoElementType.Workspace */;\n        this._isOpen = true;\n        this._editStackElementsArr = editStackElements.slice(0);\n        this._editStackElementsMap = new Map();\n        for (const editStackElement of this._editStackElementsArr) {\n            const key = uriGetComparisonKey(editStackElement.resource);\n            this._editStackElementsMap.set(key, editStackElement);\n        }\n        this._delegate = null;\n    }\n    prepareUndoRedo() {\n        if (this._delegate) {\n            return this._delegate.prepareUndoRedo(this);\n        }\n    }\n    matchesResource(resource) {\n        const key = uriGetComparisonKey(resource);\n        return (this._editStackElementsMap.has(key));\n    }\n    setModel(model) {\n        const key = uriGetComparisonKey(URI.isUri(model) ? model : model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            this._editStackElementsMap.get(key).setModel(model);\n        }\n    }\n    canAppend(model) {\n        if (!this._isOpen) {\n            return false;\n        }\n        const key = uriGetComparisonKey(model.uri);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.canAppend(model);\n        }\n        return false;\n    }\n    append(model, textChanges, afterEOL, afterVersionId, afterCursorState) {\n        const key = uriGetComparisonKey(model.uri);\n        const editStackElement = this._editStackElementsMap.get(key);\n        editStackElement.append(model, textChanges, afterEOL, afterVersionId, afterCursorState);\n    }\n    close() {\n        this._isOpen = false;\n    }\n    open() {\n        // cannot reopen\n    }\n    undo() {\n        this._isOpen = false;\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.undo();\n        }\n    }\n    redo() {\n        for (const editStackElement of this._editStackElementsArr) {\n            editStackElement.redo();\n        }\n    }\n    heapSize(resource) {\n        const key = uriGetComparisonKey(resource);\n        if (this._editStackElementsMap.has(key)) {\n            const editStackElement = this._editStackElementsMap.get(key);\n            return editStackElement.heapSize();\n        }\n        return 0;\n    }\n    split() {\n        return this._editStackElementsArr;\n    }\n    toString() {\n        const result = [];\n        for (const editStackElement of this._editStackElementsArr) {\n            result.push(`${basename(editStackElement.resource)}: ${editStackElement}`);\n        }\n        return `{${result.join(', ')}}`;\n    }\n}\nfunction getModelEOL(model) {\n    const eol = model.getEOL();\n    if (eol === '\\n') {\n        return 0 /* EndOfLineSequence.LF */;\n    }\n    else {\n        return 1 /* EndOfLineSequence.CRLF */;\n    }\n}\nexport function isEditStackElement(element) {\n    if (!element) {\n        return false;\n    }\n    return ((element instanceof SingleModelEditStackElement) || (element instanceof MultiModelEditStackElement));\n}\nexport class EditStack {\n    constructor(model, undoRedoService) {\n        this._model = model;\n        this._undoRedoService = undoRedoService;\n    }\n    pushStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.close();\n        }\n    }\n    popStackElement() {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement)) {\n            lastElement.open();\n        }\n    }\n    clear() {\n        this._undoRedoService.removeElements(this._model.uri);\n    }\n    _getOrCreateEditStackElement(beforeCursorState, group) {\n        const lastElement = this._undoRedoService.getLastElement(this._model.uri);\n        if (isEditStackElement(lastElement) && lastElement.canAppend(this._model)) {\n            return lastElement;\n        }\n        const newElement = new SingleModelEditStackElement(nls.localize('edit', \"Typing\"), 'undoredo.textBufferEdit', this._model, beforeCursorState);\n        this._undoRedoService.pushElement(newElement, group);\n        return newElement;\n    }\n    pushEOL(eol) {\n        const editStackElement = this._getOrCreateEditStackElement(null, undefined);\n        this._model.setEOL(eol);\n        editStackElement.append(this._model, [], getModelEOL(this._model), this._model.getAlternativeVersionId(), null);\n    }\n    pushEditOperation(beforeCursorState, editOperations, cursorStateComputer, group) {\n        const editStackElement = this._getOrCreateEditStackElement(beforeCursorState, group);\n        const inverseEditOperations = this._model.applyEdits(editOperations, true);\n        const afterCursorState = EditStack._computeCursorState(cursorStateComputer, inverseEditOperations);\n        const textChanges = inverseEditOperations.map((op, index) => ({ index: index, textChange: op.textChange }));\n        textChanges.sort((a, b) => {\n            if (a.textChange.oldPosition === b.textChange.oldPosition) {\n                return a.index - b.index;\n            }\n            return a.textChange.oldPosition - b.textChange.oldPosition;\n        });\n        editStackElement.append(this._model, textChanges.map(op => op.textChange), getModelEOL(this._model), this._model.getAlternativeVersionId(), afterCursorState);\n        return afterCursorState;\n    }\n    static _computeCursorState(cursorStateComputer, inverseEditOperations) {\n        try {\n            return cursorStateComputer ? cursorStateComputer(inverseEditOperations) : null;\n        }\n        catch (e) {\n            onUnexpectedError(e);\n            return null;\n        }\n    }\n}\n"],"names":["emptyArr","SmallImmutableSet","this","cache","Array","create","items","additionalItems","length","cached","empty","getEmpty","constructor","add","value","keyProvider","key","getKey","idx","newItem","newItems","slice","push","merge","other","merged","i","Math","max","item1","item2","intersects","min","identityKeyProvider","DenseKeyProvider","Map","existing","get","undefined","size","set","ModelRawFlush","changeType","LineInjectedText","applyInjectedText","lineText","injectedTexts","result","lastOriginalOffset","injectedText","substring","column","options","content","fromDecorations","decorations","decoration","before","ownerId","range","startLineNumber","startColumn","after","endLineNumber","endColumn","sort","a","b","lineNumber","order","ModelRawLineChanged","detail","ModelRawLinesDeleted","fromLineNumber","toLineNumber","ModelRawLinesInserted","ModelRawEOLChanged","ModelRawContentChangedEvent","changes","versionId","isUndoing","isRedoing","resultingSelection","containsEvent","type","len","concat","ModelInjectedTextChangedEvent","InternalModelContentChangeEvent","rawContentChangedEvent","contentChangedEvent","_mergeChangeEvents","eol","isFlush","isEolChange","IUndoRedoService","ResourceEditStackSnapshot","resource","elements","UndoRedoGroup","_ID","id","nextOrder","None","UndoRedoSource","escapeNewLine","str","replace","TextChange","oldLength","oldText","oldEnd","oldPosition","newLength","newText","newEnd","newPosition","toString","_writeStringSize","_writeString","offset","charCodeAt","_readString","writeSize","write","read","dest","compressConsecutiveTextChanges","prevEdits","currEdits","TextChangeCompressor","compress","_prevEdits","_currEdits","_result","_resultLen","_prevLen","_prevDeltaOffset","_currLen","_currDeltaOffset","prevIndex","currIndex","prevEdit","_getPrev","currEdit","_getCurr","_acceptCurr","_acceptPrev","e1","e2","_splitCurr","_splitPrev","mergePrev","mergeCurr","_merge","_removeNoOps","_rebaseCurr","_rebasePrev","prevDeltaOffset","currDeltaOffset","edit","preText","substr","postText","edits","resultLen","prev","curr","CursorColumns","_nextVisibleColumn","codePoint","visibleColumn","tabSize","nextRenderTabStop","visibleColumnFromColumn","lineContent","textLen","text","iterator","nextGraphemeLength","columnFromVisibleColumn","lineContentLength","beforeVisibleColumn","beforeColumn","afterVisibleColumn","afterColumn","nextIndentTabStop","indentSize","prevRenderTabStop","prevIndentTabStop","BracketInfo","nestingLevel","nestingLevelOfEqualBracketType","isInvalid","BracketPairInfo","openingBracketRange","closingBracketRange","bracketPairNode","openingBracketInfo","openingBracket","bracketInfo","BracketPairWithMinIndentationInfo","minVisibleColumnIndentation","super","BracketPairsTree","didLanguageChange","languageId","brackets","textModel","getLanguageConfiguration","didChangeEmitter","denseKeyProvider","onDidChange","event","queuedTextEditsForInitialAstWithoutTokens","queuedTextEdits","tokenization","hasTokens","backgroundTokenizationState","initialAstWithoutTokens","astWithTokens","parseDocumentFromTextBuffer","getSingleLanguageBracketTokens","getLanguageId","tokenizer","getValue","handleDidChangeBackgroundTokenizationState","wasUndefined","fire","handleDidChangeTokens","ranges","map","r","handleEdits","handleContentChanged","change","fromModelContentChanges","tokenChange","combineTextEditInfos","flushQueue","previousAst","immutable","previousAstClone","getBracketsInRange","onlyColorizedBrackets","startOffset","endOffset","cb","node","collectBrackets","getBracketPairsInRange","includeMinIndentation","startLength","getStartPosition","endLength","getEndPosition","context","CollectBracketPairsContext","collectBracketPairs","getFirstBracketAfter","position","getFirstBracketBefore","nodeOffsetStart","nodeOffsetEnd","kind","lengths","child","children","level","levelPerBracketType","parentPairIsIncomplete","whileLoop","childCount","childrenLength","getChild","colorize","closingBracket","closesColorized","levelPerBracket","shouldContinue","openingBracketEnd","minIndentation","computeMinIndentation","curOffset","childOffset","BracketPairsTextModelPart","canBuildAST","getValueLength","languageConfigurationService","bracketPairsTree","_register","onDidChangeEmitter","bracketsRequested","handleLanguageConfigurationServiceChange","e","object","clear","updateBracketPairsTree","handleDidChangeOptions","handleDidChangeLanguage","handleDidChangeContent","store","disposable","dispose","getBracketPairsInRangeWithMinIndentation","findMatchingBracketUp","_bracket","_position","maxDuration","validatePosition","getLanguageIdAtPosition","closingBracketInfo","bracketsNew","getClosingBracketInfo","bracketPair","fromPositions","findLast","closes","bracket","toLowerCase","bracketsSupport","data","textIsBracket","stripBracketSearchCanceled","_findMatchingBracketUp","createTimeBasedContinueBracketSearchPredicate","matchBracket","filter","item","containsPosition","findLastMaxBy","compareRangesUsingStarts","continueSearchPredicate","_matchBracket","_establishBracketSearchOffsets","lineTokens","modeBrackets","tokenIndex","tokenCount","getCount","currentLanguageId","searchStartOffset","maxBracketLength","tokenEndOffset","getEndOffset","getStandardTokenType","searchEndOffset","getLineContent","tokenStartOffset","getStartOffset","getLineTokens","findTokenIndexAtOffset","currentModeBrackets","bestResult","foundBracket","findNextBracketInRange","forwardRegex","foundBracketText","_matchFoundBracket","textIsOpenBracket","BracketSearchCanceled","prevTokenIndex","prevModeBrackets","findPrevBracketInRange","reversedRegex","isOpen","matched","_findMatchingBracketDown","reversedBracketRegex","count","totalCallCount","searchPrevMatchingBracketInRange","INSTANCE","hitText","isClose","prevSearchInToken","searchInToken","bracketRegex","searchNextMatchingBracketInRange","lineCount","getLineCount","findPrevBracket","bracketConfig","tokenLanguageId","_toFoundBracket","findNextBracket","findEnclosingBrackets","strictContainsRange","savedCounts","counts","resetCounts","has","tmp","searchInRange","index","getValueInRange","getBracketInfo","startTime","Date","now","_searchCanceledBrand","ColorizedBracketPairsDecorationProvider","colorProvider","ColorProvider","colorizationOptions","getOptions","bracketPairColorizationOptions","bracketPairs","getDecorationsInRange","filterOutValidation","onlyMinimapDecorations","enabled","description","inlineClassName","getInlineClassName","independentColorPoolPerBracketType","toArray","getAllDecorations","unexpectedClosingBracketClassName","getInlineClassNameOfLevel","theme","collector","colors","addRule","getColor","colorValues","c","isTransparent","color","SpacesDiffResult","spacesDiff","looksLikeAlignment","aLength","bLength","aSpacesCnt","aTabsCount","j","bSpacesCnt","bTabsCount","tabsDiff","abs","guessIndentation","source","defaultTabSize","defaultInsertSpaces","linesCount","linesIndentedWithTabsCount","linesIndentedWithSpacesCount","previousLineText","previousLineIndentation","ALLOWED_TAB_SIZE_GUESSES","spacesDiffCount","currentLineLength","getLineLength","currentLineText","useCurrentLineText","currentLineHasContent","currentLineIndentation","currentLineSpacesCount","currentLineTabsCount","lenJ","charCode","getLineCharCode","currentSpacesDiff","insertSpaces","tabSizeScore","forEach","possibleTabSize","possibleTabSizeScore","getNodeColor","metadata","setNodeColor","getNodeIsVisited","setNodeIsVisited","getNodeIsForValidation","setNodeIsForValidation","getNodeIsInGlyphMargin","setNodeIsInGlyphMargin","_setNodeStickiness","stickiness","setCollapseOnReplaceEdit","IntervalNode","start","end","parent","left","right","delta","maxEnd","cachedVersionId","cachedAbsoluteStart","cachedAbsoluteEnd","reset","setOptions","className","glyphMarginClassName","collapseOnReplaceEdit","setCachedOffsets","absoluteStart","absoluteEnd","detach","SENTINEL","IntervalTree","root","requestNormalizeDelta","intervalSearch","filterOwnerId","onlyMarginDecorations","T","intervalStart","intervalEnd","nodeMaxEnd","nodeStart","nodeEnd","include","search","collectNodesFromOwner","collectNodesPostOrder","insert","rbTreeInsert","_normalizeDeltaIfNecessary","rbTreeDelete","resolveNode","initialNode","acceptReplace","textLength","forceMoveMarkers","nodesOfInterest","searchForEditing","editDelta","recomputeMaxEnd","noOverlapReplace","nodeAcceptEdit","normalizeDelta","adjustMarkerBeforeColumn","markerOffset","markerStickToPreviousCharacter","checkOffset","moveSemantics","nodeStickiness","getNodeStickiness","startStickToPreviousCharacter","endStickToPreviousCharacter","deletingCnt","insertingCnt","commonLength","startDone","endDone","getCollapseOnReplaceEdit","deltaColumn","newNode","z","x","zAbsoluteStart","zAbsoluteEnd","intervalCompare","treeInsert","recomputeMaxEndWalkToRoot","y","leftRotate","rightRotate","leftest","resetSentinel","yWasRed","w","computeMaxEnd","leftMaxEnd","rightMaxEnd","aStart","aEnd","bStart","bEnd","TreeNode","piece","size_left","lf_left","next","righttest","calculateSize","calculateLF","lineFeedCnt","tree","rbDelete","recomputeTreeMetadata","newSizeLeft","newLFLeft","lf_delta","updateTreeMetadata","fixInsert","lineFeedCntDelta","AverageBufferSize","createUintArray","arr","Uint16Array","Uint32Array","LineStarts","lineStarts","cr","lf","crlf","isBasicASCII","createLineStartsFast","readonly","rLength","chr","Piece","bufferIndex","StringBuffer","buffer","PieceTreeSnapshot","BOM","_pieces","_tree","_BOM","_index","iterate","getPieceContent","PieceTreeSearchCache","limit","_limit","_cache","nodePos","nodeStartOffset","get2","nodeStartLineNumber","nodePosition","shift","validate","hasInvalidVal","newArr","entry","PieceTreeBase","chunks","eolNormalized","_buffers","_lastChangeBufferPos","line","_lineCnt","_length","_EOL","_EOLLength","_EOLNormalized","lastNode","rbInsertRight","_searchCache","_lastVisitedLine","computeBufferMetadata","normalizeEOL","floor","averageBufferSize","tempChunk","tempChunkLen","getNodeContent","getEOL","setEOL","newEOL","createSnapshot","getOffsetAt","leftLen","getAccumulatedValue","getPositionAt","lfCnt","originalOffset","out","getIndexOf","remainder","startPosition","nodeAt2","endPosition","getValueInRange2","offsetInBuffer","ret","getLinesContent","lines","linesLength","currentLine","danglingCR","pieceLength","pieceStartLine","pieceEndLine","pieceStartOffset","getLength","getLineRawContent","_getCharCode","matchingNode","targetOffset","findMatchesInNode","searcher","startCursor","endCursor","searchData","captureMatches","limitResultCount","startOffsetInBuffer","m","searchText","_wordSeparators","positionInBuffer","getLineFeedCnt","retStartColumn","retEndColumn","findMatchesLineByLine","searchRange","wordSeparators","regex","currentNode","lineBreakCnt","nextLineStartOffset","_findMatchesInLine","deltaOffset","simpleSearch","searchString","searchStringLen","lastMatchIndex","indexOf","nodeAt","insertPosInBuffer","appendToNode","insertContentToNodeLeft","nodesToDel","newRightPiece","shouldCheckCRLF","endWithCR","nodeCharCodeAt","newStart","startWithLF","previousPos","deleteNodeTail","newPieces","createNewPieces","tmpNode","k","deleteNodes","insertContentToNodeRight","pieces","rbInsertLeft","cnt","startNode","endNode","startSplitPosInBuffer","endSplitPosInBuffer","validateCRLFWithPrevNode","deleteNodeHead","validateCRLFWithNextNode","shrinkNode","nPiece","adjustCarriageReturnFromNext","low","high","mid","midStop","midStart","previousCharOffset","cursor","nodes","lastChar","splitText","endIndex","endPos","newPiece","prevAccumulatedValue","accumulatedValue","originalLineNumber","pos","lineCnt","realLineCnt","expectedLineStartIndex","originalLFCnt","originalEndOffset","newEndOffset","newLineFeedCnt","size_delta","originalStartOffset","originalStartPos","originalEndPos","oldLFCnt","hitCRLF","prevStartOffset","pop","oldLineFeedCnt","prevAccumualtedValue","offsetOfNode","newOffset","val","nextNode","fixCRLF","prevNewLength","prevNewLFCnt","callback","leftRet","p","prevNode","PieceTreeTextBuffer","containsRTL","containsUnusualLineTerminators","_onDidChangeContent","_mightContainNonBasicASCII","_mightContainRTL","_mightContainUnusualLineTerminators","_pieceTree","mightContainRTL","mightContainUnusualLineTerminators","resetMightContainUnusualLineTerminators","mightContainNonBasicASCII","getBOM","preserveBOM","getRangeAt","isEmpty","lineEnding","_getEndOfLine","getValueLengthInRange","eolOffsetCompensation","desiredEOL","actualEOL","getCharacterCountInRange","fromOffset","toOffset","strings","getLineFirstNonWhitespaceColumn","getLineLastNonWhitespaceColumn","Error","applyEdits","rawOperations","recordTrimAutoWhitespace","computeUndoEdits","canReduceOperations","operations","op","_isTracked","validatedRange","textMightContainNonBasicASCII","validText","eolCount","firstLineLength","lastLineLength","strEOL","bufferEOL","sortIndex","identifier","rangeOffset","rangeLength","Boolean","isAutoWhitespaceEdit","_sortOpsAscending","hasTouchingRanges","rangeEnd","nextRangeStart","isBeforeOrEqual","isBefore","_reduceOperations","reverseRanges","_getInverseEditRanges","newTrimAutoWhitespaceCandidates","reverseRange","currentLineContent","oldContent","reverseOperations","reverseRangeDeltaOffset","bufferText","reverseRangeOffset","textChange","contentChanges","_doApplyEdits","trimAutoWhitespaceLineNumbers","prevContent","_toSingleEditOperation","firstEditRange","lastEditRange","entireEditRange","lastEndLineNumber","lastEndColumn","operation","join","_sortOpsDescending","delete","contentChangeRange","prevOpEndLineNumber","prevOpEndColumn","prevOp","resultRange","compareRangesUsingEnds","PieceTreeTextBufferFactory","_chunks","_bom","_cr","_lf","_crlf","_containsRTL","_containsUnusualLineTerminators","_isBasicASCII","_normalizeEOL","_getEOL","defaultEOL","totalEOLCount","totalCRCount","newLineStart","textBuffer","PieceTreeTextBufferBuilder","_hasPreviousChar","_previousChar","_tmpLineStarts","acceptChunk","chunk","_acceptChunk1","allowEmptyStrings","_acceptChunk2","String","fromCharCode","createLineStarts","finish","_finish","lastChunk","newLineStarts","FixedArray","_default","_store","insertArr","arrayFill","deleteIndex","deleteCount","splice","insertIndex","insertCount","ContiguousMultilineTokens","_startLineNumber","_tokens","tokens","appendLineTokens","ContiguousMultilineTokensBuilder","last","finalize","TokenizerWithStateStore","tokenizationSupport","initialState","getInitialState","TrackingTokenizationStateStore","getStartState","getFirstInvalidLine","TokenizerWithStateStoreAndTextModel","_textModel","_languageIdCodec","updateTokensUntilLine","builder","lineToTokenize","safeTokenize","startState","setEndState","endState","getTokenTypeIfInsertingCharacter","character","lineStartState","tokenizeLineWithEdit","curLineContent","newLineContent","hasAccurateTokensForLine","getFirstInvalidEndStateLineNumberOrMax","isCheapToTokenize","firstInvalidLineNumber","tokenizeHeuristically","heuristicTokens","state","guessStartState","nonWhitespaceColumn","likelyRelevantLines","newNonWhitespaceIndex","reverse","_tokenizationStateStore","TokenizationStateStore","_invalidEndStatesLineNumbers","RangePriorityQueueImpl","addRange","getEndState","acceptChange","newLineCount","addRangeAndResize","endLineNumberExclusive","acceptChanges","invalidateEndStateRange","getFirstInvalidEndStateLineNumber","Number","MAX_SAFE_INTEGER","allStatesValid","_lineEndStates","oldState","equals","_ranges","findIndex","contains","endExclusive","idxFirstMightBeIntersecting","idxFirstIsAfter","newRange","endEx","languageIdCodec","hasEOL","tokenizeEncoded","clone","nullTokenize","encodeLanguageId","convertToEndOffset","DefaultBackgroundTokenizer","_tokenizerWithStateStore","_backgroundTokenStore","_isDisposed","_isScheduled","handleChanges","_beginBackgroundTokenization","isAttachedToEditor","_hasLinesToTokenize","deadline","_backgroundTokenizeWithDeadline","endTime","timeRemaining","execute","_backgroundTokenizeForAtLeast1ms","sw","elapsed","_tokenizeOneInvalidLine","setTokens","checkFinished","firstInvalidLine","backgroundTokenizationFinished","requestTokens","AttachedViews","_onDidChangeVisibleRanges","onDidChangeVisibleRanges","_views","Set","attachView","view","AttachedViewImpl","detachView","handleStateChange","setVisibleLines","visibleLines","stabilized","visibleLineRanges","AttachedViewHandler","lineRanges","_lineRanges","_refreshTokens","runner","update","_computedLineRanges","cancel","schedule","AbstractTokens","_backgroundTokenizationState","_onDidChangeBackgroundTokenizationState","onDidChangeBackgroundTokenizationState","_onDidChangeTokens","onDidChangeTokens","tokenizeIfCheap","forceTokenization","TreeSitterTokens","_treeSitterService","_tokenizationSupport","_initialize","newLanguage","_lastLanguageId","rawTokens","createEmpty","resetTokenization","fireTokenChangeEvent","semanticTokensApplied","handleDidChangeAttached","getParseResult","EMPTY_LINE_TOKENS","ContiguousTokensEditing","deleteBeginning","toChIndex","deleteEnding","fromChIndex","toUint32Array","lineTextLength","tokensCount","fromTokenIndex","findIndexInTokensArray","fromTokenStartOffset","lastEnd","subarray","append","_otherTokens","myTokens","otherTokens","otherTokensCount","chIndex","ContiguousTokensStore","_lineTokens","_len","flush","getTokens","topLevelLanguageId","lineIndex","rawLineTokens","getDefaultMetadata","_massageTokens","hasDifferentLanguageId","byteOffset","byteLength","_ensureLine","_deleteLines","_insertLines","arrays","checkEquality","oldTokens","_equals","_a","_b","acceptEdit","_acceptDeleteRange","_acceptInsertText","firstLineIndex","lastLineIndex","lastLineTokens","setMultilineTokens","element","minChangedLineNumber","maxChangedLineNumber","hasChange","SparseTokensStore","_isComplete","isComplete","setPartial","_range","_firstRange","getRange","_lastRange","plusRange","insertPosition","removeTokens","split","addSparseTokens","aTokens","bTokens","_findFirstPieceWithLine","aLen","bLen","aIndex","lastEndOffset","emitToken","bIndex","bStartCharacter","getStartCharacter","bEndCharacter","getEndCharacter","bMetadata","getMetadata","bMask","aMask","aMergeIndex","firstCharCode","TokenizationTextModelPart_1","__param","paramIndex","decorator","target","TokenizationTextModelPart","_bracketPairsTextModelPart","_languageId","_attachedViews","_languageService","_languageConfigurationService","_semanticTokens","_onDidChangeLanguage","onDidChangeLanguage","_onDidChangeLanguageConfiguration","onDidChangeLanguageConfiguration","_tokensDisposables","affects","changedLanguages","includes","createPreferredTokenProvider","createGrammarTokens","GrammarTokens","createTreeSitterTokens","createTokens","useTreeSitter","needsReset","_emitModelTokensChangedEvent","validateLineNumber","syntacticTokens","_isDisposing","setSemanticTokens","hasCompleteSemanticTokens","hasSomeSemanticTokens","setPartialSemanticTokens","changedRange","validateRange","getWordAtPosition","assertNotDisposed","rbStartOffset","rbEndOffset","_findLanguageBoundaries","rightBiasedWord","getWordDefinition","lbStartOffset","lbEndOffset","leftBiasedWord","getWordUntilPosition","wordAtPosition","word","setLanguageId","oldLanguage","decorators","desc","d","arguments","Object","getOwnPropertyDescriptor","Reflect","decorate","defineProperty","__decorate","ITreeSitterParserService","attachedViews","_tokenizer","_defaultBackgroundTokenizer","_backgroundTokenizer","_debugBackgroundTokenizer","_attachedViewStates","refreshRanges","deleteAndDispose","_debugBackgroundTokens","_debugBackgroundStates","isTooLargeForTokenization","initializeTokenization","firstInvalidEndStateLineNumber","createBackgroundTokenizer","backgroundTokenizerShouldOnlyVerifyTokens","refreshAllVisibleLineTokens","joinMany","_","s","refreshRange","changedTokens","backgroundResult","reportMismatchingTokens","validatedPosition","TextModel_1","createTextBuffer","factory","createTextBufferFactory","model","snapshot","createTextBufferFactoryFromSnapshot","MODEL_ID","TextModelSnapshot","_source","_eos","resultCnt","resultLength","invalidFunc","TextModel","_MODEL_SYNC_LIMIT","LARGE_FILE_SIZE_THRESHOLD","LARGE_FILE_LINE_COUNT_THRESHOLD","LARGE_FILE_HEAP_OPERATION_THRESHOLD","DEFAULT_CREATION_OPTIONS","isForSimpleWidget","detectIndentation","trimAutoWhitespace","largeFileOptimizations","resolveOptions","guessedIndentation","_tokenizationTextModelPart","onDidChangeContent","listener","_eventEmitter","slowEvent","onDidChangeContentOrInjectedText","fastEvent","_onDidChangeInjectedText","__isDisposing","_bracketPairs","guides","_guidesTextModelPart","languageIdOrSelection","creationOptions","associatedResource","_undoRedoService","instantiationService","_onWillDispose","onWillDispose","_onDidChangeDecorations","DidChangeDecorationsEmitter","affectedInjectedTextLines","handleBeforeFireDecorationsChangedEvent","onDidChangeDecorations","_onDidChangeOptions","onDidChangeOptions","_onDidChangeAttached","onDidChangeAttached","DidChangeContentEmitter","_languageSelectionListener","_deltaDecorationCallCnt","_associatedResource","parse","_attachedEditorCount","_buffer","_bufferDisposable","_options","_setLanguage","_decorationProvider","createInstance","bufferLineCount","bufferTextLength","_isTooLargeForTokenization","_isTooLargeForHeapOperation","_isTooLargeForSyncing","_versionId","_alternativeVersionId","_initialUndoRedoSnapshot","_instanceId","_lastDecorationId","_decorations","_decorationsTree","DecorationsTrees","_commandManager","_isUndoing","_isRedoing","_trimAutoWhitespaceLines","beginDeferredEmit","endDeferredEmit","requestRichLanguageFeatures","emptyDisposedTextBuffer","_assertNotDisposed","_emitContentChangedEvent","rawChange","setValue","_setValueFromTextBuffer","_createContentChanged2","getVersionId","textBufferDisposable","oldFullModelRange","getFullModelRange","oldModelValueLength","getLineMaxColumn","_increaseVersionId","_onBeforeEOLChange","_onAfterEOLChange","ensureAllNodesHaveRanges","allDecorations","onBeforeAttached","onBeforeDetached","getAttachedEditorCount","isTooLargeForSyncing","isTooLargeForHeapOperation","isDisposed","isDominatedByLongLines","smallLineCharCount","longLineCharCount","lineLength","uri","getFormattingOptions","updateOptions","_newOpts","originalIndentSize","bracketColorizationOptions","newOpts","createChangeEvent","normalizeIndentation","removeUnusualLineTerminators","selections","matches","findMatches","pushEditOperations","getAlternativeVersionId","getInitialUndoRedoSnapshot","rawPosition","_validatePosition","rawOffset","_overwriteVersionId","_overwriteAlternativeVersionId","newAlternativeVersionId","_overwriteInitialUndoRedoSnapshot","newInitialUndoRedoSnapshot","fullModelRange","fullModelValue","rawRange","getEndOfLineSequence","getLineMinColumn","_validateRangeRelaxedNoAllocations","initialStartLineNumber","initialStartColumn","isNaN","maxColumn","initialEndLineNumber","initialEndColumn","_isValidPosition","validationType","charCodeBefore","_lineNumber","_column","_isValidRange","charCodeBeforeStart","charCodeBeforeEnd","startInsideSurrogatePair","endInsideSurrogatePair","modifyPosition","candidate","rawSearchScope","isRegex","matchCase","searchRanges","isArray","every","searchScope","isIRange","d1","d2","uniqueSearchRanges","matchMapper","reduce","areIntersecting","parseSearchRequest","findNextMatch","rawSearchStart","searchStart","findPreviousMatch","pushStackElement","popStackElement","pushEOL","_validateEditOperation","rawOperation","_validateEditOperations","beforeCursorState","editOperations","cursorStateComputer","group","_pushEditOperations","incomingEdits","editsAreNearCursors","sel","foundEditNearSel","editRange","selIsAbove","selIsBelow","trimLineNumber","maxLineColumn","allowTrimLine","editText","charAt","trimRange","pushEditOperation","_applyUndo","resultingAlternativeVersionId","rangeStart","_applyUndoRedoEdits","_applyRedo","oldLineCount","rawContentChanges","deletingLinesCnt","insertingLinesCnt","editingLinesCnt","changeLineCountDelta","currentEditStartLineNumber","firstEditLineNumber","lastInsertedLineNumber","decorationsWithInjectedTextInEditedRange","getInjectedTextInInterval","injectedTextInEditedRange","injectedTextInEditedRangeQueue","editLineNumber","currentEditLineNumber","takeFromEndWhile","decorationsInCurrentLine","spliceStartLineNumber","spliceLineNumber","newLines","takeWhile","reverseEdits","undo","canUndo","redo","canRedo","lineChangeEvents","from","_getInjectedTextInLine","changeDecorations","_changeDecorations","changeAccessor","addDecoration","_deltaDecorationsImpl","changeDecoration","_changeDecorationImpl","changeDecorationOptions","_changeDecorationOptionsImpl","_normalizeOptions","removeDecoration","deltaDecorations","oldDecorations","newDecorations","console","warn","_getTrackedRange","getDecorationRange","_setTrackedRange","newStickiness","TRACKED_RANGE_OPTIONS","removeAllDecorationsWithOwnerId","getDecorationOptions","decorationId","getNodeRange","getLineDecorations","getLinesDecorations","_endLineNumber","_getDecorationsInRange","getOverviewRulerDecorations","getAll","getInjectedTextDecorations","getAllInjectedText","t","getAllMarginDecorations","filterRange","getAllInInterval","oldRange","recordLineAffectedByInjectedText","checkAffectedAndFire","nodeWasInOverviewRuler","overviewRuler","nodeIsInOverviewRuler","nodeRange","movedInOverviewRuler","changedWhetherInjectedText","isOptionsInjectedText","isNodeInjectedText","oldDecorationsIds","suppressEvents","oldDecorationsLen","oldDecorationIndex","newDecorationsLen","newDecorationIndex","internalDecorationId","newDecoration","setLanguage","normalizePosition","affinity","getLineIndentColumn","indent","indentOfLine","isNodeInOverviewRuler","_decorationsTree0","_decorationsTree1","_injectedTextDecorationsTree","host","_ensureNodesHaveRanges","_intervalSearch","r0","r1","r2","showIfCollapsed","overviewRulerOnly","_search","_resolveNode","cleanClassName","DecorationOptions","darkColor","ModelDecorationOverviewRulerOptions","_resolvedColor","Center","_resolveColor","invalidateCachedColor","ModelDecorationGlyphMarginOptions","persistLane","ModelDecorationMinimapOptions","sectionHeaderStyle","sectionHeaderText","fromHex","ModelDecorationInjectedTextOptions","inlineClassNameAffectsLetterSpacing","attachedData","cursorStops","ModelDecorationOptions","register","createDynamic","blockClassName","blockDoesNotCollapse","blockIsAfterEnd","blockPadding","zIndex","shouldFillLineOnLineBreak","hoverMessage","glyphMarginHoverMessage","lineNumberHoverMessage","isWholeLine","minimap","glyphMargin","linesDecorationsClassName","lineNumberClassName","linesDecorationsTooltip","firstLineDecorationClassName","marginClassName","beforeContentClassName","afterContentClassName","hideInCommentTokens","hideInStringTokens","EMPTY","handleBeforeFire","_actual","_affectedInjectedTextLines","_deferredCnt","_shouldFireDeferred","_affectsMinimap","_affectsOverviewRuler","_affectsGlyphMargin","_affectsLineNumber","doFire","tryFire","affectsMinimap","affectsOverviewRuler","affectsGlyphMargin","affectsLineNumber","_fastEmitter","_slowEmitter","_deferredEvent","_utf16LE_TextDecoder","_utf16BE_TextDecoder","_platformTextDecoder","getUTF16LE_TextDecoder","TextDecoder","getPlatformTextDecoder","decodeUTF16LE","compatDecodeUTF16LE","decode","StringBuilder","capacity","_capacity","_completedStrings","_bufferLength","build","_flushBuffer","_buildBuffer","bufferString","appendCharCode","remainingSpace","appendASCIICharCode","appendString","strLen","_registry","registerSingleton","ctorOrDescriptor","supportsDelayedInstantiation","getSingletonServiceDescriptors","hasBuffer","Buffer","textDecoder","Uint8Array","VSBuffer","wrap","actual","isBuffer","readUInt16LE","writeUInt16LE","destination","readUInt32BE","writeUInt32BE","readUInt8","writeUInt8","TextEditInfo","lift","BeforeEditPositionMapper","nextEditIdx","deltaOldToNewLineCount","deltaOldToNewColumnCount","deltaLineIdxInOld","TextEditInfoCache","getOffsetBeforeChange","adjustNextEdit","translateCurToOld","getDistanceToNextChange","nextEdit","nextChangeOffset","translateOldToCur","offsetObj","oldOffsetObj","columnCount","nextEditEndOffsetInCur","endOffsetAfterObj","nextEditEndOffsetInCurObj","nextEditEndOffsetBeforeInCurObj","endOffsetBeforeObj","lineDelta","previousColumnDelta","columnDelta","RichEditBracket","open","close","_richEditBracketBrand","_openSet","_toSet","_closeSet","RichEditBrackets","_brackets","_richEditBracketsBrand","N","areOverlapping","aOpen","aClose","bOpen","bClose","mergeGroups","g1","g2","newG","oldG","g","currentOpen","currentClose","groupFuzzyBrackets","currentIndex","collectSuperstrings","unique","lengthcmp","createBracketOrRegExp","getRegexForBracketPair","toReversedString","getReversedRegexForBracketPair","getRegexForBrackets","getReversedRegexForBrackets","seen","prepareBracketForRegExp","insertWordBoundaries","test","regexStr","lastInput","lastOutput","BracketsUtils","_findPrevBracketInText","reversedText","match","matchOffset","matchLength","absoluteMatchOffset","reversedSubstr","findNextBracketInText","BaseAstNode","PairAstNode","missingOpeningBracketIds","listHeight","canBeReused","openBracketIds","deepClone","ListAstNode","create23","item3","missingBracketIds","Immutable23ListAstNode","TwoThreeListAstNode","ImmutableArrayListAstNode","_missingOpeningBracketIds","cachedMinIndentation","throwIfImmutable","makeLastElementMutable","lastChild","mutable","toMutable","setChild","makeFirstElementMutable","firstChild","lastLength","handleChildrenChanged","unopenedBrackets","_item3","_item1","_item2","appendChildOfSameHeight","unappendChild","prependChildOfSameHeight","unprependChild","ArrayListAstNode","_children","unshift","emptyArray","ImmutableLeafAstNode","TextAstNode","_openedBracketIds","firstNonWsColumn","BracketAstNode","bracketIds","bracketText","InvalidBracketAstNode","closingBrackets","openedBracketIds","IndentAction","StandardAutoClosingPairConditional","_neutralCharacter","_neutralCharacterSearched","_inString","_inComment","_inRegEx","notIn","isOK","standardToken","shouldAutoClose","getTokenCount","standardTokenType","_findNeutralCharacterInRange","toCharCode","findNeutralCharacter","AutoClosingPairs","autoClosingPairs","autoClosingPairsOpenByStart","autoClosingPairsOpenByEnd","autoClosingPairsCloseByStart","autoClosingPairsCloseByEnd","autoClosingPairsCloseSingleChar","pair","appendEntry","EDITOR_MODEL_DEFAULTS","NullState","nullTokenizeEncoded","GuidesTextModelPart","_computeIndentLevel","getActiveIndentGuide","minLineNumber","maxLineNumber","foldingRules","offSide","up_aboveContentLineIndex","up_aboveContentLineIndent","up_belowContentLineIndex","up_belowContentLineIndent","up_resolveIndents","down_aboveContentLineIndex","down_aboveContentLineIndent","down_belowContentLineIndex","down_belowContentLineIndent","down_resolveIndents","goUp","goDown","initialIndent","distance","upLineNumber","downLineNumber","upLineIndentLevel","currentIndent","ceil","_getIndentLevelForWhitespaceLine","downLineIndentLevel","getLinesBracketGuides","activePosition","activeBracketPairRange","bracketsContainingActivePosition","bp","strictContainsPosition","BracketPairGuidesClassNames","isActive","equalsRange","includeInactive","highlightActive","activeClassName","horizontalGuides","Enabled","EnabledForActive","endVisibleColumn","getVisibleColumnFromPosition","startVisibleColumn","guideVisibleColumn","renderHorizontalEndLineAtTheBottom","visibleGuideStartLineNumber","visibleGuideEndLineNumber","l","getLinesIndentGuides","aboveContentLineIndex","aboveContentLineIndent","belowContentLineIndex","belowContentLineIndent","resultIndex","BracketTokens","createFromLanguage","configuration","getId","openingBrackets","openingTextId","getOpeningBrackets","hasRegExp","_regExpGlobal","getRegExpStr","keys","escaped","regExpGlobal","regExpStr","RegExp","getToken","findClosingTokenText","openingBracketIds","closingText","info","LanguageAgnosticBracketTokens","languageIdToBracketTokens","singleLanguageBracketTokens","CharacterPairSupport","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_QUOTES","DEFAULT_AUTOCLOSE_BEFORE_LANGUAGE_DEFINED_BRACKETS","config","_autoClosingPairs","el","__electricCharacterSupport","docComment","_autoCloseBeforeForQuotes","autoCloseBefore","_autoCloseBeforeForBrackets","_surroundingPairs","surroundingPairs","getAutoClosingPairs","getAutoCloseBeforeSet","forQuotes","getSurroundingPairs","BracketElectricCharacterSupport","richEditBrackets","_richEditBrackets","getElectricCharacters","onElectricCharacter","textBeforeBracket","getActualLineContentBefore","matchOpenBracket","resetGlobalRegex","reg","global","lastIndex","IndentRulesSupport","indentationRules","_indentationRules","shouldIncrease","increaseIndentPattern","shouldDecrease","decreaseIndentPattern","shouldIndentNextLine","indentNextLinePattern","shouldIgnore","unIndentedLinePattern","getIndentMetadata","OnEnterSupport","opts","openRegExp","_createOpenBracketRegExp","closeRegExp","_createCloseBracketRegExp","_regExpRules","onEnterRules","onEnter","autoIndent","beforeEnterText","afterEnterText","rule","beforeText","afterText","obj","action","indentAction","IndentOutdent","Indent","_safeRegExp","def","err","LanguageBracketsConfiguration","filterValidBrackets","openingBracketInfos","closing","OpeningBracketKind","closingBracketInfos","opening","openingColorized","ClosingBracketKind","colorizedBracketPairs","_openingBrackets","cachedValues","v","_closingBrackets","values","getOpeningBracketInfo","getBracketRegExp","BracketKindBase","openedBrackets","isOpeningBracket","openingColorizedBrackets","LanguageConfigurationServiceChangeEvent","ILanguageConfigurationService","LanguageConfigurationService","configurationService","languageService","LanguageConfigurationRegistry","configurations","languageConfigKeys","customizedLanguageConfigKeys","onDidChangeConfiguration","globalConfigChanged","some","localConfigChanged","overrides","overrideLangName","isRegisteredLanguageId","priority","registry","languageConfig","ResolvedLanguageConfiguration","customizedConfig","overrideIdentifier","validateBracketPairs","getCustomizedLanguageConfig","combineLanguageConfigurations","underlyingConfig","computeConfig","getIndentationAtPosition","indentation","ComposedLanguageConfiguration","_resolved","_entries","_order","LanguageConfigurationContribution","getResolvedConfiguration","_resolve","cmp","configs","comments","wordPattern","folding","LanguageConfigurationChangeEvent","_onDidChange","entries","_electricCharacter","_onEnterSupport","_handleComments","characterPair","wordDefinition","indentRulesSupport","electricCharacter","conf","commentRule","lineComment","lineCommentToken","blockComment","blockStart","blockEnd","blockCommentStartToken","blockCommentEndToken","Token","bracketId","astNode","TextBufferTokenizer","bracketTokens","reader","NonPeekableTextBufferTokenizer","_offset","didPeek","peeked","textBufferLineCount","textBufferLastLineLength","skip","setPosition","token","peek","lineIdx","lineCharOffset","lineTokenOffset","peekedToken","startLineIdx","startLineCharOffset","lengthHeuristic","peekedBracketToken","tokenMetadata","isOther","getTokenType","containsBracketType","containsBalancedBrackets","regexp","exec","FastTokenizer","curLineCount","lastLineBreakOffset","lastTokenEndOffset","lastTokenEndLine","smallTextTokens0Line","smallTextTokens1Line","colCount","LineTokens","defaultTokenMetadata","decoder","defaultMetadata","createFromTextAndMetadata","fullText","_lineTokensBrand","_tokensCount","_text","slicedEquals","sliceFromTokenIndex","sliceTokenCount","to","decodeLanguageId","getForeground","getClassName","getClassNameFromMetadata","getInlineStyle","colorMap","getInlineStyleFromMetadata","getPresentation","getPresentationFromMetadata","inflate","sliceAndInflate","SliceLineTokens","lastTokenIndex","desiredIndex","withInserted","insertTokens","nextOriginalTokenIdx","nextInsertTokenIdx","newTokens","nextOriginalTokenEndOffset","nextInsertToken","getTokenText","_startOffset","_endOffset","_deltaOffset","_firstTokenIndex","adjustedTokenIndex","getStandardTokenTypeAtPosition","concat23TreesOfSameHeight","createImmutableLists","heightDiff","node1","node2","list","nodeToAppend","curNode","parents","nodeToAppendOfCorrectHeight","nodeToPrependOfCorrectHeight","prepend","NodeReader","lastOffset","nextNodes","offsets","idxs","readLongestNodeAt","predicate","lastOrUndefined","curNodeOffset","nextNodeAfterCurrent","nextChildIdx","getNextChildIdx","currentOffset","curIdx","parseDocument","oldNode","Parser","_itemsConstructed","_itemsFromCache","oldNodeReader","positionMapper","parseList","tryReadChildFromCache","parseChild","readNode","height","first","second","concat23Trees","maxCacheableLength","cachedNode","nextToken","textEditInfoFirst","textEditInfoSecond","s0ToS1Map","toLengthMapping","s1ToS2Map","modified","lengthBefore","lengthAfter","curItem","dequeue","nextS0ToS1MapWithS1LengthOf","s1Length","remainingItem","splitAt","LengthMapping","pushEdit","lastResult","s0offset","s1ToS2","s0Length","s0EndOffset","s1","s0startOffset","remainingLengthAfter","textEditInfos","textEditInfo","spaceLength","SyncDescriptor","ctor","staticArguments","HorizontalGuidesState","IndentGuide","horizontalLine","forWrappedLinesAfterColumn","forWrappedLinesBeforeOrAtColumn","IndentGuideHorizontalLine","top","TextModelPart","computeIndentLevel","chCode","lengthDiff","startLineCount","startColumnCount","endLineCount","endColumnCount","toLength","lengthZero","lengthIsZero","factor","lengthToObj","lengthGetLineCount","lengthGetColumnCountIfZeroLineCount","lengthAdd","l1","l2","sumLengths","lengthFn","lengthEquals","length1","length2","lengthDiffNonNegative","lineCount1","lineCount2","colCount2","lengthLessThan","lengthLessThanEqual","lengthGreaterThanEqual","positionToLength","lengthsToRange","lengthStart","lengthEnd","lengthOfString","ModelService_1","ModelData","_modelEventListeners","DEFAULT_EOL","DisposedModelInfo","initialUndoRedoSnapshot","time","sharesUndoRedoStack","heapSize","sha1","alternativeVersionId","ModelService","MAX_MEMORY_FOR_CLOSED_FILES_UNDO_STACK","_configurationService","_resourcePropertiesService","_instantiationService","_onModelAdded","onModelAdded","_onModelRemoved","onModelRemoved","_onModelModeChanged","onModelLanguageChanged","_modelCreationOptionsByLanguageAndResource","_models","_disposedModels","_disposedModelsHeapSize","_updateModelOptions","_readModelOptions","editor","parsedTabSize","parseInt","parsedIndentSize","newDefaultEOL","bracketPairColorization","language","_shouldRestoreUndoStack","getCreationOptions","oldOptionsByLanguageAndResource","modelId","modelData","affectsConfiguration","oldOptions","newOptions","_setModelOptionsForModel","currentOptions","_insertDisposedModel","disposedModelData","_removeDisposedModel","_ensureDisposedModelsHeapSize","maxModelsHeapSize","disposedModels","disposedModel","restoreSnapshot","_createModelData","getElements","sha1Computer","_getSHA1Computer","sha1IsEqual","canComputeSHA1","computeSHA1","past","matchesResource","setModel","future","setElementsValidFlag","createModel","languageSelection","getModels","getModel","_schemaShouldMaintainUndoRedoElements","scheme","file","vscodeRemote","vscodeUserData","vscodeNotebookCell","getUriComparisonKey","maintainUndoRedoStack","maxMemory","oldLanguageId","newLanguageId","DefaultModelSHA1Computer","ITextResourcePropertiesService","MAX_MODEL_SIZE","shaComputer","digest","firstNonWhitespaceIndex","spacesCnt","tabsCnt","_normalizeIndentationFromWhitespace","ITextResourceConfigurationService","createScopedLineTokens","desiredLanguageId","firstTokenIndex","ScopedLineTokens","firstCharOffset","lastCharOffset","_scopedLineTokensBrand","_lastTokenIndex","_lastCharOffset","toIViewLineTokens","ignoreBracketsInToken","uriGetComparisonKey","SingleModelEditStackData","getModelEOL","beforeVersionId","afterVersionId","beforeEOL","afterEOL","afterCursorState","textChanges","_writeSelectionsSize","_writeSelections","selection","selectionStartLineNumber","selectionStartColumn","positionLineNumber","positionColumn","_readSelections","serialize","necessarySize","deserialize","changeCount","SingleModelEditStackElement","isUri","label","code","_data","canAppend","MultiModelEditStackElement","resources","_editStackElementsArr","editStackElement","editStackElements","_isOpen","_editStackElementsMap","_delegate","prepareUndoRedo","isEditStackElement","EditStack","undoRedoService","_model","lastElement","getLastElement","removeElements","_getOrCreateEditStackElement","newElement","pushElement","inverseEditOperations","_computeCursorState"],"sourceRoot":""}